SCRIPT  /opt/homebrew/Cellar/neovim/0.11.0/share/nvim/runtime/ftplugin/lua.vim
Sourced 1 time
Total time:   0.000303
 Self time:   0.000303

count  total (s)   self (s)
                            " Vim filetype plugin file.
                            " Language:		Lua
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " Previous Maintainer:	Max Ischenko <mfi@ukr.net>
                            " Contributor:		Dorai Sitaram <ds26@gte.com>
                            "			C.D. MacEachern <craig.daniel.maceachern@gmail.com>
                            "			Phạm Bình An <phambinhanctb2004@gmail.com>
                            " Last Change:		2025 Feb 27
                            
    1              0.000005 if exists("b:did_ftplugin")
                              finish
    1              0.000001 endif
    1              0.000003 let b:did_ftplugin = 1
                            
                            " keep in sync with syntax/lua.vim
    1              0.000003 if !exists("lua_version")
                              " Default is lua 5.3
                              let lua_version = 5
                              let lua_subversion = 3
    1              0.000002 elseif !exists("lua_subversion")
                              " lua_version exists, but lua_subversion doesn't. In this case set it to 0
                              let lua_subversion = 0
    1              0.000000 endif
                            
    1              0.000003 let s:cpo_save = &cpo
    1              0.000008 set cpo&vim
                            
    1              0.000005 setlocal comments=:---,:--
    1              0.000003 setlocal commentstring=--\ %s
    1              0.000004 setlocal formatoptions-=t formatoptions+=croql
                            
    1              0.000004 let &l:define = '\<function\|\<local\%(\s\+function\)\='
                            
    1              0.000003 let &l:include = '\<\%(\%(do\|load\)file\|require\)\s*('
    1              0.000005 setlocal includeexpr=s:LuaInclude(v:fname)
    1              0.000003 setlocal suffixesadd=.lua
                            
    1              0.000002 let b:undo_ftplugin = "setl cms< com< def< fo< inc< inex< sua<"
                            
    1              0.000003 if exists("loaded_matchit") && !exists("b:match_words")
    1              0.000001   let b:match_ignorecase = 0
    1              0.000009   let b:match_words =
                            	\ '\<\%(do\|function\|if\)\>:' ..
                            	\ '\<\%(return\|else\|elseif\)\>:' ..
                            	\ '\<end\>,' ..
                            	\ '\<repeat\>:\<until\>,' ..
                            	\ '\%(--\)\=\[\(=*\)\[:]\1]'
    1              0.000003   let b:undo_ftplugin ..= " | unlet! b:match_words b:match_ignorecase"
    1              0.000001 endif
                            
    1              0.000007 if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
                              let b:browsefilter = "Lua Source Files (*.lua)\t*.lua\n"
                              if has("win32")
                                let b:browsefilter ..= "All Files (*.*)\t*\n"
                              else
                                let b:browsefilter ..= "All Files (*)\t*\n"
                              endif
                              let b:undo_ftplugin ..= " | unlet! b:browsefilter"
    1              0.000000 endif
                            
                            " The rest of the file needs to be :sourced only once per Vim session
    1              0.000003 if exists("s:loaded_lua") || &cp
    1              0.000003   let &cpo = s:cpo_save
    1              0.000002   unlet s:cpo_save
    1              0.000003   finish
                            endif
                            let s:loaded_lua = 1
                            
                            function s:LuaInclude(fname) abort
                              let lua_ver = str2float(printf("%d.%02d", g:lua_version, g:lua_subversion))
                              let fname = tr(a:fname, '.', '/')
                              let paths = lua_ver >= 5.03 ? [fname .. ".lua", fname .. "/init.lua"] : [fname .. ".lua"]
                              for path in paths
                                if filereadable(path)
                                  return path
                                endif
                              endfor
                              return fname
                            endfunction
                            
                            " vim: nowrap sw=2 sts=2 ts=8 noet:

SCRIPT  /opt/homebrew/Cellar/neovim/0.11.0/share/nvim/runtime/ftplugin/lua.lua
Sourced 1 time
Total time:   0.001023
 Self time:   0.000953

count  total (s)   self (s)
                            -- use treesitter over syntax
                            vim.treesitter.start()
                            
                            vim.bo.includeexpr = [[v:lua.require'vim._ftplugin.lua'.includeexpr(v:fname)]]
                            vim.bo.omnifunc = 'v:lua.vim.lua_omnifunc'
                            vim.wo[0][0].foldexpr = 'v:lua.vim.treesitter.foldexpr()'
                            
                            vim.b.undo_ftplugin = (vim.b.undo_ftplugin or '')
                              .. '\n call v:lua.vim.treesitter.stop()'
                              .. '\n setl omnifunc< foldexpr< includeexpr<'

SCRIPT  /opt/homebrew/Cellar/neovim/0.11.0/share/nvim/runtime/indent/lua.vim
Sourced 1 time
Total time:   0.000195
 Self time:   0.000195

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Lua script
                            " Maintainer:	Marcus Aurelius Farias <marcus.cf 'at' bol.com.br>
                            " First Author:	Max Ischenko <mfi 'at' ukr.net>
                            " Last Change:	2017 Jun 13
                            "		2022 Sep 07: b:undo_indent added by Doug Kearns
                            "		2024 Jul 27: by Vim project: match '(', ')' in function GetLuaIndentIntern()
                            
                            " Only load this indent file when no other was loaded.
    1              0.000004 if exists("b:did_indent")
                              finish
    1              0.000000 endif
    1              0.000002 let b:did_indent = 1
                            
    1              0.000006 setlocal indentexpr=GetLuaIndent()
                            
                            " To make Vim call GetLuaIndent() when it finds '\s*end' or '\s*until'
                            " on the current line ('else' is default and includes 'elseif').
    1              0.000004 setlocal indentkeys+=0=end,0=until
                            
    1              0.000002 setlocal autoindent
                            
    1              0.000002 let b:undo_indent = "setlocal autoindent< indentexpr< indentkeys<"
                            
                            " Only define the function once.
    1              0.000003 if exists("*GetLuaIndent")
    1              0.000001   finish
                            endif
                            
                            function! GetLuaIndent()
                                let ignorecase_save = &ignorecase
                              try
                                let &ignorecase = 0
                                return GetLuaIndentIntern()
                              finally
                                let &ignorecase = ignorecase_save
                              endtry
                            endfunction
                            
                            function! GetLuaIndentIntern()
                              " Find a non-blank line above the current line.
                              let prevlnum = prevnonblank(v:lnum - 1)
                            
                              " Hit the start of the file, use zero indent.
                              if prevlnum == 0
                                return 0
                              endif
                            
                              " Add a 'shiftwidth' after lines that start a block:
                              " 'function', 'if', 'for', 'while', 'repeat', 'else', 'elseif', '{', '('
                              let ind = indent(prevlnum)
                              let prevline = getline(prevlnum)
                              let midx = match(prevline, '^\s*\%(if\>\|for\>\|while\>\|repeat\>\|else\>\|elseif\>\|do\>\|then\>\)')
                              if midx == -1
                                let midx = match(prevline, '\%({\|(\)\s*\%(--\%([^[].*\)\?\)\?$')
                                if midx == -1
                                  let midx = match(prevline, '\<function\>\s*\%(\k\|[.:]\)\{-}\s*(')
                                endif
                              endif
                            
                              if midx != -1
                                " Add 'shiftwidth' if what we found previously is not in a comment and
                                " an "end" or "until" is not present on the same line.
                                if synIDattr(synID(prevlnum, midx + 1, 1), "name") != "luaComment" && prevline !~ '\<end\>\|\<until\>'
                                  let ind = ind + shiftwidth()
                                endif
                              endif
                            
                              " Subtract a 'shiftwidth' on end, else, elseif, until, '}' and ')'
                              " This is the part that requires 'indentkeys'.
                              let midx = match(getline(v:lnum), '^\s*\%(end\>\|else\>\|elseif\>\|until\>\|}\|)\)')
                              if midx != -1 && synIDattr(synID(v:lnum, midx + 1, 1), "name") != "luaComment"
                                let ind = ind - shiftwidth()
                              endif
                            
                              return ind
                            endfunction

SCRIPT  /Users/tianli/.local/share/nvim/lazy/fzf-lua/plugin/fzf-lua.vim
Sourced 1 time
Total time:   0.000351
 Self time:   0.000351

count  total (s)   self (s)
    1              0.000015 if !has('nvim-0.5')
                                echohl Error
                                echomsg "Fzf-lua is only available for Neovim versions 0.5 and above"
                                echohl clear
                                finish
    1              0.000001 endif
                            
    1              0.000004 if exists('g:loaded_fzf_lua') | finish | endif
    1              0.000004 let g:loaded_fzf_lua = 1
                            
                            " FzfLua builtin lists
    1              0.000005 function! s:fzflua_complete(arg, line, pos) abort
                              let l:builtin_list = luaeval('vim.tbl_filter(
                                \ function(k)
                                \   if require("fzf-lua")._excluded_metamap[k] then
                                \     return false
                                \   end
                                \   return true
                                \ end,
                                \ vim.tbl_keys(require("fzf-lua")))')
                              call sort(l:builtin_list)
                            
                              let list = [l:builtin_list]
                              let l = split(a:line[:a:pos-1], '\%(\%(\%(^\|[^\\]\)\\\)\@<!\s\)\+', 1)
                              let n = len(l) - index(l, 'FzfLua') - 2
                            
                              return join(list[0],"\n")
                            endfunction
                            
                            " FzfLua commands with auto-complete
    1              0.000013 command! -nargs=* -complete=custom,s:fzflua_complete FzfLua lua require('fzf-lua.cmd').load_command(<f-args>)

SCRIPT  /Users/tianli/.local/share/nvim/lazy/grug-far.nvim/plugin/grug-far.lua
Sourced 1 time
Total time:   0.000787
 Self time:   0.000787

count  total (s)   self (s)
                            -- note: unfortunately has to be global so it can be passed to command complete= opt
                            -- selene: allow(unused_variable)
                            function GrugFarCompleteEngine()
                              local opts = require('grug-far.opts')
                              return table.concat(vim.fn.keys(opts.defaultOptions.engines), '\n')
                            end
                            
                            vim.api.nvim_create_user_command('GrugFar', function(params)
                              local utils = require('grug-far.utils')
                              local opts = require('grug-far.opts')
                            
                              local engineParam = params.fargs[1]
                              local visual_selection_info
                              if params.range > 0 then
                                visual_selection_info = utils.get_current_visual_selection_info()
                              end
                              local resolvedOpts = opts.with_defaults({ engine = engineParam }, opts.getGlobalOptions())
                              if params.mods and #params.mods > 0 then
                                resolvedOpts.windowCreationCommand = params.mods .. ' split'
                              end
                              require('grug-far')._open_internal(
                                resolvedOpts,
                                { visual_selection_info = visual_selection_info }
                              )
                            end, {
                              nargs = '?',
                              range = true,
                              complete = 'custom,v:lua.GrugFarCompleteEngine',
                            })
                            
                            vim.api.nvim_create_user_command('GrugFarWithin', function(params)
                              local utils = require('grug-far.utils')
                              local opts = require('grug-far.opts')
                            
                              local engineParam = params.fargs[1]
                              local visual_selection_info
                              if params.range > 0 then
                                visual_selection_info = utils.get_current_visual_selection_info()
                              end
                              local resolvedOpts = opts.with_defaults({ engine = engineParam }, opts.getGlobalOptions())
                              if params.mods and #params.mods > 0 then
                                resolvedOpts.windowCreationCommand = params.mods .. ' split'
                              end
                              resolvedOpts.visualSelectionUsage = 'operate-within-range'
                              require('grug-far')._open_internal(
                                resolvedOpts,
                                { visual_selection_info = visual_selection_info }
                              )
                            end, {
                              nargs = '?',
                              range = true,
                              complete = 'custom,v:lua.GrugFarCompleteEngine',
                            })

SCRIPT  /Users/tianli/.local/share/nvim/lazy/ultisnips/autoload/UltiSnips.vim
Sourced 1 time
Total time:   0.014572
 Self time:   0.000243

count  total (s)   self (s)
    1              0.000002 if exists("b:did_autoload_ultisnips")
                                finish
    1              0.000000 endif
    1              0.000001 let b:did_autoload_ultisnips = 1
                            
                            " Ensure snippets are loaded for current buffer
    1              0.000004 au UltiSnips_AutoTrigger FileType,BufEnter * call UltiSnips#CheckFiletype()
                            
                            " Also import vim as we expect it to be imported in many places.
    1   0.000261   0.000004 py3 import vim
    1   0.014092   0.000020 py3 from UltiSnips import UltiSnips_Manager
                            
    1              0.000002 function! s:compensate_for_pum() abort
                                """ The CursorMovedI event is not triggered while the popup-menu is visible,
                                """ and it's by this event that UltiSnips updates its vim-state. The fix is
                                """ to explicitly check for the presence of the popup menu, and update
                                """ the vim-state accordingly.
                                if pumvisible()
                                    py3 UltiSnips_Manager._cursor_moved()
                                endif
                            endfunction
                            
    1              0.000001 function! s:is_floating(winId) abort
                                if has('nvim')
                                    return get(nvim_win_get_config(a:winId), 'relative', '') !=# ''
                                endif
                            
                                return 0
                            endfunction
                            
    1              0.000001 function! UltiSnips#Edit(bang, ...) abort
                                if a:0 == 1 && a:1 != ''
                                    let type = a:1
                                else
                                    let type = ""
                                endif
                                py3 vim.command("let file = '%s'" % UltiSnips_Manager._file_to_edit(vim.eval("type"), vim.eval('a:bang')))
                            
                                if !len(file)
                                   return
                                endif
                            
                                let mode = 'e'
                                if exists('g:UltiSnipsEditSplit')
                                    if g:UltiSnipsEditSplit == 'vertical'
                                        let mode = 'vs'
                                    elseif g:UltiSnipsEditSplit == 'horizontal'
                                        let mode = 'sp'
                                    elseif g:UltiSnipsEditSplit == 'tabdo'
                                        let mode = 'tabedit'
                                    elseif g:UltiSnipsEditSplit == 'context'
                                        let mode = 'vs'
                                        if winwidth(0) <= 2 * (&tw ? &tw : 80)
                                            let mode = 'sp'
                                        endif
                                    endif
                                endif
                                exe ':'.mode.' '.escape(file, ' ')
                            endfunction
                            
    1              0.000001 function! UltiSnips#AddFiletypes(filetypes) abort
                                py3 UltiSnips_Manager.add_buffer_filetypes(vim.eval("a:filetypes"))
                                return ""
                            endfunction
                            
    1              0.000001 function! UltiSnips#FileTypeComplete(arglead, cmdline, cursorpos) abort
                                let ret = {}
                                let items = map(
                                \   split(globpath(&runtimepath, 'syntax/*.vim'), '\n'),
                                \   'fnamemodify(v:val, ":t:r")'
                                \ )
                                call insert(items, 'all')
                                for item in items
                                    if !has_key(ret, item) && item =~ '^'.a:arglead
                                        let ret[item] = 1
                                    endif
                                endfor
                            
                                return sort(keys(ret))
                            endfunction
                            
    1              0.000000 function! UltiSnips#ExpandSnippet() abort
                                py3 UltiSnips_Manager.expand()
                                return ""
                            endfunction
                            
    1              0.000000 function! UltiSnips#ExpandSnippetOrJump() abort
                                call s:compensate_for_pum()
                                py3 UltiSnips_Manager.expand_or_jump()
                                return ""
                            endfunction
                            
    1              0.000000 function! UltiSnips#JumpOrExpandSnippet() abort
                                call s:compensate_for_pum()
                                py3 UltiSnips_Manager.jump_or_expand()
                                return ""
                            endfunction
                            
    1              0.000000 function! UltiSnips#ListSnippets() abort
                                py3 UltiSnips_Manager.list_snippets()
                                return ""
                            endfunction
                            
    1              0.000000 function! UltiSnips#SnippetsInCurrentScope(...) abort
                                let g:current_ulti_dict = {}
                                let all = get(a:, 1, 0)
                                if all
                                  let g:current_ulti_dict_info = {}
                                endif
                                py3 UltiSnips_Manager.snippets_in_current_scope(int(vim.eval("all")))
                                return g:current_ulti_dict
                            endfunction
                            
    1              0.000000 function! UltiSnips#CanExpandSnippet() abort
                            	py3 vim.command("let can_expand = %d" % UltiSnips_Manager.can_expand())
                            	return can_expand
                            endfunction
                            
    1              0.000000 function! UltiSnips#CanJumpForwards() abort
                            	py3 vim.command("let can_jump_forwards = %d" % UltiSnips_Manager.can_jump_forwards())
                            	return can_jump_forwards
                            endfunction
                            
    1              0.000000 function! UltiSnips#CanJumpBackwards() abort
                            	py3 vim.command("let can_jump_backwards = %d" % UltiSnips_Manager.can_jump_backwards())
                            	return can_jump_backwards
                            endfunction
                            
    1              0.000000 function! UltiSnips#ToggleAutoTrigger() abort
                                py3 vim.command("let autotrigger = %d" % UltiSnips_Manager._toggle_autotrigger())
                                return autotrigger
                            endfunction
                            
    1              0.000001 function! UltiSnips#SaveLastVisualSelection() range abort
                                py3 UltiSnips_Manager._save_last_visual_selection()
                                return ""
                            endfunction
                            
    1              0.000000 function! UltiSnips#JumpBackwards() abort
                                call s:compensate_for_pum()
                                py3 UltiSnips_Manager.jump_backwards()
                                return ""
                            endfunction
                            
    1              0.000000 function! UltiSnips#JumpForwards() abort
                                call s:compensate_for_pum()
                                py3 UltiSnips_Manager.jump_forwards()
                                return ""
                            endfunction
                            
    1              0.000001 function! UltiSnips#AddSnippetWithPriority(trigger, value, description, options, filetype, priority) abort
                                py3 trigger = vim.eval("a:trigger")
                                py3 value = vim.eval("a:value")
                                py3 description = vim.eval("a:description")
                                py3 options = vim.eval("a:options")
                                py3 filetype = vim.eval("a:filetype")
                                py3 priority = vim.eval("a:priority")
                                py3 UltiSnips_Manager.add_snippet(trigger, value, description, options, filetype, priority)
                                return ""
                            endfunction
                            
    1              0.000000 function! UltiSnips#Anon(value, ...) abort
                                " Takes the same arguments as SnippetManager.expand_anon:
                                " (value, trigger="", description="", options="")
                                py3 args = vim.eval("a:000")
                                py3 value = vim.eval("a:value")
                                py3 UltiSnips_Manager.expand_anon(value, *args)
                                return ""
                            endfunction
                            
    1              0.000000 function! UltiSnips#CursorMoved() abort
                                py3 UltiSnips_Manager._cursor_moved()
                            endf
                            
    1              0.000000 function! UltiSnips#LeavingBuffer() abort
                                let from_preview = getwinvar(winnr('#'), '&previewwindow')
                                let to_preview = getwinvar(winnr(), '&previewwindow')
                                let from_floating = s:is_floating(win_getid('#'))
                                let to_floating = s:is_floating(win_getid())
                            
                                if !(from_preview || to_preview || from_floating || to_floating)
                                    py3 UltiSnips_Manager._leaving_buffer()
                                endif
                            endf
                            
    1              0.000000 function! UltiSnips#LeavingInsertMode() abort
                                py3 UltiSnips_Manager._leaving_insert_mode()
                            endfunction
                            
    1              0.000000 function! UltiSnips#TrackChange() abort
                                py3 UltiSnips_Manager._track_change()
                            endfunction
                            
    1              0.000000 function! UltiSnips#CheckFiletype() abort
                                py3 UltiSnips_Manager._check_filetype(vim.eval('&ft'))
                            endfunction
                            
    1              0.000000 function! UltiSnips#RefreshSnippets() abort
                                py3 UltiSnips_Manager._refresh_snippets()
                            endfunction
                            " }}}

SCRIPT  /Users/tianli/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim
Sourced 1 time
Total time:   0.000851
 Self time:   0.000851

count  total (s)   self (s)
    1              0.000005 function! wilder#renderer#redraw(apply_incsearch_fix) abort
                              call s:redraw(a:apply_incsearch_fix, 0)
                            endfunction
                            
    1              0.000002 function! wilder#renderer#redrawstatus(apply_incsearch_fix) abort
                              call s:redraw(a:apply_incsearch_fix, 1)
                            endfunction
                            
    1              0.000002 function! s:redraw(apply_incsearch_fix, is_redrawstatus) abort
                              if a:apply_incsearch_fix &&
                                    \ &incsearch &&
                                    \ (getcmdtype() ==# '/' || getcmdtype() ==# '?')
                                call feedkeys("\<C-R>\<BS>", 'n')
                                return
                              endif
                            
                              if a:is_redrawstatus
                                redrawstatus
                              else
                                redraw
                              endif
                            endfunction
                            
    1              0.000001 function! wilder#renderer#get_cmdheight() abort
                              if !has('nvim')
                                " For Vim, if cmdline exceeds cmdheight, the screen lines are pushed up
                                " similar to :mess, so we draw the popupmenu just above the cmdline.
                                " Lines exceeding cmdheight do not count into target line number.
                                return &cmdheight
                              endif
                            
                              let l:cmdline = getcmdline()
                            
                              " include the cmdline character
                              let l:display_width = strdisplaywidth(l:cmdline) + 1
                              let l:cmdheight = l:display_width / &columns + 1
                            
                              if l:cmdheight < &cmdheight
                                let l:cmdheight = &cmdheight
                              elseif l:cmdheight > 1
                                " Show the pum above the msgsep.
                                let l:has_msgsep = stridx(&display, 'msgsep') >= 0
                            
                                if l:has_msgsep
                                  let l:cmdheight += 1
                                endif
                              endif
                            
                              return l:cmdheight
                            endfunction
                            
    1              0.000004 function! wilder#renderer#pre_draw(components, ctx, result) abort
                              let l:should_draw = 0
                            
                              for l:Component in a:components
                                let l:should_draw += s:pre_draw(l:Component, a:ctx, a:result)
                              endfor
                            
                              return l:should_draw
                            endfunction
                            
    1              0.000003 function! s:pre_draw(component, ctx, result) abort
                              if type(a:component) isnot v:t_dict
                                return a:ctx.done
                              endif
                            
                              if has_key(a:component, 'pre_draw')
                                return a:component.pre_draw(a:ctx, a:result)
                              endif
                            
                              return a:ctx.done || get(a:component, 'dynamic', 0)
                            endfunction
                            
    1              0.000002 function! wilder#renderer#call_component_pre_hook(ctx, component) abort
                              if type(a:component) is v:t_dict &&
                                    \ has_key(a:component, 'pre_hook')
                                call a:component['pre_hook'](a:ctx)
                              endif
                            endfunction
                            
    1              0.000001 function! wilder#renderer#call_component_post_hook(ctx, component) abort
                              if type(a:component) is v:t_dict &&
                                    \ has_key(a:component, 'post_hook')
                                call a:component['post_hook'](a:ctx)
                              endif
                            endfunction

SCRIPT  /Users/tianli/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim
Sourced 1 time
Total time:   0.000320
 Self time:   0.000320

count  total (s)   self (s)
    1              0.000005 let s:handler_registry = {}
    1              0.000002 let s:partial_results = {}
    1              0.000001 let s:id_index = 0
    1              0.000001 let s:last_cleared_id = -1
                            
    1              0.000002 function! wilder#pipeline#clear_handlers() abort
                              let s:last_cleared_id = s:id_index
                              let s:handler_registry = {}
                              let s:partial_results = {}
                            endfunction
                            
    1              0.000001 function! wilder#pipeline#resolve(ctx, x) abort
                              call s:handle(a:ctx, a:x, 'resolve')
                            endfunction
                            
    1              0.000001 function! wilder#pipeline#reject(ctx, x) abort
                              call s:handle(a:ctx, a:x, 'reject')
                            endfunction
                            
    1              0.000002 function! s:partial_error_message(key, x)
                              let l:message = 'wilder#' . a:key . '()'
                              let l:message .= ' ''partial'' only supported for lists: ' . string(a:x)
                            
                              return l:message
                            endfunction
                            
    1              0.000001 function! s:handle(ctx, x, key) abort
                              let l:handler_id = get(a:ctx, 'handler_id', 0)
                            
                              if !has_key(s:handler_registry, l:handler_id)
                                " only show error if handler has not been cleared
                                if l:handler_id > s:last_cleared_id
                                  let l:message = 'wilder#' . a:key . '()'
                                  let l:message .= ' handler not found - id: ' . l:handler_id
                                  let l:message .= ': ' . string(a:x)
                            
                                  call s:echoerr(l:message)
                                endif
                            
                                return
                              endif
                            
                              let l:X = a:x
                              let l:handler = s:handler_registry[l:handler_id]
                            
                              if get(a:ctx, 'partial', 0)
                                if type(l:X) isnot v:t_list
                                  call l:handler.on_error(a:ctx,
                                        \ 'pipeline: ' . s:partial_error_message(a:key, l:X))
                                  return
                                endif
                            
                                if !has_key(s:partial_results, l:handler_id)
                                  let s:partial_results[l:handler_id] = l:X
                                else
                                  let s:partial_results[l:handler_id] += l:X
                                endif
                            
                                return
                              endif
                            
                              unlet s:handler_registry[l:handler_id]
                            
                              if has_key(s:partial_results, l:handler_id)
                                if type(l:X) isnot v:t_list
                                  call l:handler.on_error(a:ctx,
                                        \ 'pipeline: ' . s:partial_error_message(a:key, l:X))
                                  return
                                endif
                            
                                let l:X = s:partial_results[l:handler_id] + l:X
                                unlet s:partial_results[l:handler_id]
                              endif
                            
                              if a:key ==# 'reject'
                                call l:handler.on_error(a:ctx, l:X)
                                return
                              endif
                            
                              try
                                call l:handler.on_finish(a:ctx, l:X)
                              catch
                                call l:handler.on_error(a:ctx, 'pipeline: ' . v:exception)
                              endtry
                            endfunction
                            
    1              0.000002 function! wilder#pipeline#run(pipeline, on_finish, on_error, ctx, x) abort
                              let l:pipeline = type(a:pipeline) isnot v:t_list
                                    \ ? [a:pipeline]
                                    \ : a:pipeline
                            
                              return s:run(l:pipeline, a:on_finish, a:on_error, a:ctx, a:x, 0)
                            endfunction
                            
    1              0.000001 function! s:call(f, ctx, handler_id) abort
                              let a:ctx.handler_id = a:handler_id
                            
                              try
                                call a:f(a:ctx)
                              catch
                                call wilder#reject(a:ctx, 'pipeline: ' . v:exception)
                              endtry
                            endfunction
                            
    1              0.000002 function! s:prepare_call(f, pipeline, on_finish, on_error, ctx, i)
                              let l:handler = {
                                    \ 'on_finish': {ctx, x -> s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)},
                                    \ 'on_error': {ctx, x -> a:on_error(ctx, x)},
                                    \ }
                            
                              let s:id_index += 1
                              let l:handler_id = s:id_index
                              let s:handler_registry[s:id_index] = l:handler
                            
                              call timer_start(0, {_ -> s:call(a:f, a:ctx, l:handler_id)})
                            endfunction
                            
    1              0.000002 function! s:run(pipeline, on_finish, on_error, ctx, x, i) abort
                              if a:x is v:false || a:x is v:true
                                call a:on_finish(a:ctx, a:x)
                                return
                              endif
                            
                              if type(a:x) is v:t_func
                                let l:ctx = copy(a:ctx)
                                call s:prepare_call(a:x, a:pipeline, a:on_finish, a:on_error, l:ctx, a:i)
                                return
                              endif
                            
                              let l:x = a:x
                              let l:i = a:i
                            
                              while l:i < len(a:pipeline)
                                let l:F = a:pipeline[l:i]
                            
                                if type(l:F) isnot v:t_func
                                  call a:on_error(a:ctx, 'pipeline: expected function but got: ' . string(l:F))
                                  return
                                endif
                            
                                try
                                  let l:Result = l:F(a:ctx, l:x)
                                catch
                                  call a:on_error(a:ctx, 'pipeline: ' . v:exception)
                                  return
                                endtry
                            
                                if l:Result is v:false || l:Result is v:true
                                  call a:on_finish(a:ctx, l:Result)
                                  return
                                endif
                            
                                if type(l:Result) is v:t_func
                                  let l:ctx = copy(a:ctx)
                                  call s:prepare_call(l:Result, a:pipeline, a:on_finish, a:on_error, l:ctx, l:i+1)
                                  return
                                endif
                            
                                let l:x = l:Result
                                let l:i += 1
                              endwhile
                            
                              call a:on_finish(a:ctx, l:x)
                            endfunction
                            
    1              0.000002 function! wilder#pipeline#wait(f, on_finish) abort
                              let l:state = {
                                    \ 'f': a:f,
                                    \ 'on_finish': a:on_finish,
                                    \ }
                            
                              return {ctx -> s:wait_start(l:state, ctx)}
                            endfunction
                            
    1              0.000001 function! s:wait_start(state, ctx)
                              let a:state.wait_handler_id = a:ctx.handler_id
                            
                              let a:state.handler = {
                                    \ 'on_finish': {ctx, x -> s:wait_on_finish(a:state, ctx, x)},
                                    \ 'on_error': {ctx, x -> s:wait_on_error(a:state, ctx, x)},
                                    \ }
                            
                              call s:wait_call(a:state, a:ctx)
                            endfunction
                            
    1              0.000001 function! s:wait_call(state, ctx)
                              try
                                if type(a:state.f) is v:t_func
                                  let l:ctx = copy(a:ctx)
                            
                                  let s:id_index += 1
                                  let l:id_index = s:id_index
                                  let s:handler_registry[s:id_index] = a:state.handler
                            
                                  call timer_start(0, {_ -> s:call(a:state.f, l:ctx, l:id_index)})
                                else
                                  let a:ctx.handler_id = a:state.wait_handler_id
                                  call a:state.on_finish(a:ctx, a:state.f)
                                endif
                              catch
                                let a:ctx.handler_id = a:state.wait_handler_id
                                call s:wait_on_error(a:state, a:ctx, v:exception)
                              endtry
                            endfunction
                            
    1              0.000001 function! s:wait_on_finish(state, ctx, x)
                              if type(a:x) is v:t_func
                                let a:state.f = a:x
                                call s:wait_call(a:state, a:ctx)
                                return
                              endif
                            
                              let l:ctx = copy(a:ctx)
                              let l:ctx.handler_id = a:state.wait_handler_id
                            
                              try
                                call a:state.on_finish(l:ctx, a:x)
                              catch
                                call wilder#reject(l:ctx, v:exception)
                              endtry
                            endfunction
                            
    1              0.000001 function! s:wait_on_error(state, ctx, x)
                              let l:ctx = copy(a:ctx)
                              let l:ctx.handler_id = a:state.wait_handler_id
                            
                              call wilder#reject(l:ctx, a:x)
                            endfunction
                            
    1              0.000002 function! s:echoerr(message)
                              " avoid echoerr since this in a try-catch block
                              " see try-echoerr
                              echohl ErrorMsg
                              echomsg a:message
                              echohl Normal
                            endfunction

SCRIPT  /Users/tianli/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/main.vim
Sourced 1 time
Total time:   0.001057
 Self time:   0.001057

count  total (s)   self (s)
    1              0.000019 let s:command_modifiers = {
                                  \ 'aboveleft': 1,
                                  \ 'argdo': 1,
                                  \ 'belowright': 1,
                                  \ 'botright': 1,
                                  \ 'browse': 1,
                                  \ 'bufdo': 1,
                                  \ 'cdo': 1,
                                  \ 'cfdo': 1,
                                  \ 'confirm': 1,
                                  \ 'debug': 1,
                                  \ 'folddoclosed': 1,
                                  \ 'folddoopen': 1,
                                  \ 'hide': 1,
                                  \ 'keepalt': 1,
                                  \ 'keepjumps': 1,
                                  \ 'keepmarks': 1,
                                  \ 'keeppatterns': 1,
                                  \ 'ldo': 1,
                                  \ 'leftabove': 1,
                                  \ 'lfdo': 1,
                                  \ 'lockmarks': 1,
                                  \ 'noautocmd': 1,
                                  \ 'noswapfile': 1,
                                  \ 'rightbelow': 1,
                                  \ 'sandbox': 1,
                                  \ 'silent': 1,
                                  \ 'tab': 1,
                                  \ 'tabdo': 1,
                                  \ 'topleft': 1,
                                  \ 'verbose': 1,
                                  \ 'vertical': 1,
                                  \ 'windo': 1,
                                  \ }
                            
    1              0.000002 function! wilder#cmdline#main#do(ctx) abort
                              " default
                              let a:ctx.expand = 'command'
                              let a:ctx.force = 0
                            
                              if empty(a:ctx.cmdline[a:ctx.pos :])
                                return
                              endif
                            
                              if !wilder#cmdline#main#skip_whitespace(a:ctx)
                                return
                              endif
                            
                              " check if comment
                              if a:ctx.cmdline[a:ctx.pos] ==# '"'
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
                              endif
                            
                              " skip range
                              call wilder#cmdline#skip_range#do(a:ctx)
                            
                              if !wilder#cmdline#main#skip_whitespace(a:ctx)
                                return
                              endif
                            
                              if a:ctx.cmdline[a:ctx.pos] ==# '"'
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
                              endif
                            
                              " check if starts with | or :
                              " treat as a new command
                              if a:ctx.cmdline[a:ctx.pos] ==# '|' || a:ctx.cmdline[a:ctx.pos] ==# ':'
                                let a:ctx.pos += 1
                                let a:ctx.cmd = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
                              endif
                            
                              let l:is_user_cmd = 0
                            
                              if a:ctx.cmdline[a:ctx.pos] ==# 'k' && a:ctx.cmdline[a:ctx.pos + 1] !=# 'e'
                                let a:ctx.cmd = 'k'
                                let a:ctx.pos += 1
                            
                                return
                              else
                                let l:cmd_start = a:ctx.pos
                            
                                let l:char = a:ctx.cmdline[a:ctx.pos]
                            
                                if l:char >=# 'A' && l:char <=# 'Z'
                                  " user-defined command can contain digits
                                  while l:char >=# 'a' && l:char <=# 'z' ||
                                        \ l:char >=# 'A' && l:char <=# 'Z' ||
                                        \ l:char >=# '0' && l:char <=# '9'
                                    let a:ctx.pos += 1
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                  endwhile
                            
                                  let a:ctx.cmd = a:ctx.cmdline[l:cmd_start : a:ctx.pos - 1]
                                  let l:is_user_cmd = 1
                                else
                                  " non-alphabet command
                                  if stridx('@*!=><&~#', l:char) != -1
                                    let a:ctx.pos += 1
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                  else
                                    " py3, python3, py3file and py3do are the only commands with numbers
                                    " all other commands are alphabet only
                                    if a:ctx.cmdline[a:ctx.pos] ==# 'p' &&
                                          \ a:ctx.cmdline[a:ctx.pos + 1] ==# 'y' &&
                                          \ a:ctx.cmdline[a:ctx.pos + 2] ==# '3'
                                      let a:ctx.pos += 3
                                      let l:char = a:ctx.cmdline[a:ctx.pos]
                                    endif
                            
                                    " this should check for [a-zA-Z] only, but the Vim implementation
                                    " skips over wildcards. This matters for commands which accept
                                    " non-alphanumeric arugments e.g. 'e*' would be parsed as an 'edit'
                                    " command with a '*' argument otherwise. These commands typically
                                    " don't need a space between the command and argument e.g. 'e++opt'
                                    " is a valid command.
                                    while l:char >=# 'a' && l:char <=# 'z' ||
                                          \ l:char >=# 'A' && l:char <=# 'Z' ||
                                          \ l:char ==# '*'
                                      let a:ctx.pos += 1
                                      let l:char = a:ctx.cmdline[a:ctx.pos]
                                    endwhile
                                  endif
                            
                                  if a:ctx.pos == l:cmd_start
                                    let a:ctx.expand = 'unsuccessful'
                                    return
                                  endif
                            
                                  " find the command
                                  if a:ctx.pos > l:cmd_start
                                    let l:cmd = a:ctx.cmdline[l:cmd_start : a:ctx.pos - 1]
                                    let l:len = a:ctx.pos - l:cmd_start
                            
                                    let l:char = l:cmd[0]
                                    if l:char < 'a' || l:char > 'z'
                                      let l:char = 'z'
                                    endif
                            
                                    let l:next_char = nr2char(char2nr(l:char) + 1)
                            
                                    let l:i = s:command_char_pos[l:char]
                                    let l:end = get(s:command_char_pos, 'l:next_char', len(s:commands))
                            
                                    while l:i < l:end
                                      let l:command = s:commands[l:i]
                                      if l:cmd ==# l:command[: l:len - 1]
                                        let a:ctx.cmd = l:command
                                        break
                                      endif
                            
                                      let l:i += 1
                                    endwhile
                                  endif
                                endif
                              endif
                            
                              " cursor is touching command and ends in alpha-numeric character
                              " complete the command name
                              if a:ctx.pos == len(a:ctx.cmdline)
                                let l:char = a:ctx.cmdline[a:ctx.pos - 1]
                            
                                if l:char >=# 'a' && l:char <=# 'z' ||
                                      \ l:char >=# 'A' && l:char <=# 'Z' ||
                                      \ l:char >=# '0' && l:char <=# '9'
                                  let a:ctx.pos = l:cmd_start
                                  let a:ctx.cmd = ''
                                  " expand commands
                                  return
                                endif
                              endif
                            
                              " no matching command found, treat as no arguments
                              if empty(a:ctx.cmd)
                                " 2 or 3-letter substitute command, takes no arguments
                                if a:ctx.cmdline[l:cmd_start] ==# 's' &&
                                      \ stridx('cgriI', a:ctx.cmdline[l:cmd_start + 1]) != -1
                                  let a:ctx.cmd = 's'
                                endif
                            
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
                              endif
                            
                              let a:ctx.expand = 'nothing'
                            
                              " handle !
                              if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                let a:ctx.pos += 1
                                let a:ctx.force = 1
                              endif
                            
                              if has_key(s:command_modifiers, a:ctx.cmd)
                                let a:ctx.cmd = ''
                                let a:ctx.expand = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
                              endif
                            
                              call wilder#cmdline#main#skip_whitespace(a:ctx)
                            
                              let l:flags = get(s:command_flags, a:ctx.cmd, 0)
                            
                              let l:use_filter = 0
                            
                              if a:ctx.cmd ==# 'write' || a:ctx.cmd ==# 'update'
                                if a:ctx.cmdline[a:ctx.pos] ==# '>'
                                  if a:ctx.cmdline[a:ctx.pos + 1] ==# '>'
                                    let a:ctx.pos += 2
                                  endif
                            
                                  call wilder#cmdline#main#skip_whitespace(a:ctx)
                                endif
                            
                                if a:ctx.cmd ==# 'write' && a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                endif
                              elseif a:ctx.cmd ==# 'read'
                                if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                else
                                  let l:use_filter = a:ctx.force
                                endif
                              elseif a:ctx.cmd ==# '<' || a:ctx.cmd ==# '>'
                                while a:ctx.cmdline[a:ctx.pos] ==# a:ctx.cmd
                                  let a:ctx.pos += 1
                                endwhile
                            
                                call wilder#cmdline#main#skip_whitespace(a:ctx)
                              endif
                            
                              " Handle +cmd or ++opt
                              if a:ctx.cmdline[a:ctx.pos] ==# '+' &&
                                    \ ((and(l:flags, s:EDITCMD) && !l:use_filter) ||
                                    \ and(l:flags, s:ARGOPT))
                                let l:allow_opt = 1
                                let l:allow_cmd = and(l:flags, s:EDITCMD) && !l:use_filter
                            
                                while a:ctx.cmdline[a:ctx.pos] ==# '+' &&
                                      \ a:ctx.pos < len(a:ctx.cmdline)
                                  let a:ctx.pos += 1
                            
                                  if a:ctx.cmdline[a:ctx.pos] ==# '+'
                                    if l:allow_opt
                                      let a:ctx.pos += 1
                                      let l:expand = 'file_opt'
                                    else
                                      let l:expand = 'nothing'
                                    endif
                                  elseif l:allow_cmd
                                    let l:expand = 'command'
                                    " ++opt must be before +cmd
                                    let l:allow_opt = 0
                                    " only 1 +cmd allowed
                                    let l:allow_cmd = 0
                                  else
                                    let l:expand = 'nothing'
                                  endif
                            
                                  let l:arg_start = a:ctx.pos
                            
                                  " skip to next arg
                                  while a:ctx.pos < len(a:ctx.cmdline)
                                        \ && !wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
                                    if a:ctx.cmdline[a:ctx.pos] ==# '\' &&
                                          \ a:ctx.pos + 1 < len(a:ctx.cmdline)
                                      let a:ctx.pos += 1
                                    endif
                            
                                    " TODO: multibyte
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  " still in command or option
                                  if empty(a:ctx.cmdline[a:ctx.pos])
                                    let a:ctx.pos = l:arg_start
                                    let a:ctx.expand = l:expand
                                    return
                                  endif
                            
                                  call wilder#cmdline#main#skip_whitespace(a:ctx)
                                endwhile
                            
                                if a:ctx.cmd ==# 'write' && a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                elseif a:ctx.cmd ==# 'read'
                                  if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                    let a:ctx.pos += 1
                                    let l:use_filter = 1
                                  else
                                    let l:use_filter = a:ctx.force
                                  endif
                                endif
                              endif
                            
                              " look for | for new command and " for comment
                              if and(l:flags, s:TRLBAR) && !l:use_filter
                                if a:ctx.cmd ==# 'redir' &&
                                      \ a:ctx.cmdline[a:ctx.pos] ==# '@' &&
                                      \ a:ctx.cmdline[a:ctx.pos + 1] ==# '"'
                                  let a:ctx.pos += 2
                                endif
                            
                                let l:lookahead = a:ctx.pos
                                while l:lookahead < len(a:ctx.cmdline)
                                  if a:ctx.cmdline[l:lookahead] ==# "\<C-V>" || a:ctx.cmdline[l:lookahead] ==# '\'
                                    let l:lookahead += 1
                            
                                    if l:lookahead + 1 < len(a:ctx.cmdline)
                                      let l:lookahead += 1
                                    else
                                      break
                                    endif
                                  endif
                            
                                  " Check if " indicates a comment or start of string
                                  if a:ctx.cmdline[l:lookahead] ==# '"'
                                    let l:lookahead += 1
                            
                                    let l:end_quote_reached = 0
                                    " Consume until next char is " or end of cmdline is reached
                                    while l:lookahead < len(a:ctx.cmdline)
                                      if a:ctx.cmdline[l:lookahead] ==# '\'
                                        let l:lookahead += 1
                                      elseif a:ctx.cmdline[l:lookahead] ==# '"'
                                        let l:end_quote_reached = 1
                                        let l:lookahead += 1
                                        break
                                      endif
                            
                                      let l:lookahead += 1
                                    endwhile
                            
                                    " remaining part of cmdline is comment, treat as no arguments
                                    if !l:end_quote_reached
                                      let a:ctx.pos = len(a:ctx.cmdline)
                                      return
                                    endif
                            
                                  " start of new command
                                  elseif a:ctx.cmdline[l:lookahead] ==# '|'
                                    let a:ctx.pos = l:lookahead + 1
                                    let a:ctx.cmd = ''
                                    let a:ctx.expand = ''
                            
                                    call wilder#cmdline#main#do(a:ctx)
                            
                                    return
                                  endif
                            
                                  " TODO: multibyte
                                  let l:lookahead += 1
                                endwhile
                              endif
                            
                              " command does not take extra arguments
                              if !and(l:flags, s:EXTRA) && !l:is_user_cmd
                                " consume whitespace
                                call wilder#cmdline#main#skip_whitespace(a:ctx)
                            
                                " and check for | or "
                                if a:ctx.cmdline[a:ctx.pos] ==# '|'
                                  let a:ctx.pos += 1
                                  let a:ctx.cmd = ''
                                  let a:ctx.expand = ''
                            
                                  call wilder#cmdline#main#do(a:ctx)
                                  return
                                else
                                  " remaining part is either comment or invalid arguments
                                  " either way, treat as no arguments
                                  let a:ctx.pos = len(a:ctx.cmdline)
                                  let a:ctx.expand = 'nothing'
                                  return
                                endif
                              endif
                            
                            
                              if l:use_filter || a:ctx.cmd ==# '!' || a:ctx.cmd ==# 'terminal'
                                let l:before_args = a:ctx.pos
                            
                                if !wilder#cmdline#main#skip_nonwhitespace(a:ctx)
                                  let a:ctx.pos = l:before_args
                                  let a:ctx.expand = 'shellcmd'
                                  return
                                endif
                            
                                " Reset pos back to before_args
                                let a:ctx.pos = l:before_args
                              endif
                            
                              if and(l:flags, s:XFILE)
                                " TODO: handle backticks :h backtick-expansion
                            
                                let l:arg_start = a:ctx.pos
                            
                                " Check if completing $ENV
                                if a:ctx.cmdline[a:ctx.pos] ==# '$'
                                  let l:arg_start = a:ctx.pos
                                  let a:ctx.pos += 1
                            
                                  while a:ctx.pos < len(a:ctx.cmdline)
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                    if !s:is_idc(l:char)
                                      break
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  if a:ctx.pos == len(a:ctx.cmdline)
                                    let a:ctx.expand = 'environment'
                                    let a:ctx.pos = l:arg_start + 1
                                    return
                                  endif
                                endif
                            
                                " Check if completing ~user
                                if a:ctx.cmdline[a:ctx.pos] ==# '~'
                                  let l:allow_backslash = has('win32') || has('win64')
                            
                                  while a:ctx.pos < len(a:ctx.cmdline)
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                    if l:char ==# '/' ||
                                          \ l:allow_backslash && l:char ==# '\' ||
                                          \ !s:is_filec(l:char)
                                      break
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  " + 1 since we want to expand ~ to $HOME
                                  if a:ctx.pos == len(a:ctx.cmdline) &&
                                        \ a:ctx.pos > l:arg_start + 1
                                    let a:ctx.expand = 'user'
                                    let a:ctx.pos = l:arg_start + 1
                                    return
                                  endif
                                endif
                            
                                let a:ctx.pos = l:arg_start
                                let a:ctx.expand = 'file'
                            
                                " vim assumes for XFILE, we can ignore arguments other than the last one but
                                " this is not necessarily true, we should not do this for NOSPC
                                if !and(l:flags, s:NOSPC)
                                  call s:move_pos_to_last_arg(a:ctx)
                                endif
                              endif
                            
                              if a:ctx.cmd ==# 'find' ||
                                    \ a:ctx.cmd ==# 'sfind' ||
                                    \ a:ctx.cmd ==# 'tabfind'
                                if a:ctx.expand ==# 'file'
                                  let a:ctx.expand = 'file_in_path'
                                endif
                                return
                              elseif a:ctx.cmd ==# 'cd' ||
                                    \ a:ctx.cmd ==# 'chdir' ||
                                    \ a:ctx.cmd ==# 'lcd' ||
                                    \ a:ctx.cmd ==# 'lchdir' ||
                                    \ a:ctx.cmd ==# 'tcd' ||
                                    \ a:ctx.cmd ==# 'tchdir'
                                if a:ctx.expand ==# 'file'
                                  let a:ctx.expand = 'dir'
                                endif
                                return
                              elseif a:ctx.cmd ==# 'help'
                                let a:ctx.expand = 'help'
                                return
                              " command modifiers
                              elseif has_key(s:command_modifiers, a:ctx.cmd)
                                let a:ctx.cmd = ''
                                let a:ctx.expand = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
                              elseif a:ctx.cmd ==# 'filter'
                                call wilder#cmdline#filter#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'match'
                                call wilder#cmdline#match#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'command'
                                call wilder#cmdline#command#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'delcommand'
                                let a:ctx.expand = 'user_commands'
                                return
                              elseif a:ctx.cmd ==# 'global' || a:ctx.cmd ==# 'vglobal'
                                call wilder#cmdline#global#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# '&' || a:ctx.cmd ==# 'substitute'
                                call wilder#cmdline#substitute#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'isearch' ||
                                    \ a:ctx.cmd ==# 'dsearch' ||
                                    \ a:ctx.cmd ==# 'ilist' ||
                                    \ a:ctx.cmd ==# 'dlist' ||
                                    \ a:ctx.cmd ==# 'ijump' ||
                                    \ a:ctx.cmd ==# 'psearch' ||
                                    \ a:ctx.cmd ==# 'djump' ||
                                    \ a:ctx.cmd ==# 'isplit' ||
                                    \ a:ctx.cmd ==# 'dsplit'
                                call wilder#cmdline#isearch#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'autocmd'
                                call wilder#cmdline#autocmd#do(a:ctx, 0)
                                return
                              elseif a:ctx.cmd ==# 'doautocmd' ||
                                    \ a:ctx.cmd ==# 'doautoall'
                                call wilder#cmdline#autocmd#do(a:ctx, 1)
                              elseif a:ctx.cmd ==# 'set' ||
                                    \ a:ctx.cmd ==# 'setglobal' ||
                                    \ a:ctx.cmd ==# 'setlocal'
                                call wilder#cmdline#set#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'tag' ||
                                    \ a:ctx.cmd ==# 'stag' ||
                                    \ a:ctx.cmd ==# 'ptag' ||
                                    \ a:ctx.cmd ==# 'ltag' ||
                                    \ a:ctx.cmd ==# 'tselect' ||
                                    \ a:ctx.cmd ==# 'stselect' ||
                                    \ a:ctx.cmd ==# 'tjump' ||
                                    \ a:ctx.cmd ==# 'stjump' ||
                                    \ a:ctx.cmd ==# 'ptselect' ||
                                    \ a:ctx.cmd ==# 'ptjump'
                                let a:ctx.expand = 'tags'
                                return
                              elseif a:ctx.cmd ==# 'augroup'
                                let a:ctx.expand = 'augroup'
                              elseif a:ctx.cmd ==# 'syntax'
                                call wilder#cmdline#syntax#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'let' ||
                                    \ a:ctx.cmd ==# 'if' ||
                                    \ a:ctx.cmd ==# 'elseif' ||
                                    \ a:ctx.cmd ==# 'while' ||
                                    \ a:ctx.cmd ==# 'for' ||
                                    \ a:ctx.cmd ==# 'echo' ||
                                    \ a:ctx.cmd ==# 'echon' ||
                                    \ a:ctx.cmd ==# 'execute' ||
                                    \ a:ctx.cmd ==# 'echomsg' ||
                                    \ a:ctx.cmd ==# 'echoerr' ||
                                    \ a:ctx.cmd ==# 'call' ||
                                    \ a:ctx.cmd ==# 'return' ||
                                    \ a:ctx.cmd ==# 'cexpr' ||
                                    \ a:ctx.cmd ==# 'caddexpr' ||
                                    \ a:ctx.cmd ==# 'cgetexpr' ||
                                    \ a:ctx.cmd ==# 'lexpr' ||
                                    \ a:ctx.cmd ==# 'laddexpr' ||
                                    \ a:ctx.cmd ==# 'lgetexpr'
                                "TODO call has extra arugments
                                call wilder#cmdline#let#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'unlet'
                                call wilder#cmdline#unlet#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'function'
                                let a:ctx.expand = 'function'
                                return
                              elseif a:ctx.cmd ==# 'delfunction'
                                let a:ctx.expand = 'user_func'
                                return
                              elseif a:ctx.cmd ==# 'echohl'
                                let a:ctx.expand = 'highlight'
                                " TODO: include None
                                return
                              elseif a:ctx.cmd ==# 'highlight'
                                call wilder#cmdline#highlight#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'cscope' ||
                                    \ a:ctx.cmd ==# 'lcscope' ||
                                    \ a:ctx.cmd ==# 'scscope'
                                call wilder#cmdline#cscope#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'sign'
                                call wilder#cmdline#sign#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'bdelete' ||
                                    \ a:ctx.cmd ==# 'bwipeout' ||
                                    \ a:ctx.cmd ==# 'bunload'
                                let a:ctx.expand = 'buffer'
                                return
                              elseif a:ctx.cmd ==# 'buffer' ||
                                    \ a:ctx.cmd ==# 'sbuffer' ||
                                    \ a:ctx.cmd ==# 'checktime'
                                let a:ctx.expand = 'buffer'
                                return
                              elseif a:ctx.cmd ==# 'abbreviate' ||
                                    \ a:ctx.cmd ==# 'unabbreviate' ||
                                    \ a:ctx.cmd[-3 :] ==# 'map' ||
                                    \ a:ctx.cmd[-6 :] ==# 'abbrev'
                                call wilder#cmdline#map#do(a:ctx)
                                return
                              elseif a:ctx.cmd[-8 :] ==# 'mapclear'
                                let a:ctx.expand = 'mapclear'
                                return
                              elseif a:ctx.cmd[-4 :] ==# 'menu'
                                call wilder#cmdline#menu#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'colorscheme'
                                let a:ctx.expand = 'color'
                                return
                              elseif a:ctx.cmd ==# 'compiler'
                                let a:ctx.expand = 'compiler'
                                return
                              elseif a:ctx.cmd ==# 'ownsyntax'
                                let a:ctx.expand = 'ownsyntax'
                                return
                              elseif a:ctx.cmd ==# 'packadd'
                                let a:ctx.expand = 'packadd'
                                return
                              elseif a:ctx.cmd ==# 'language'
                                let l:arg_start = a:ctx.pos
                                call wilder#cmdline#main#skip_nonwhitespace(a:ctx)
                            
                                if a:ctx.pos == len(a:ctx.cmdline)
                                  let a:ctx.expand = 'language'
                                  let a:ctx.pos = l:arg_start
                                else
                                  let l:subcommand = a:ctx.cmdline[l:arg_start : a:ctx.pos - 1]
                                  if l:subcommand ==# 'messages' ||
                                        \ l:subcommand ==# 'ctype' ||
                                        \ l:subcommand ==# 'time'
                                    let a:ctx.expand = 'locales'
                                    call wilder#cmdline#main#skip_whitespace(a:ctx)
                                  endif
                                endif
                              elseif a:ctx.cmd ==# 'profile'
                                call wilder#cmdline#profile#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'checkhealth'
                                let a:ctx.expand = 'checkhealth'
                                call s:move_pos_to_last_arg(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'behave'
                                let a:ctx.expand = 'behave'
                                return
                              elseif a:ctx.cmd ==# 'messages'
                                let a:ctx.expand = 'messages'
                                return
                              elseif a:ctx.cmd ==# 'history'
                                let a:ctx.expand = 'history'
                                return
                              elseif a:ctx.cmd ==# 'syntime'
                                let a:ctx.expand = 'syntime'
                                return
                              elseif a:ctx.cmd ==# 'argdelete'
                                let a:ctx.expand = 'arglist'
                                return
                              elseif a:ctx.cmd ==# 'lua'
                                let a:ctx.expand = 'lua'
                                return
                              endif
                            endfunction
                            
    1              0.000002 function! wilder#cmdline#main#has_file_args(cmd) abort
                              let l:flags = get(s:command_flags, a:cmd, 0)
                              return and(l:flags, s:XFILE)
                            endfunction
                            
    1              0.000001 function! wilder#cmdline#main#is_whitespace(char) abort
                              let l:nr = char2nr(a:char)
                              return a:char ==# ' ' || l:nr >= 9 && l:nr <= 13
                            endfunction
                            
    1              0.000001 function! wilder#cmdline#main#skip_whitespace(ctx) abort
                              if empty(a:ctx.cmdline[a:ctx.pos])
                                return 0
                              endif
                            
                              while wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
                                let a:ctx.pos += 1
                            
                                if empty(a:ctx.cmdline[a:ctx.pos])
                                  return 0
                                endif
                              endwhile
                            
                              return 1
                            endfunction
                            
    1              0.000001 function! wilder#cmdline#main#skip_nonwhitespace(ctx) abort
                              if empty(a:ctx.cmdline[a:ctx.pos])
                                return 0
                              endif
                            
                              while !wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
                                let a:ctx.pos += 1
                            
                                if empty(a:ctx.cmdline[a:ctx.pos])
                                  return 0
                                endif
                              endwhile
                            
                              return 1
                            endfunction
                            
    1              0.000001 function! wilder#cmdline#main#find_last_whitespace(ctx) abort
                              let l:arg_start = a:ctx.pos
                              let a:ctx.pos = len(a:ctx.cmdline) - 1
                              while a:ctx.pos >= l:arg_start
                                if wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
                                  let l:arg_start = a:ctx.pos + 1
                            
                                  break
                                endif
                                let a:ctx.pos -= 1
                              endwhile
                            endfunction
                            
    1              0.000001 function! s:move_pos_to_last_arg(ctx) abort
                              let l:last_arg = a:ctx.pos
                            
                              " find start of last argument
                              while a:ctx.pos < len(a:ctx.cmdline)
                                let l:char = a:ctx.cmdline[a:ctx.pos]
                            
                                if l:char ==# ' ' || l:char ==# "\t"
                                  let a:ctx.pos += 1
                                  let l:last_arg = a:ctx.pos
                                else
                                  if l:char ==# '\' && a:ctx.pos + 1 < len(a:ctx.cmdline)
                                    let a:ctx.pos += 1
                                  endif
                                  let a:ctx.pos += 1
                                endif
                              endwhile
                            
                              let a:ctx.pos = l:last_arg
                            endfunction
                            
    1              0.000001 function! s:is_filec(c) abort
                              return match(a:c, '\f') != -1
                            endfunction
                            
    1              0.000001 function! s:path_has_wildcard(c) abort
                              if has('win32') || has('win64')
                                let l:wildcards = '?*$[`'
                              else
                                let l:wildcards = "*?[{`'$"
                              endif
                            
                              return stridx(l:wildcards, a:c) != -1
                            endfunction
                            
    1              0.000001 function! s:isfilec_or_wc(c) abort
                              return s:is_filec(a:c) || a:c ==# ']' || s:path_has_wildcard(a:c)
                            endfunction
                            
    1              0.000001 function! s:is_idc(c) abort
                              return match(a:c, '\i') != -1
                            endfunction
                            
    1              0.000001 function! s:or(...) abort
                              let l:result = 0
                            
                              for l:arg in a:000
                                let l:result = or(l:result, l:arg)
                              endfor
                            
                              return l:result
                            endfunc
                            
    1              0.000002 let s:EXTRA      =    0x004
    1              0.000001 let s:XFILE      =    0x008
    1              0.000001 let s:NOSPC      =    0x010
    1              0.000001 let s:TRLBAR     =    0x100
    1              0.000001 let s:EDITCMD    =   0x8000
    1              0.000001 let s:ARGOPT     =  0x40000
                            
    1              0.000009 let s:command_char_pos = {
                                  \ 'a': 0,
                                  \ 'b': 19,
                                  \ 'c': 42,
                                  \ 'd': 104,
                                  \ 'e': 126,
                                  \ 'f': 146,
                                  \ 'g': 161,
                                  \ 'h': 167,
                                  \ 'i': 175,
                                  \ 'j': 193,
                                  \ 'k': 195,
                                  \ 'l': 200,
                                  \ 'm': 258,
                                  \ 'n': 276,
                                  \ 'o': 296,
                                  \ 'p': 307,
                                  \ 'q': 342,
                                  \ 'r': 345,
                                  \ 's': 365,
                                  \ 't': 430,
                                  \ 'u': 471,
                                  \ 'v': 482,
                                  \ 'w': 500,
                                  \ 'x': 516,
                                  \ 'y': 525,
                                  \ 'z': 526,
                                  \ '{': 527,
                                  \ }
                            
    1              0.000202 let s:commands = [
                                  \ 'append',
                                  \ 'abbreviate',
                                  \ 'abclear',
                                  \ 'aboveleft',
                                  \ 'all',
                                  \ 'amenu',
                                  \ 'anoremenu',
                                  \ 'args',
                                  \ 'argadd',
                                  \ 'argdelete',
                                  \ 'argdo',
                                  \ 'argedit',
                                  \ 'argglobal',
                                  \ 'arglocal',
                                  \ 'argument',
                                  \ 'ascii',
                                  \ 'autocmd',
                                  \ 'augroup',
                                  \ 'aunmenu',
                                  \ 'buffer',
                                  \ 'bNext',
                                  \ 'ball',
                                  \ 'badd',
                                  \ 'bdelete',
                                  \ 'behave',
                                  \ 'belowright',
                                  \ 'bfirst',
                                  \ 'blast',
                                  \ 'bmodified',
                                  \ 'bnext',
                                  \ 'botright',
                                  \ 'bprevious',
                                  \ 'brewind',
                                  \ 'break',
                                  \ 'breakadd',
                                  \ 'breakdel',
                                  \ 'breaklist',
                                  \ 'browse',
                                  \ 'buffers',
                                  \ 'bufdo',
                                  \ 'bunload',
                                  \ 'bwipeout',
                                  \ 'change',
                                  \ 'cNext',
                                  \ 'cNfile',
                                  \ 'cabbrev',
                                  \ 'cabclear',
                                  \ 'caddbuffer',
                                  \ 'caddexpr',
                                  \ 'caddfile',
                                  \ 'call',
                                  \ 'catch',
                                  \ 'cbuffer',
                                  \ 'cbottom',
                                  \ 'cc',
                                  \ 'cclose',
                                  \ 'cd',
                                  \ 'cdo',
                                  \ 'center',
                                  \ 'cexpr',
                                  \ 'cfile',
                                  \ 'cfdo',
                                  \ 'cfirst',
                                  \ 'cgetfile',
                                  \ 'cgetbuffer',
                                  \ 'cgetexpr',
                                  \ 'chdir',
                                  \ 'changes',
                                  \ 'checkhealth',
                                  \ 'checkpath',
                                  \ 'checktime',
                                  \ 'chistory',
                                  \ 'clist',
                                  \ 'clast',
                                  \ 'close',
                                  \ 'clearjumps',
                                  \ 'cmap',
                                  \ 'cmapclear',
                                  \ 'cmenu',
                                  \ 'cnext',
                                  \ 'cnewer',
                                  \ 'cnfile',
                                  \ 'cnoremap',
                                  \ 'cnoreabbrev',
                                  \ 'cnoremenu',
                                  \ 'copy',
                                  \ 'colder',
                                  \ 'colorscheme',
                                  \ 'command',
                                  \ 'comclear',
                                  \ 'compiler',
                                  \ 'continue',
                                  \ 'confirm',
                                  \ 'copen',
                                  \ 'cprevious',
                                  \ 'cpfile',
                                  \ 'cquit',
                                  \ 'crewind',
                                  \ 'cscope',
                                  \ 'cstag',
                                  \ 'cunmap',
                                  \ 'cunabbrev',
                                  \ 'cunmenu',
                                  \ 'cwindow',
                                  \ 'delete',
                                  \ 'delmarks',
                                  \ 'debug',
                                  \ 'debuggreedy',
                                  \ 'delcommand',
                                  \ 'delfunction',
                                  \ 'display',
                                  \ 'diffupdate',
                                  \ 'diffget',
                                  \ 'diffoff',
                                  \ 'diffpatch',
                                  \ 'diffput',
                                  \ 'diffsplit',
                                  \ 'diffthis',
                                  \ 'digraphs',
                                  \ 'djump',
                                  \ 'dlist',
                                  \ 'doautocmd',
                                  \ 'doautoall',
                                  \ 'drop',
                                  \ 'dsearch',
                                  \ 'dsplit',
                                  \ 'edit',
                                  \ 'earlier',
                                  \ 'echo',
                                  \ 'echoerr',
                                  \ 'echohl',
                                  \ 'echomsg',
                                  \ 'echon',
                                  \ 'else',
                                  \ 'elseif',
                                  \ 'emenu',
                                  \ 'endif',
                                  \ 'endfunction',
                                  \ 'endfor',
                                  \ 'endtry',
                                  \ 'endwhile',
                                  \ 'enew',
                                  \ 'ex',
                                  \ 'execute',
                                  \ 'exit',
                                  \ 'exusage',
                                  \ 'file',
                                  \ 'files',
                                  \ 'filetype',
                                  \ 'filter',
                                  \ 'find',
                                  \ 'finally',
                                  \ 'finish',
                                  \ 'first',
                                  \ 'fold',
                                  \ 'foldclose',
                                  \ 'folddoopen',
                                  \ 'folddoclosed',
                                  \ 'foldopen',
                                  \ 'for',
                                  \ 'function',
                                  \ 'global',
                                  \ 'goto',
                                  \ 'grep',
                                  \ 'grepadd',
                                  \ 'gui',
                                  \ 'gvim',
                                  \ 'help',
                                  \ 'helpclose',
                                  \ 'helpgrep',
                                  \ 'helptags',
                                  \ 'hardcopy',
                                  \ 'highlight',
                                  \ 'hide',
                                  \ 'history',
                                  \ 'insert',
                                  \ 'iabbrev',
                                  \ 'iabclear',
                                  \ 'if',
                                  \ 'ijump',
                                  \ 'ilist',
                                  \ 'imap',
                                  \ 'imapclear',
                                  \ 'imenu',
                                  \ 'inoremap',
                                  \ 'inoreabbrev',
                                  \ 'inoremenu',
                                  \ 'intro',
                                  \ 'isearch',
                                  \ 'isplit',
                                  \ 'iunmap',
                                  \ 'iunabbrev',
                                  \ 'iunmenu',
                                  \ 'join',
                                  \ 'jumps',
                                  \ 'k',
                                  \ 'keepmarks',
                                  \ 'keepjumps',
                                  \ 'keeppatterns',
                                  \ 'keepalt',
                                  \ 'list',
                                  \ 'lNext',
                                  \ 'lNfile',
                                  \ 'last',
                                  \ 'language',
                                  \ 'laddexpr',
                                  \ 'laddbuffer',
                                  \ 'laddfile',
                                  \ 'later',
                                  \ 'lbuffer',
                                  \ 'lbottom',
                                  \ 'lcd',
                                  \ 'lchdir',
                                  \ 'lclose',
                                  \ 'lcscope',
                                  \ 'ldo',
                                  \ 'left',
                                  \ 'leftabove',
                                  \ 'let',
                                  \ 'lexpr',
                                  \ 'lfile',
                                  \ 'lfdo',
                                  \ 'lfirst',
                                  \ 'lgetfile',
                                  \ 'lgetbuffer',
                                  \ 'lgetexpr',
                                  \ 'lgrep',
                                  \ 'lgrepadd',
                                  \ 'lhelpgrep',
                                  \ 'lhistory',
                                  \ 'll',
                                  \ 'llast',
                                  \ 'llist',
                                  \ 'lmap',
                                  \ 'lmapclear',
                                  \ 'lmake',
                                  \ 'lnoremap',
                                  \ 'lnext',
                                  \ 'lnewer',
                                  \ 'lnfile',
                                  \ 'loadview',
                                  \ 'loadkeymap',
                                  \ 'lockmarks',
                                  \ 'lockvar',
                                  \ 'lolder',
                                  \ 'lopen',
                                  \ 'lprevious',
                                  \ 'lpfile',
                                  \ 'lrewind',
                                  \ 'ltag',
                                  \ 'lunmap',
                                  \ 'lua',
                                  \ 'luado',
                                  \ 'luafile',
                                  \ 'lvimgrep',
                                  \ 'lvimgrepadd',
                                  \ 'lwindow',
                                  \ 'ls',
                                  \ 'move',
                                  \ 'mark',
                                  \ 'make',
                                  \ 'map',
                                  \ 'mapclear',
                                  \ 'marks',
                                  \ 'match',
                                  \ 'menu',
                                  \ 'menutranslate',
                                  \ 'messages',
                                  \ 'mkexrc',
                                  \ 'mksession',
                                  \ 'mkspell',
                                  \ 'mkvimrc',
                                  \ 'mkview',
                                  \ 'mode',
                                  \ 'mzscheme',
                                  \ 'mzfile',
                                  \ 'next',
                                  \ 'nbkey',
                                  \ 'nbclose',
                                  \ 'nbstart',
                                  \ 'new',
                                  \ 'nmap',
                                  \ 'nmapclear',
                                  \ 'nmenu',
                                  \ 'nnoremap',
                                  \ 'nnoremenu',
                                  \ 'noremap',
                                  \ 'noautocmd',
                                  \ 'nohlsearch',
                                  \ 'noreabbrev',
                                  \ 'noremenu',
                                  \ 'noswapfile',
                                  \ 'normal',
                                  \ 'number',
                                  \ 'nunmap',
                                  \ 'nunmenu',
                                  \ 'oldfiles',
                                  \ 'omap',
                                  \ 'omapclear',
                                  \ 'omenu',
                                  \ 'only',
                                  \ 'onoremap',
                                  \ 'onoremenu',
                                  \ 'options',
                                  \ 'ounmap',
                                  \ 'ounmenu',
                                  \ 'ownsyntax',
                                  \ 'print',
                                  \ 'packadd',
                                  \ 'packloadall',
                                  \ 'pclose',
                                  \ 'perl',
                                  \ 'perldo',
                                  \ 'pedit',
                                  \ 'pop',
                                  \ 'popup',
                                  \ 'ppop',
                                  \ 'preserve',
                                  \ 'previous',
                                  \ 'promptfind',
                                  \ 'promptrepl',
                                  \ 'profile',
                                  \ 'profdel',
                                  \ 'psearch',
                                  \ 'ptag',
                                  \ 'ptNext',
                                  \ 'ptfirst',
                                  \ 'ptjump',
                                  \ 'ptlast',
                                  \ 'ptnext',
                                  \ 'ptprevious',
                                  \ 'ptrewind',
                                  \ 'ptselect',
                                  \ 'put',
                                  \ 'pwd',
                                  \ 'python',
                                  \ 'pydo',
                                  \ 'pyfile',
                                  \ 'py3',
                                  \ 'py3do',
                                  \ 'python3',
                                  \ 'py3file',
                                  \ 'quit',
                                  \ 'quitall',
                                  \ 'qall',
                                  \ 'read',
                                  \ 'recover',
                                  \ 'redo',
                                  \ 'redir',
                                  \ 'redraw',
                                  \ 'redrawstatus',
                                  \ 'registers',
                                  \ 'resize',
                                  \ 'retab',
                                  \ 'return',
                                  \ 'rewind',
                                  \ 'right',
                                  \ 'rightbelow',
                                  \ 'rshada',
                                  \ 'runtime',
                                  \ 'rundo',
                                  \ 'ruby',
                                  \ 'rubydo',
                                  \ 'rubyfile',
                                  \ 'rviminfo',
                                  \ 'substitute',
                                  \ 'sNext',
                                  \ 'sargument',
                                  \ 'sall',
                                  \ 'sandbox',
                                  \ 'saveas',
                                  \ 'sbuffer',
                                  \ 'sbNext',
                                  \ 'sball',
                                  \ 'sbfirst',
                                  \ 'sblast',
                                  \ 'sbmodified',
                                  \ 'sbnext',
                                  \ 'sbprevious',
                                  \ 'sbrewind',
                                  \ 'scriptnames',
                                  \ 'scriptencoding',
                                  \ 'scscope',
                                  \ 'set',
                                  \ 'setfiletype',
                                  \ 'setglobal',
                                  \ 'setlocal',
                                  \ 'sfind',
                                  \ 'sfirst',
                                  \ 'simalt',
                                  \ 'sign',
                                  \ 'silent',
                                  \ 'sleep',
                                  \ 'slast',
                                  \ 'smagic',
                                  \ 'smap',
                                  \ 'smapclear',
                                  \ 'smenu',
                                  \ 'snext',
                                  \ 'snomagic',
                                  \ 'snoremap',
                                  \ 'snoremenu',
                                  \ 'source',
                                  \ 'sort',
                                  \ 'split',
                                  \ 'spellgood',
                                  \ 'spelldump',
                                  \ 'spellinfo',
                                  \ 'spellrepall',
                                  \ 'spellundo',
                                  \ 'spellwrong',
                                  \ 'sprevious',
                                  \ 'srewind',
                                  \ 'stop',
                                  \ 'stag',
                                  \ 'startinsert',
                                  \ 'startgreplace',
                                  \ 'startreplace',
                                  \ 'stopinsert',
                                  \ 'stjump',
                                  \ 'stselect',
                                  \ 'sunhide',
                                  \ 'sunmap',
                                  \ 'sunmenu',
                                  \ 'suspend',
                                  \ 'sview',
                                  \ 'swapname',
                                  \ 'syntax',
                                  \ 'syntime',
                                  \ 'syncbind',
                                  \ 't',
                                  \ 'tcd',
                                  \ 'tchdir',
                                  \ 'tNext',
                                  \ 'tag',
                                  \ 'tags',
                                  \ 'tab',
                                  \ 'tabclose',
                                  \ 'tabdo',
                                  \ 'tabedit',
                                  \ 'tabfind',
                                  \ 'tabfirst',
                                  \ 'tabmove',
                                  \ 'tablast',
                                  \ 'tabnext',
                                  \ 'tabnew',
                                  \ 'tabonly',
                                  \ 'tabprevious',
                                  \ 'tabNext',
                                  \ 'tabrewind',
                                  \ 'tabs',
                                  \ 'tcl',
                                  \ 'tcldo',
                                  \ 'tclfile',
                                  \ 'terminal',
                                  \ 'tfirst',
                                  \ 'throw',
                                  \ 'tjump',
                                  \ 'tlast',
                                  \ 'tmap',
                                  \ 'tmapclear',
                                  \ 'tmenu',
                                  \ 'tnext',
                                  \ 'tnoremap',
                                  \ 'topleft',
                                  \ 'tprevious',
                                  \ 'trewind',
                                  \ 'try',
                                  \ 'tselect',
                                  \ 'tunmap',
                                  \ 'tunmenu',
                                  \ 'undo',
                                  \ 'undojoin',
                                  \ 'undolist',
                                  \ 'unabbreviate',
                                  \ 'unhide',
                                  \ 'unlet',
                                  \ 'unlockvar',
                                  \ 'unmap',
                                  \ 'unmenu',
                                  \ 'unsilent',
                                  \ 'update',
                                  \ 'vglobal',
                                  \ 'version',
                                  \ 'verbose',
                                  \ 'vertical',
                                  \ 'visual',
                                  \ 'view',
                                  \ 'vimgrep',
                                  \ 'vimgrepadd',
                                  \ 'viusage',
                                  \ 'vmap',
                                  \ 'vmapclear',
                                  \ 'vmenu',
                                  \ 'vnoremap',
                                  \ 'vnew',
                                  \ 'vnoremenu',
                                  \ 'vsplit',
                                  \ 'vunmap',
                                  \ 'vunmenu',
                                  \ 'write',
                                  \ 'wNext',
                                  \ 'wall',
                                  \ 'while',
                                  \ 'winsize',
                                  \ 'wincmd',
                                  \ 'windo',
                                  \ 'winpos',
                                  \ 'wnext',
                                  \ 'wprevious',
                                  \ 'wq',
                                  \ 'wqall',
                                  \ 'wsverb',
                                  \ 'wshada',
                                  \ 'wundo',
                                  \ 'wviminfo',
                                  \ 'xit',
                                  \ 'xall',
                                  \ 'xmap',
                                  \ 'xmapclear',
                                  \ 'xmenu',
                                  \ 'xnoremap',
                                  \ 'xnoremenu',
                                  \ 'xunmap',
                                  \ 'xunmenu',
                                  \ 'yank',
                                  \ 'z',
                                  \ '!',
                                  \ '#',
                                  \ '&',
                                  \ '<',
                                  \ ':',
                                  \ '>',
                                  \ '@',
                                  \ 'Next',
                                  \ '~',
                                  \ ]
                            
    1              0.000295 let s:command_flags = {
                                  \ 'append': 3150083,
                                  \ 'abbreviate': 1059076,
                                  \ 'abclear': 1048836,
                                  \ 'aboveleft': 2180,
                                  \ 'all': 17667,
                                  \ 'amenu': 1079557,
                                  \ 'anoremenu': 1079557,
                                  \ 'args': 295182,
                                  \ 'argadd': 20751,
                                  \ 'argdelete': 16655,
                                  \ 'argdo': 18599,
                                  \ 'argedit': 315791,
                                  \ 'argglobal': 295182,
                                  \ 'arglocal': 295182,
                                  \ 'argument': 312583,
                                  \ 'ascii': 1573120,
                                  \ 'autocmd': 1058822,
                                  \ 'augroup': 1048854,
                                  \ 'aunmenu': 1059076,
                                  \ 'buffer': 247047,
                                  \ 'bNext': 50435,
                                  \ 'ball': 17665,
                                  \ 'badd': 1081756,
                                  \ 'bdelete': 83207,
                                  \ 'behave': 1048980,
                                  \ 'belowright': 2180,
                                  \ 'bfirst': 49411,
                                  \ 'blast': 49411,
                                  \ 'bmodified': 50435,
                                  \ 'bnext': 50435,
                                  \ 'botright': 2180,
                                  \ 'bprevious': 50435,
                                  \ 'brewind': 49411,
                                  \ 'break': 1573120,
                                  \ 'breakadd': 1048836,
                                  \ 'breakdel': 1048836,
                                  \ 'breaklist': 1048836,
                                  \ 'browse': 1050756,
                                  \ 'buffers': 1048838,
                                  \ 'bufdo': 18599,
                                  \ 'bunload': 83207,
                                  \ 'bwipeout': 214279,
                                  \ 'change': 3147075,
                                  \ 'cNext': 17667,
                                  \ 'cNfile': 17667,
                                  \ 'cabbrev': 1059076,
                                  \ 'cabclear': 1048836,
                                  \ 'caddbuffer': 16661,
                                  \ 'caddexpr': 2452,
                                  \ 'caddfile': 284,
                                  \ 'call': 1575045,
                                  \ 'catch': 1572868,
                                  \ 'cbuffer': 16663,
                                  \ 'cbottom': 256,
                                  \ 'cc': 17667,
                                  \ 'cclose': 17665,
                                  \ 'cd': 1048862,
                                  \ 'cdo': 18599,
                                  \ 'center': 3146053,
                                  \ 'cexpr': 2454,
                                  \ 'cfile': 286,
                                  \ 'cfdo': 18599,
                                  \ 'cfirst': 17667,
                                  \ 'cgetfile': 284,
                                  \ 'cgetbuffer': 16661,
                                  \ 'cgetexpr': 2452,
                                  \ 'chdir': 1048862,
                                  \ 'changes': 1048832,
                                  \ 'checkhealth': 260,
                                  \ 'checkpath': 1048834,
                                  \ 'checktime': 83205,
                                  \ 'chistory': 256,
                                  \ 'clist': 1048838,
                                  \ 'clast': 17667,
                                  \ 'close': 1066243,
                                  \ 'clearjumps': 1048832,
                                  \ 'cmap': 1059076,
                                  \ 'cmapclear': 1048836,
                                  \ 'cmenu': 1079557,
                                  \ 'cnext': 17667,
                                  \ 'cnewer': 17665,
                                  \ 'cnfile': 17667,
                                  \ 'cnoremap': 1059076,
                                  \ 'cnoreabbrev': 1059076,
                                  \ 'cnoremenu': 1079557,
                                  \ 'copy': 3146053,
                                  \ 'colder': 17665,
                                  \ 'colorscheme': 1048852,
                                  \ 'command': 1058822,
                                  \ 'comclear': 1048832,
                                  \ 'compiler': 1048854,
                                  \ 'continue': 1573120,
                                  \ 'confirm': 1050756,
                                  \ 'copen': 17665,
                                  \ 'cprevious': 17667,
                                  \ 'cpfile': 17667,
                                  \ 'cquit': 21763,
                                  \ 'crewind': 17667,
                                  \ 'cscope': 2060,
                                  \ 'cstag': 278,
                                  \ 'cunmap': 1059076,
                                  \ 'cunabbrev': 1059076,
                                  \ 'cunmenu': 1059076,
                                  \ 'cwindow': 17665,
                                  \ 'delete': 3147585,
                                  \ 'delmarks': 1048838,
                                  \ 'debug': 1575044,
                                  \ 'debuggreedy': 1069313,
                                  \ 'delcommand': 1048982,
                                  \ 'delfunction': 1048726,
                                  \ 'display': 1575172,
                                  \ 'diffupdate': 258,
                                  \ 'diffget': 2097413,
                                  \ 'diffoff': 258,
                                  \ 'diffpatch': 2097436,
                                  \ 'diffput': 261,
                                  \ 'diffsplit': 284,
                                  \ 'diffthis': 256,
                                  \ 'digraphs': 1048836,
                                  \ 'djump': 103,
                                  \ 'dlist': 1048679,
                                  \ 'doautocmd': 1048836,
                                  \ 'doautoall': 1048836,
                                  \ 'drop': 295308,
                                  \ 'dsearch': 1048679,
                                  \ 'dsplit': 103,
                                  \ 'edit': 295198,
                                  \ 'earlier': 1048852,
                                  \ 'echo': 1574916,
                                  \ 'echoerr': 1574916,
                                  \ 'echohl': 1573124,
                                  \ 'echomsg': 1574916,
                                  \ 'echon': 1574916,
                                  \ 'else': 1573120,
                                  \ 'elseif': 1574916,
                                  \ 'emenu': 1067397,
                                  \ 'endif': 1573120,
                                  \ 'endfunction': 1048832,
                                  \ 'endfor': 1573120,
                                  \ 'endtry': 1573120,
                                  \ 'endwhile': 1573120,
                                  \ 'enew': 258,
                                  \ 'ex': 295198,
                                  \ 'execute': 1574916,
                                  \ 'exit': 1311103,
                                  \ 'exusage': 256,
                                  \ 'file': 20767,
                                  \ 'files': 1048838,
                                  \ 'filetype': 1048836,
                                  \ 'filter': 2182,
                                  \ 'find': 311583,
                                  \ 'finally': 1573120,
                                  \ 'finish': 1573120,
                                  \ 'first': 295174,
                                  \ 'fold': 1573185,
                                  \ 'foldclose': 1573187,
                                  \ 'folddoopen': 2213,
                                  \ 'folddoclosed': 2213,
                                  \ 'foldopen': 1573187,
                                  \ 'for': 1574916,
                                  \ 'function': 1048582,
                                  \ 'global': 1572967,
                                  \ 'goto': 1590529,
                                  \ 'grep': 18831,
                                  \ 'grepadd': 18831,
                                  \ 'gui': 1343758,
                                  \ 'gvim': 1343758,
                                  \ 'help': 2054,
                                  \ 'helpclose': 17665,
                                  \ 'helpgrep': 2180,
                                  \ 'helptags': 1048972,
                                  \ 'hardcopy': 1319,
                                  \ 'highlight': 1573126,
                                  \ 'hide': 17671,
                                  \ 'history': 1048836,
                                  \ 'insert': 3145987,
                                  \ 'iabbrev': 1059076,
                                  \ 'iabclear': 1048836,
                                  \ 'if': 1574916,
                                  \ 'ijump': 103,
                                  \ 'ilist': 1048679,
                                  \ 'imap': 1059076,
                                  \ 'imapclear': 1048836,
                                  \ 'imenu': 1079557,
                                  \ 'inoremap': 1059076,
                                  \ 'inoreabbrev': 1059076,
                                  \ 'inoremenu': 1079557,
                                  \ 'intro': 1048832,
                                  \ 'isearch': 1048679,
                                  \ 'isplit': 103,
                                  \ 'iunmap': 1059076,
                                  \ 'iunabbrev': 1059076,
                                  \ 'iunmenu': 1059076,
                                  \ 'join': 7341379,
                                  \ 'jumps': 1048832,
                                  \ 'k': 1573141,
                                  \ 'keepmarks': 2180,
                                  \ 'keepjumps': 2180,
                                  \ 'keeppatterns': 2180,
                                  \ 'keepalt': 2180,
                                  \ 'list': 5244225,
                                  \ 'lNext': 17667,
                                  \ 'lNfile': 17667,
                                  \ 'last': 295174,
                                  \ 'language': 1048836,
                                  \ 'laddexpr': 2452,
                                  \ 'laddbuffer': 16661,
                                  \ 'laddfile': 284,
                                  \ 'later': 1048852,
                                  \ 'lbuffer': 16663,
                                  \ 'lbottom': 256,
                                  \ 'lcd': 1048862,
                                  \ 'lchdir': 1048862,
                                  \ 'lclose': 17665,
                                  \ 'lcscope': 2060,
                                  \ 'ldo': 18599,
                                  \ 'left': 3146053,
                                  \ 'leftabove': 2180,
                                  \ 'let': 1574916,
                                  \ 'lexpr': 2454,
                                  \ 'lfile': 286,
                                  \ 'lfdo': 18599,
                                  \ 'lfirst': 17667,
                                  \ 'lgetfile': 284,
                                  \ 'lgetbuffer': 16661,
                                  \ 'lgetexpr': 2452,
                                  \ 'lgrep': 18831,
                                  \ 'lgrepadd': 18831,
                                  \ 'lhelpgrep': 2180,
                                  \ 'lhistory': 256,
                                  \ 'll': 17667,
                                  \ 'llast': 17667,
                                  \ 'llist': 1048838,
                                  \ 'lmap': 1059076,
                                  \ 'lmapclear': 1048836,
                                  \ 'lmake': 2318,
                                  \ 'lnoremap': 1059076,
                                  \ 'lnext': 17667,
                                  \ 'lnewer': 17665,
                                  \ 'lnfile': 17667,
                                  \ 'loadview': 284,
                                  \ 'loadkeymap': 1048576,
                                  \ 'lockmarks': 2180,
                                  \ 'lockvar': 1572998,
                                  \ 'lolder': 17665,
                                  \ 'lopen': 17665,
                                  \ 'lprevious': 17667,
                                  \ 'lpfile': 17667,
                                  \ 'lrewind': 17667,
                                  \ 'ltag': 16662,
                                  \ 'lunmap': 1059076,
                                  \ 'lua': 1048709,
                                  \ 'luado': 1048741,
                                  \ 'luafile': 1048733,
                                  \ 'lvimgrep': 18831,
                                  \ 'lvimgrepadd': 18831,
                                  \ 'lwindow': 17665,
                                  \ 'ls': 1048838,
                                  \ 'move': 3146053,
                                  \ 'mark': 1573141,
                                  \ 'make': 2318,
                                  \ 'map': 1059078,
                                  \ 'mapclear': 1048838,
                                  \ 'marks': 1048836,
                                  \ 'match': 1064965,
                                  \ 'menu': 1079559,
                                  \ 'menutranslate': 1059076,
                                  \ 'messages': 1048837,
                                  \ 'mkexrc': 1048862,
                                  \ 'mksession': 286,
                                  \ 'mkspell': 2446,
                                  \ 'mkvimrc': 1048862,
                                  \ 'mkview': 286,
                                  \ 'mode': 1048852,
                                  \ 'mzscheme': 1573029,
                                  \ 'mzfile': 1048733,
                                  \ 'next': 311567,
                                  \ 'nbkey': 16516,
                                  \ 'nbclose': 1048832,
                                  \ 'nbstart': 1048852,
                                  \ 'new': 311583,
                                  \ 'nmap': 1059076,
                                  \ 'nmapclear': 1048836,
                                  \ 'nmenu': 1079557,
                                  \ 'nnoremap': 1059076,
                                  \ 'nnoremenu': 1079557,
                                  \ 'noremap': 1059078,
                                  \ 'noautocmd': 2180,
                                  \ 'nohlsearch': 1573120,
                                  \ 'noreabbrev': 1059076,
                                  \ 'noremenu': 1079559,
                                  \ 'noswapfile': 2180,
                                  \ 'normal': 1583239,
                                  \ 'number': 5244225,
                                  \ 'nunmap': 1059076,
                                  \ 'nunmenu': 1059076,
                                  \ 'oldfiles': 1573122,
                                  \ 'omap': 1059076,
                                  \ 'omapclear': 1048836,
                                  \ 'omenu': 1079557,
                                  \ 'only': 17667,
                                  \ 'onoremap': 1059076,
                                  \ 'onoremenu': 1079557,
                                  \ 'options': 256,
                                  \ 'ounmap': 1059076,
                                  \ 'ounmenu': 1059076,
                                  \ 'ownsyntax': 1574916,
                                  \ 'print': 5768513,
                                  \ 'packadd': 1573278,
                                  \ 'packloadall': 1573122,
                                  \ 'pclose': 258,
                                  \ 'perl': 1573029,
                                  \ 'perldo': 1048741,
                                  \ 'pedit': 295198,
                                  \ 'pop': 21763,
                                  \ 'popup': 1051014,
                                  \ 'ppop': 21763,
                                  \ 'preserve': 256,
                                  \ 'previous': 312583,
                                  \ 'promptfind': 1050628,
                                  \ 'promptrepl': 1050628,
                                  \ 'profile': 1048838,
                                  \ 'profdel': 1048836,
                                  \ 'psearch': 103,
                                  \ 'ptag': 20759,
                                  \ 'ptNext': 20739,
                                  \ 'ptfirst': 20739,
                                  \ 'ptjump': 278,
                                  \ 'ptlast': 258,
                                  \ 'ptnext': 20739,
                                  \ 'ptprevious': 20739,
                                  \ 'ptrewind': 20739,
                                  \ 'ptselect': 278,
                                  \ 'put': 3150659,
                                  \ 'pwd': 1048832,
                                  \ 'python': 1048709,
                                  \ 'pydo': 1048741,
                                  \ 'pyfile': 1048733,
                                  \ 'py3': 1048709,
                                  \ 'py3do': 1048741,
                                  \ 'python3': 1048709,
                                  \ 'py3file': 1048733,
                                  \ 'quit': 1066243,
                                  \ 'quitall': 258,
                                  \ 'qall': 1048834,
                                  \ 'read': 3412319,
                                  \ 'recover': 286,
                                  \ 'redo': 1048832,
                                  \ 'redir': 1048846,
                                  \ 'redraw': 1048834,
                                  \ 'redrawstatus': 1048834,
                                  \ 'registers': 1050884,
                                  \ 'resize': 1065237,
                                  \ 'retab': 3146103,
                                  \ 'return': 1574916,
                                  \ 'rewind': 295174,
                                  \ 'right': 3146053,
                                  \ 'rightbelow': 2180,
                                  \ 'rshada': 1048862,
                                  \ 'runtime': 1573262,
                                  \ 'rundo': 156,
                                  \ 'ruby': 1048709,
                                  \ 'rubydo': 1048741,
                                  \ 'rubyfile': 1048733,
                                  \ 'rviminfo': 1048862,
                                  \ 'substitute': 1048645,
                                  \ 'sNext': 312583,
                                  \ 'sargument': 312583,
                                  \ 'sall': 17667,
                                  \ 'sandbox': 2180,
                                  \ 'saveas': 1311038,
                                  \ 'sbuffer': 247047,
                                  \ 'sbNext': 50433,
                                  \ 'sball': 50433,
                                  \ 'sbfirst': 33024,
                                  \ 'sblast': 33024,
                                  \ 'sbmodified': 50433,
                                  \ 'sbnext': 50433,
                                  \ 'sbprevious': 50433,
                                  \ 'sbrewind': 33024,
                                  \ 'scriptnames': 1048832,
                                  \ 'scriptencoding': 1048852,
                                  \ 'scscope': 2052,
                                  \ 'set': 1573124,
                                  \ 'setfiletype': 1048964,
                                  \ 'setglobal': 1573124,
                                  \ 'setlocal': 1573124,
                                  \ 'sfind': 311583,
                                  \ 'sfirst': 295174,
                                  \ 'simalt': 1048980,
                                  \ 'sign': 1065093,
                                  \ 'silent': 1575046,
                                  \ 'sleep': 1066245,
                                  \ 'slast': 295174,
                                  \ 'smagic': 1048645,
                                  \ 'smap': 1059076,
                                  \ 'smapclear': 1048836,
                                  \ 'smenu': 1079557,
                                  \ 'snext': 311567,
                                  \ 'snomagic': 1048645,
                                  \ 'snoremap': 1059076,
                                  \ 'snoremenu': 1079557,
                                  \ 'source': 1573150,
                                  \ 'sort': 2099303,
                                  \ 'split': 311583,
                                  \ 'spellgood': 16775,
                                  \ 'spelldump': 258,
                                  \ 'spellinfo': 256,
                                  \ 'spellrepall': 256,
                                  \ 'spellundo': 16775,
                                  \ 'spellwrong': 16775,
                                  \ 'sprevious': 312583,
                                  \ 'srewind': 295174,
                                  \ 'stop': 1048834,
                                  \ 'stag': 20759,
                                  \ 'startinsert': 1048834,
                                  \ 'startgreplace': 1048834,
                                  \ 'startreplace': 1048834,
                                  \ 'stopinsert': 1048834,
                                  \ 'stjump': 278,
                                  \ 'stselect': 278,
                                  \ 'sunhide': 17665,
                                  \ 'sunmap': 1059076,
                                  \ 'sunmenu': 1059076,
                                  \ 'suspend': 1048834,
                                  \ 'sview': 311583,
                                  \ 'swapname': 1048832,
                                  \ 'syntax': 1050628,
                                  \ 'syntime': 1048980,
                                  \ 'syncbind': 256,
                                  \ 't': 3146053,
                                  \ 'tcd': 1048862,
                                  \ 'tchdir': 1048862,
                                  \ 'tNext': 20739,
                                  \ 'tag': 20759,
                                  \ 'tags': 1048832,
                                  \ 'tab': 2180,
                                  \ 'tabclose': 1069335,
                                  \ 'tabdo': 18597,
                                  \ 'tabedit': 315679,
                                  \ 'tabfind': 315807,
                                  \ 'tabfirst': 256,
                                  \ 'tabmove': 20757,
                                  \ 'tablast': 256,
                                  \ 'tabnext': 20757,
                                  \ 'tabnew': 315679,
                                  \ 'tabonly': 1069335,
                                  \ 'tabprevious': 20757,
                                  \ 'tabNext': 20757,
                                  \ 'tabrewind': 256,
                                  \ 'tabs': 1048832,
                                  \ 'tcl': 1048709,
                                  \ 'tcldo': 1048741,
                                  \ 'tclfile': 1048733,
                                  \ 'terminal': 1048590,
                                  \ 'tfirst': 20739,
                                  \ 'throw': 1572996,
                                  \ 'tjump': 278,
                                  \ 'tlast': 258,
                                  \ 'tmap': 1059076,
                                  \ 'tmapclear': 1048836,
                                  \ 'tmenu': 1079557,
                                  \ 'tnext': 20739,
                                  \ 'tnoremap': 1059076,
                                  \ 'topleft': 2180,
                                  \ 'tprevious': 20739,
                                  \ 'trewind': 20739,
                                  \ 'try': 1573120,
                                  \ 'tselect': 278,
                                  \ 'tunmap': 1059076,
                                  \ 'tunmenu': 1059076,
                                  \ 'undo': 1070337,
                                  \ 'undojoin': 1048832,
                                  \ 'undolist': 1048832,
                                  \ 'unabbreviate': 1059076,
                                  \ 'unhide': 17665,
                                  \ 'unlet': 1572998,
                                  \ 'unlockvar': 1572998,
                                  \ 'unmap': 1059078,
                                  \ 'unmenu': 1059078,
                                  \ 'unsilent': 1575044,
                                  \ 'update': 262527,
                                  \ 'vglobal': 1048677,
                                  \ 'version': 1048836,
                                  \ 'verbose': 1591429,
                                  \ 'vertical': 2180,
                                  \ 'visual': 295198,
                                  \ 'view': 295198,
                                  \ 'vimgrep': 18831,
                                  \ 'vimgrepadd': 18831,
                                  \ 'viusage': 256,
                                  \ 'vmap': 1059076,
                                  \ 'vmapclear': 1048836,
                                  \ 'vmenu': 1079557,
                                  \ 'vnoremap': 1059076,
                                  \ 'vnew': 311583,
                                  \ 'vnoremenu': 1079557,
                                  \ 'vsplit': 311583,
                                  \ 'vunmap': 1059076,
                                  \ 'vunmenu': 1059076,
                                  \ 'write': 1311103,
                                  \ 'wNext': 278879,
                                  \ 'wall': 1048834,
                                  \ 'while': 1574916,
                                  \ 'winsize': 388,
                                  \ 'wincmd': 1065109,
                                  \ 'windo': 18597,
                                  \ 'winpos': 1048836,
                                  \ 'wnext': 278815,
                                  \ 'wprevious': 278815,
                                  \ 'wq': 262527,
                                  \ 'wqall': 262462,
                                  \ 'wsverb': 16516,
                                  \ 'wshada': 1048862,
                                  \ 'wundo': 158,
                                  \ 'wviminfo': 1048862,
                                  \ 'xit': 1311103,
                                  \ 'xall': 258,
                                  \ 'xmap': 1059076,
                                  \ 'xmapclear': 1048836,
                                  \ 'xmenu': 1079557,
                                  \ 'xnoremap': 1059076,
                                  \ 'xnoremenu': 1079557,
                                  \ 'xunmap': 1059076,
                                  \ 'xunmenu': 1059076,
                                  \ 'yank': 1050433,
                                  \ 'z': 5243205,
                                  \ '!': 1048655,
                                  \ '#': 5244225,
                                  \ '&': 3145797,
                                  \ '<': 7341377,
                                  \ ':': 5243169,
                                  \ '>': 7341377,
                                  \ '@': 1048901,
                                  \ 'Next': 312583,
                                  \ '~': 3145797,
                                  \ }

SCRIPT  /Users/tianli/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/skip_range.vim
Sourced 1 time
Total time:   0.000222
 Self time:   0.000222

count  total (s)   self (s)
    1              0.000005 let s:chars = " \t0123456789.$%'/?-+,;\\"
                            
    1              0.000003 function! wilder#cmdline#skip_range#do(ctx) abort
                              while a:ctx.pos < len(a:ctx.cmdline) &&
                                    \ stridx(s:chars, a:ctx.cmdline[a:ctx.pos]) != -1
                                let l:char = a:ctx.cmdline[a:ctx.pos]
                                if l:char ==# '\'
                                  if a:ctx.pos + 1 >= len(a:ctx.cmdline)
                                    return 1
                                  endif
                            
                                  let l:second_char = a:ctx.cmdline[a:ctx.pos + 1]
                            
                                  if l:second_char ==# '?' ||
                                        \ l:second_char ==# '/' ||
                                        \ l:second_char ==# '&'
                                    let a:ctx.pos += 2
                                  else
                                    return 1
                                  endif
                                elseif l:char ==# "'"
                                  let a:ctx.pos += 1
                                elseif l:char ==# '/' || l:char ==# '?'
                                  let l:delim = l:char
                                  let a:ctx.pos += 1
                            
                                  while a:ctx.pos < len(a:ctx.cmdline) && a:ctx.cmdline[a:ctx.pos] !=# l:delim
                                    if a:ctx.cmdline[a:ctx.pos] ==# '\' &&
                                          \ a:ctx.pos + 1 < len (a:ctx.cmdline)
                                      let a:ctx.pos += 1
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  if a:ctx.pos == len(a:ctx.cmdline)
                                    return
                                  endif
                                endif
                            
                                let a:ctx.pos += 1
                              endwhile
                            endfunc

SCRIPT  /Users/tianli/.local/share/nvim/lazy/wildfire.vim/autoload/wildfire.vim
Sourced 1 time
Total time:   0.000586
 Self time:   0.000561

count  total (s)   self (s)
                            " =============================================================================
                            " File: wildfire.vim
                            " Description: Smart selection of the closest text object
                            " Mantainer: Giacomo Comitti (https://github.com/gcmt)
                            " Url: https://github.com/gcmt/wildfire.vim
                            " License: MIT
                            " =============================================================================
                            
                            
    1              0.000006 let s:save_cpo = &cpo
    1   0.000026   0.000010 set cpo&vim
                            
                            
                            " Internal variables
                            " =============================================================================
                            
    1              0.000006 let s:cannot_be_nested = {"iw" : 1, "aw" : 1, "iW" : 1, "aW": 1}
                            
    1              0.000002 let s:vim_text_objects = {}
   19              0.000032 for s:char in split("(){}[]<>'`\"bBwWpst", "\\zs")
   18              0.000085     let s:vim_text_objects = extend(s:vim_text_objects, {"a".s:char : 1, "i".s:char : 1})
   19              0.000008 endfor
                            
    1              0.000001 let s:counts = {}
    1              0.000001 let s:history = []
    1              0.000001 let s:origin = []
                            
                            
                            " Functions
                            " =============================================================================
                            
    1              0.000002 fu! wildfire#Start(repeat, objects)
                                cal s:init(a:objects)
                                cal wildfire#Fuel(a:repeat)
                            endfu
                            
    1              0.000001 fu! wildfire#Fuel(repeat)
                                for i in range(a:repeat)
                                    cal s:select_text_object()
                                endfor
                            endfu
                            
    1              0.000001 fu! wildfire#Water(repeat)
                                for i in range(a:repeat)
                                    cal setpos(".", s:origin)
                                    if len(s:history) > 1
                                        let s:counts[remove(s:history, -1).selection.object] -= 1
                                        cal winrestview(get(s:history, -1).view)
                                        cal s:select(get(s:history, -1).selection)
                                    endif
                                endfor
                            endfu
                            
    1              0.000002 fu! s:init(objects)
                                let s:origin = getpos(".")
                                let s:history = []
                                let s:counts = {}
                                let _objects = s:load_objects(a:objects)
                                for object in get(_objects, &ft, get(_objects, "*", []))
                                    let s:counts[object] = 1
                                endfor
                            endfu
                            
    1              0.000001 fu! s:load_objects(objects)
                                " force `a:objects` to be a dictionary
                                let _objects = type(a:objects) == type([]) ? {"*": a:objects} : a:objects
                                " split filetypes that share the same text objects
                                for [ftypes, objs] in items(_objects)
                                    for ft in split(ftypes, ",")
                                        let _objects[ft] = objs
                                    endfor
                                endfor
                                return _objects
                            endfu
                            
    1              0.000001 fu! s:select_text_object()
                            
                                cal setpos(".", s:origin)
                            
                                let view = winsaveview()
                            
                                let candidates = {}
                                for object in keys(s:counts)
                            
                                    let selection = {"object": object, "count": s:counts[object]}
                            
                                    let [startline, startcol, endline, endcol] = s:edges(selection)
                                    let selection = extend(selection,
                                        \ {"startline": startline, "startcol": startcol, "endline": endline, "endcol": endcol })
                            
                                    cal winrestview(view)
                            
                                    " Some text object cannot be nested. This avoids unwanted behavior.
                                    if get(s:cannot_be_nested, selection.object) && selection.count > 1
                                        continue
                                    endif
                            
                                    " The selection failed with the candidate text object
                                    if selection.startline == selection.endline && selection.startcol == selection.endcol
                                        continue
                                    endif
                            
                                    " Sometimes Vim selects text objects even if the cursor is outside the
                                    " them (e.g. `it`, `i"`, etc). We don't want this.
                                    if selection.startline == selection.endline
                                        if s:origin[2] < selection.startcol - 1 || s:origin[2] > selection.endcol + 1
                                            let s:counts[object] += 1
                                            continue
                                        endif
                                    endif
                            
                                    " Check if the cursor is even within selection. If not, we obviously
                                    " don't want that
                                    if s:origin[1] < selection.startline || s:origin[1] > selection.endline
                                        let s:counts[object] += 1
                                        continue
                                    endif
                            
                                    let size = s:size(selection)
                            
                                    " This happens when the _count is incremented but the selection remains still
                                    let _selection = extend(copy(selection), {"count": selection.count-1})
                                    if s:already_selected(_selection)
                                        continue
                                    endif
                            
                                    " Special case
                                    if object =~ "a\"\\|i\"\\|a'\\|i'" && startline == endline
                                        let _selection = extend(copy(selection),
                                            \ {"count": selection.count-1, "startcol": selection.startcol+1, "endcol": selection.endcol-1})
                                        if s:already_selected(_selection)
                                            " When there is no more string to select on the same line, vim
                                            " selects the outer string text object. This is far from the
                                            " desired behavior
                                            continue
                                        endif
                                        let _selection = extend(copy(selection),
                                            \ {"count": selection.count-1, "startcol": selection.startcol+1})
                                        if s:already_selected(_selection)
                                            " This follows the previous check. When the string ends the
                                            " line, the size of the text object is just one character less
                                            continue
                                        endif
                                        let line = getline("'<")
                                        let quote = strpart(object, 1)
                                        let [before, after] = [line[:selection.startcol-3], line[selection.endcol+1:]]
                                        if s:odd_quotes(quote, before) || s:odd_quotes(quote, after)
                                            continue
                                        endif
                                    endif
                            
                                    let candidates[size] = selection
                            
                                endfor
                            
                                cal s:select_best_candidate(candidates)
                            
                            endfu
                            
                            " To select the closest text object among the candidates
    1              0.000002 fu! s:select_best_candidate(candidates)
                                if len(a:candidates)
                                    " select the closest text object (the one with the smaller size)
                                    " skip same size text-objects
                                    let lastsize = 0
                                    if len(s:history)
                                        let lastsize = s:size(get(s:history, -1).selection)
                                    endif
                                    let m = -1
                                    for ss in keys(a:candidates)
                                        let s = str2nr(ss)
                                        if s > lastsize && (m == -1 || s < m)
                                            let m = s
                                        endif
                                    endfor
                                    if m > -1
                                        let selection = a:candidates[m]
                                        let s:history = add(s:history, {"selection": selection, "view": winsaveview()})
                                        let s:counts[selection.object] += 1
                                        cal s:select(selection)
                                    else
                                        cal s:select_best_candidate_fallback()
                                    endif
                                else
                                    cal s:select_best_candidate_fallback()
                                endif
                            endfu
                            
                            " Select best candidate fallback
    1              0.000001 fu! s:select_best_candidate_fallback()
                                if len(s:history)
                                    " get stuck on the last selection
                                    cal s:select(get(s:history, -1).selection)
                                else
                                    " do nothing
                                    exec "sil! norm! \<ESC>"
                                endif
                            endfu
                            
                            " To retrun the edges of a text object
    1              0.000001 fu! s:edges(selection)
                                cal s:select(a:selection)
                                exe "sil! norm! \<ESC>"
                                return [line("'<"), col("'<"), line("'>"), col("'>")]
                            endfu
                            
                            " To select a text object
    1              0.000001 fu! s:select(selection)
                                exe "sil! norm! \<ESC>v\<ESC>v"
                                if get(s:vim_text_objects, a:selection.object)
                                    " use counts when selecting vim text objects
                                    exe "sil! norm! " . a:selection.count . a:selection.object
                                else
                                    " counts might not be suported by non-default text objects
                                    for n in range(a:selection.count)
                                        exe "sil! norm " . a:selection.object
                                    endfor
                                endif
                            endfu
                            
                            " To check if a text object has been already selected
    1              0.000001 fu! s:already_selected(selection)
                                for s in s:history
                                    if s.selection == a:selection
                                        return 1
                                    end
                                endfor
                                return 0
                            endfu
                            
                            " To return the size of a text object
    1              0.000001 fu! s:size(selection)
                                if a:selection.startline == a:selection.endline
                                    return a:selection.endcol - a:selection.startcol + 1
                                endif
                                let size = len(getline(a:selection.startline)) - a:selection.startcol + a:selection.endcol + 1
                                let size += winwidth(0) * (a:selection.endline - a:selection.startline - 1)
                                return size
                            endfu
                            
                            " To check if in a strings there is an odd number of quotes
    1              0.000001 fu! s:odd_quotes(quote, s)
                                let n = 0
                                for i in range(0, strlen(a:s))
                                    if a:s[i] == a:quote && !(i > 0 && a:s[i-1] == "\\")
                                        let n += 1
                                    endif
                                endfor
                                return n % 2 != 0
                            endfu
                            
                            " Quick Select
                            " =============================================================================
                            
    1              0.000001 fu! wildfire#QuickSelect(objects)
                                cal s:init(a:objects)
                                while 1
                                    let last_hist_size = len(s:history)
                                    cal s:select_text_object()
                                    if empty(s:history)
                                        return
                                    end
                                    let selection = get(s:history, -1).selection
                                    if selection.startline < line("w0") || selection.endline > line("w$")
                                        cal wildfire#Water(1)
                                        break
                                    end
                                    if last_hist_size == len(s:history)
                                        break
                                    end
                                endw
                                exe "norm! \<ESC>"
                                cal setpos(".", s:origin)
                                let save_hl = s:turn_off_syntax_errs()
                                let marks = s:show_marks(map(copy(s:history), "v:val.selection"))
                                cal s:jump(marks)
                                cal s:turn_on_syntax_errs(save_hl)
                            endfu
                            
                            " To display marks
    1              0.000001 fu s:show_marks(selections)
                                try | undojoin | catch | endtry
                                cal matchadd("WildfireShade", '\%>'.(line('w0')-1).'l\%<'.line('w$').'l')
                                let marks = split(g:wildfire_marks, '\zs')
                                let placed_marks = {}
                                let candidates = {}
                                for selection in a:selections
                                    if empty(marks) | break | end
                                    if !has_key(placed_marks, selection.startline . "," . selection.startcol)
                                        let [mline, mcol] = [selection.startline, selection.startcol]
                                    elseif !has_key(placed_marks, selection.endline . "," . selection.endcol)
                                        let [mline, mcol] = [selection.endline, selection.endcol]
                                    else
                                        continue
                                    end
                                    let placed_marks[mline.",".mcol] = 1
                                    let mark = remove(marks, 0)
                                    let candidates[mark] = [
                                        \ selection,
                                        \ {"line": mline, "col": mcol, "char": mark, "oldchar": getline(mline)[mcol-1]}
                                    \ ]
                                    cal setline(mline, s:str_subst(getline(mline), mcol-1, mark))
                                    cal matchadd("WildfireMark", '\%'.mline.'l\%'.mcol.'c')
                                endfor
                                setl nomodified
                                return candidates
                            endfu
                            
                            " To ask the user where to jump and move there
    1              0.000001 fu s:jump(marks)
                                if empty(a:marks) | return | end
                                normal! m'
                                while 1
                                    redraw
                                    cal s:show_prompt()
                                    let choice = s:get_char()
                                    if choice =~ '<C-C>\|<ESC>'
                                        cal s:clear_marks(a:marks)
                                        break
                                    end
                                    if has_key(a:marks, choice)
                                        cal s:clear_marks(a:marks)
                                        cal s:select(a:marks[choice][0])
                                        let s:history = s:history[:stridx(g:wildfire_marks, choice)]
                                        break
                                    end
                                endw
                            endfu
                            
                            " To display the prompt
    1              0.000001 fu s:show_prompt()
                                echohl WildfirePrompt | echon g:wildfire_prompt | echohl None
                            endfu
                            
                            
                            " To clear all marks
    1              0.000001 fu s:clear_marks(marks)
                                cal s:clear_matches("WildfireMark", "WildfireShade")
                                try | undojoin | catch | endtry
                                for [s, mark] in values(a:marks)
                                    cal setline(mark.line, s:str_subst(getline(mark.line), mark.col-1, mark.oldchar))
                                endfor
                                setl nomodified
                            endfu
                            
                            " To turn off syntax errors. The returned value can be used to restore syntax
                            " errors with s:turn_on_syntax_err()
    1              0.000001 fu s:turn_off_syntax_errs()
                                let colors = s:colors_of("Error")
                                hi Error None
                                return colors
                            endfu
                            
                            " To turn on syntax errors
    1              0.000001 fu s:turn_on_syntax_errs(colors)
                                cal s:set_colors("Error", a:colors)
                            endfu
                            
                            " Utilities
                            " =============================================================================
                            
                            " To get the colors of given highlight group.
    1              0.000001 fu s:colors_of(group)
                                redir => raw_hl
                                    exe "hi" a:group
                                redir END
                                let raw_hl = substitute(raw_hl, "\n", " ", "")
                                if match(raw_hl, 'cleared') >= 0
                                    return {"colors": "None", "link": ""}
                                end
                                if match(raw_hl, "links to") >= 0
                                    return {"colors": "", "link": matchstr(raw_hl, '\v(links to )@<=.*')}
                                end
                                return {"colors": matchstr(raw_hl, '\v( xxx )@<=.*'), "link": ""}
                            endfu
                            
                            " To set the colors for a given highlight group. Note that this function should
                            " be used exclusively with colors retrieved with the function s:color_of(..)
    1              0.000001 fu s:set_colors(group, colors)
                                if !empty(a:colors.link)
                                    exe "hi link" a:group a:colors.link
                                else
                                    exe "hi" a:group a:colors.colors
                                end
                            endfu
                            
                            " To clear matches of given groups
    1              0.000001 fu s:clear_matches(...)
                                for m in getmatches()
                                    if index(a:000, m.group) != -1
                                        cal matchdelete(m.id)
                                    end
                                endfor
                            endfu
                            
                            " To substitute a character in a string
    1              0.000003 fu s:str_subst(str, col, char)
                                return strpart(a:str, 0, a:col) . a:char . strpart(a:str, a:col+1)
                            endfu
                            
                            " To get a key pressed by the user
    1              0.000001 fu s:get_char()
                                let char = strtrans(getchar())
                                    if char == 13 | return "<CR>"
                                elseif char == 27 | return "<ESC>"
                                elseif char == 9 | return "<TAB>"
                                elseif char >= 1 && char <= 26 | return "<C-" . nr2char(char+64) . ">"
                                elseif char != 0 | return nr2char(char)
                                elseif match(char, '<fc>^D') > 0 | return "<C-SPACE>"
                                elseif match(char, 'kb') > 0 | return "<BS>"
                                elseif match(char, 'ku') > 0 | return "<UP>"
                                elseif match(char, 'kd') > 0 | return "<DOWN>"
                                elseif match(char, 'kl') > 0 | return "<LEFT>"
                                elseif match(char, 'kr') > 0 | return "<RIGHT>"
                                elseif match(char, 'k\\d\\+') > 0 | return "<F" . match(char, '\\d\\+', 4) . ">"
                                end
                            endfu
                            
                            " =============================================================================
                            
    1   0.000015   0.000006 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

FUNCTION  <SNR>51_render()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:121
Called 6 times
Total time:   0.001967
 Self time:   0.000504

count  total (s)   self (s)
    6              0.000013   call timer_stop(a:state.empty_message_first_draw_timer)
                            
    6              0.000006   if a:state.run_id != a:ctx.run_id
    2              0.000002     let a:state.longest_line_width = 0
    2   0.000011   0.000008     call a:state.draw_cache.clear()
    2   0.000009   0.000007     call a:state.highlight_cache.clear()
    6              0.000002   endif
                            
    6              0.000006   let a:state.run_id = a:ctx.run_id
                            
    6              0.000003   if a:ctx.clear_previous
    2              0.000002     let a:state.page = [-1, -1]
    6              0.000001   endif
                            
    6   0.000211   0.000057   let l:page = s:make_page(a:state, a:ctx, a:result)
    6              0.000006   let a:ctx.page = l:page
    6              0.000006   let a:state.page = l:page
                            
    6              0.000013   let l:height = l:page == [-1, -1] ? 0 : l:page[1] - l:page[0] + 1
                            
    6   0.000136   0.000077   let l:min_height = a:state.get_min_height(a:ctx, a:result)
    6              0.000009   let l:min_height -= len(a:state.top)
    6              0.000007   let l:min_height -= len(a:state.bottom)
    6              0.000005   if l:height < l:min_height
                                let l:height = l:min_height
    6              0.000002   endif
                            
    6              0.000006   let a:ctx.height = l:height
    6              0.000007   let a:ctx.highlights = a:state.highlights
                            
                              " Hide popupmenu if there is nothing to draw and empty message is not set
    6              0.000014   if a:state.page == [-1, -1] && !has_key(a:ctx, 'error') && a:state.empty_message is 0
                                call a:state.api.hide()
                                return
    6              0.000001   endif
                            
    6              0.000006   let l:was_first_draw = a:state.is_first_draw
    6              0.000005   let a:state.is_first_draw = 0
                            
                              " Rough hack to prevent empty message from showing for the first draw.
                              " If the pipeline is async, the first draw will always have an empty result.
                              " This delays the empty message from showing to prevent flicker.
    6              0.000014   if l:was_first_draw && a:state.page == [-1, -1] && a:state.empty_message isnot 0 && !a:ctx.done && a:state.empty_message_first_draw_delay > 0
    1              0.000004     let a:state.empty_message_first_draw_timer = timer_start(a:state.empty_message_first_draw_delay, {-> wilder#main#draw()})
    1              0.000000     return
    5              0.000001   endif
                            
                              " If error or empty message is not showing, check if we need to draw.
    5   0.001287   0.000064   if !has_key(a:ctx, 'error') && a:state.page != [-1, -1] && !wilder#renderer#pre_draw(a:state.left + a:state.right + a:state.top + a:state.bottom, a:ctx, a:result)
                                return
    5              0.000001   endif
                            
    5              0.000005   let a:state.render_id += 1
                            
    5   0.000052   0.000029   if a:state.api.need_timer()
    5              0.000005     let l:render_id = a:state.render_id
    5              0.000021     call timer_start(0, {-> s:render_lines_from_timer(l:render_id, a:state, a:ctx, a:result)})
                              else
                                call s:render_lines(a:state, a:ctx, a:result)
    5              0.000001   endif

FUNCTION  <lambda>81()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:113
Called 1 time
Total time:   0.002221
 Self time:   0.000010

count  total (s)   self (s)
                            return s:pre_hook(l:state, ctx)

FUNCTION  <lambda>82()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:113
Called 1 time
Total time:   0.000632
 Self time:   0.000037

count  total (s)   self (s)
                            return s:post_hook(l:state, ctx)

FUNCTION  <SNR>107_UriFromPath()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:175
Called 18 times
Total time:   0.000503
 Self time:   0.000503

count  total (s)   self (s)
   18              0.000036   let absolute = a:absolute
   18              0.000101   if has('win32') && absolute =~# '^\a://\@!'
                                return 'file:///' . strpart(absolute, 0, 2) . s:UrlEncode(strpart(absolute, 2))
   18              0.000053   elseif absolute =~# '^/'
                                return 'file://' . s:UrlEncode(absolute)
   18              0.000153   elseif absolute =~# '^\a[[:alnum:].+-]*:\|^$'
   18              0.000020     return absolute
                              else
                                return ''
                              endif

FUNCTION  <SNR>104_Start()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:34
Called 53 times
Total time:   0.000498
 Self time:   0.000354

count  total (s)   self (s)
   53   0.000446   0.000301   if s:Running() || exists('s:client.startup_error')
   53              0.000028     return
                              endif
                              let s:client = copilot#client#New()

FUNCTION  copilot#logger#Debug()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/logger.vim:53
Called 12 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
   12              0.000034   if empty(get(g:, 'copilot_debug'))
   12              0.000007     return
                              endif
                              call copilot#logger#Raw(4, a:000)

FUNCTION  <SNR>121_select()
    Defined: ~/.local/share/nvim/lazy/wildfire.vim/autoload/wildfire.vim:208
Called 16 times
Total time:   0.019989
 Self time:   0.002329

count  total (s)   self (s)
   16   0.017512   0.001018     exe "sil! norm! \<ESC>v\<ESC>v"
   16              0.000074     if get(s:vim_text_objects, a:selection.object)
                                    " use counts when selecting vim text objects
   16   0.002286   0.001120         exe "sil! norm! " . a:selection.count . a:selection.object
                                else
                                    " counts might not be suported by non-default text objects
                                    for n in range(a:selection.count)
                                        exe "sil! norm " . a:selection.object
                                    endfor
   16              0.000007     endif

FUNCTION  <SNR>104_SuggestionTextWithAdjustments()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:193
Called 43 times
Total time:   0.002889
 Self time:   0.002720

count  total (s)   self (s)
   43              0.000111   let empty = ['', 0, 0, {}]
   43              0.000017   try
   43   0.000971   0.000802     if mode() !~# '^[iR]' || (s:HideDuringCompletion() && pumvisible()) || !exists('b:_copilot.suggestions')
    6              0.000004       return empty
   37              0.000018     endif
   37              0.000105     let choice = get(b:_copilot.suggestions, b:_copilot.choice, {})
   37              0.000149     if !has_key(choice, 'range') || choice.range.start.line != line('.') - 1 || type(choice.insertText) !=# v:t_string
   37              0.000035       return empty
                                endif
                                let line = getline('.')
                                let offset = col('.') - 1
                                let choice_text = strpart(line, 0, copilot#util#UTF16ToByteIdx(line, choice.range.start.character)) . substitute(choice.insertText, "\n*$", '', '')
                                let typed = strpart(line, 0, offset)
                                let end_offset = copilot#util#UTF16ToByteIdx(line, choice.range.end.character)
                                if end_offset < 0
                                  let end_offset = len(line)
                                endif
                                let delete = strpart(line, offset, end_offset - offset)
                                if typed =~# '^\s*$'
                                  let leading = matchstr(choice_text, '^\s\+')
                                  let unindented = strpart(choice_text, len(leading))
                                  if strpart(typed, 0, len(leading)) == leading && unindented !=# delete
                                    return [unindented, len(typed) - len(leading), strchars(delete), choice]
                                  endif
                                elseif typed ==# strpart(choice_text, 0, offset)
                                  return [strpart(choice_text, offset), 0, strchars(delete), choice]
                                endif
                              catch
                                call copilot#logger#Exception()
   43              0.000051   endtry
                              return empty

FUNCTION  <lambda>91()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1325
Called 2 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
                            return res[0] ? res : v:false

FUNCTION  <lambda>94()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1344
Called 2 times
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
                            return res[2]

FUNCTION  <lambda>95()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/transform.vim:95
Called 2 times
Total time:   0.000058
 Self time:   0.000021

count  total (s)   self (s)
                            return wilder#vim_fuzzy_filt(ctx, {}, xs, q)

FUNCTION  <lambda>96()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1127
Called 2 times
Total time:   0.000048
 Self time:   0.000041

count  total (s)   self (s)
                            return wilder#cmdline#is_file_expansion(res.expand)

FUNCTION  <SNR>47_prompt()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:165
Called 3 times
Total time:   0.000647
 Self time:   0.000512

count  total (s)   self (s)
    3              0.000003   let l:cmdline = getcmdline()
    3              0.000003   let a:state.cmdpos = getcmdpos()
    3   0.000154   0.000019   let l:cmdline_data = s:get_cmdline_data(a:state, l:cmdline)
    3              0.000002   let l:hl = a:state.hl
                            
                              " cmdpos includes the prompt character
    3              0.000002   let l:cursor_pos = a:state.cmdpos - 1
                              " -1 as the prompt char is always drawn
    3              0.000002   let l:max_displaywidth = a:ctx.width - 1
    3              0.000002   let l:displaywidth = 0
    3              0.000003   let l:previous_start = len(l:cmdline)
    3              0.000001   let l:previous_end = 0
                            
                              " cursor is at end of cmdline
    3              0.000003   if l:cursor_pos >= len(l:cmdline)
                                " -1 for the cursor
    3              0.000002     let l:max_displaywidth -= 1
    3              0.000002     let l:displaywidth = 0
    3              0.000002     let l:prompt_str = ''
                            
                                " draw entire cmdline starting from the back
    3              0.000003     let l:i = len(l:cmdline_data) - 1
   31              0.000010     while l:i >= 0
                                  " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
   28              0.000017       let l:data = l:cmdline_data[l:i]
                            
   28              0.000020       if l:displaywidth + l:data[2] > l:max_displaywidth
                                    break
   28              0.000004       endif
                            
   28              0.000017       let l:displaywidth += l:data[2]
   28              0.000023       let l:prompt_str = l:data[0] . l:prompt_str
   28              0.000016       let l:previous_start = l:data[3]
                            
   28              0.000010       let l:i -= 1
   31              0.000019     endwhile
                            
    3              0.000003     let l:previous_end = len(l:cmdline)
    3              0.000004     let l:chunks = [[l:prompt_str, l:hl], [' ', a:state.cursor_hl]]
                              else
                                let l:chunks = v:null
                            
                                " check if the cursor fits within previous_start and previous_end
                                " if it does, draw the prompt with the same bounds
                                if strdisplaywidth(l:cmdline) <= l:max_displaywidth || (l:cursor_pos >= a:state.previous_start && l:cursor_pos < a:state.previous_end)
                                  let l:start_seen = 0
                                  let l:cursor_char = ''
                                  let l:before_cursor_str = ''
                                  let l:after_cursor_str = ''
                            
                                  let l:i = 0
                                  while l:i < len(l:cmdline_data)
                                    " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
                                    let l:data = l:cmdline_data[l:i]
                            
                                    if l:data[3] < a:state.previous_start
                                      let l:i += 1
                                      continue
                                    endif
                            
                                    if !l:start_seen
                                      let l:start_seen = 1
                                      let l:previous_start = l:data[3]
                                    endif
                            
                                    if l:data[3] > a:state.previous_end
                                      break
                                    endif
                            
                                    if l:displaywidth + l:data[2] > l:max_displaywidth
                                      break
                                    endif
                            
                                    let l:displaywidth += l:data[2]
                            
                                    if l:data[3] == l:cursor_pos
                                      let l:cursor_char = l:data[0]
                                    elseif l:data[3] < l:cursor_pos
                                      let l:before_cursor_str .= l:data[0]
                                    else
                                      let l:after_cursor_str .= l:data[0]
                                    endif
                            
                                    let l:previous_end = l:data[1] + l:data[3]
                            
                                    let l:i += 1
                                  endwhile
                            
                                  " max_displaywidth reached but cursor is not inside bounds
                                  if l:cursor_char !=# ''
                                    let l:chunks = [[l:before_cursor_str, l:hl], [l:cursor_char, a:state.cursor_hl], [l:after_cursor_str, l:hl]]
                                  endif
                                endif
                            
                                " cursor is not within old bounds, draw new bounds with cursor starting
                                " at the front or end depending on which direction it moved
                                if l:chunks is v:null
                                  let l:displaywidth = 0
                            
                                  if l:cursor_pos < a:state.previous_cursor_pos
                                    " cursor at start
                                    let l:cursor_char = ''
                                    let l:prompt_str = ''
                            
                                    let l:i = 0
                                    while l:i < len(l:cmdline_data)
                                      " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
                                      let l:data = l:cmdline_data[l:i]
                            
                                      if l:data[3] < l:cursor_pos
                                        let l:i += 1
                                        continue
                                      endif
                            
                                      if l:displaywidth + l:data[2] > l:max_displaywidth
                                        break
                                      endif
                            
                                      let l:displaywidth += l:data[2]
                            
                                      if l:data[3] == l:cursor_pos
                                        let l:previous_start = l:data[3]
                                        let l:cursor_char = l:data[0]
                                      else
                                        let l:prompt_str .= l:data[0]
                                      endif
                            
                                      let l:previous_end = l:data[3] + l:data[1]
                            
                                      let l:i += 1
                                    endwhile
                            
                                    let l:chunks = [[l:cursor_char, a:state.cursor_hl], [l:prompt_str, l:hl]]
                                  else
                                    " cursor at end
                                    let l:cursor_char = ''
                                    let l:prompt_str = ''
                            
                                    let l:i = len(l:cmdline_data) - 1
                                    while l:i >= 0
                                      " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
                                      let l:data = l:cmdline_data[l:i]
                            
                                      if l:data[3] > l:cursor_pos
                                        let l:i -= 1
                                        continue
                                      endif
                            
                                      if l:displaywidth + l:data[2] > l:max_displaywidth
                                        break
                                      endif
                            
                                      let l:displaywidth += l:data[2]
                            
                                      if l:data[3] == l:cursor_pos
                                        let l:previous_end = l:data[3]
                                        let l:cursor_char = l:data[0]
                                      else
                                        let l:prompt_str = l:data[0] . l:prompt_str
                                      endif
                            
                                      let l:previous_start = l:data[3] + l:data[1]
                            
                                      let l:i -= 1
                                    endwhile
                            
                                    let l:chunks = [[l:prompt_str, l:hl], [l:cursor_char, a:state.cursor_hl]]
                                  endif
                                endif
    3              0.000001   endif
                            
                              " if there is space leftover, add characters depending on the direction
                              " which the cursor moved
    3              0.000002   if l:displaywidth < l:max_displaywidth
    3              0.000001     let l:str = ''
                            
                                " cursor moved left, add characters to the end
    3              0.000002     if l:cursor_pos < a:state.previous_cursor_pos
                                  let l:i = 0
                                  while l:i < len(l:cmdline_data)
                                    " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
                                    let l:data = l:cmdline_data[l:i]
                            
                                    if l:data[3] < l:previous_end
                                      let l:i += 1
                                      continue
                                    endif
                            
                                    if l:displaywidth + l:data[2] > l:max_displaywidth
                                      break
                                    endif
                            
                                    let l:displaywidth += l:data[2]
                                    let l:str .= l:data[0]
                                    let l:previous_end = l:data[1] + l:data[3]
                            
                                    let l:i += 1
                                  endwhile
                            
                                  call add(l:chunks, [l:str, l:hl])
    3              0.000001     else
                                  " cursor moved right, add characters to the start
    3              0.000002       let l:i = len(l:cmdline_data) - 1
   31              0.000009       while l:i >= 0
                                    " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
   28              0.000016         let l:data = l:cmdline_data[l:i]
                            
   28              0.000014         if l:data[3] >= l:previous_start
   28              0.000010           let l:i -= 1
   28              0.000006           continue
                                    endif
                            
                                    if l:displaywidth + l:data[2] > l:max_displaywidth
                                      break
                                    endif
                            
                                    let l:displaywidth += l:data[2]
                                    let l:str = l:data[0] . l:str
                                    let l:previous_start = l:data[3]
                            
                                    let l:i -= 1
    3              0.000001       endwhile
                            
    3              0.000006       call insert(l:chunks, [l:str, l:hl], 0)
    3              0.000001     endif
    3              0.000001   endif
                            
                              " add padding for the rest of the leftover space
    3              0.000002   if l:displaywidth < l:max_displaywidth
    3              0.000006     call add(l:chunks, [repeat(' ', l:max_displaywidth - l:displaywidth), l:hl])
    3              0.000001   endif
                            
    3              0.000004   call insert(l:chunks, [getcmdtype(), l:hl], 0)
                            
    3              0.000002   let a:state.previous_start = l:previous_start
    3              0.000002   let a:state.previous_end = l:previous_end
    3              0.000002   let a:state.previous_cursor_pos = l:cursor_pos
                            
    3              0.000001   return l:chunks

FUNCTION  <SNR>51_post_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:698
Called 1 time
Total time:   0.000594
 Self time:   0.000342

count  total (s)   self (s)
    1   0.000109   0.000013   call a:state.api.hide()
                            
   13              0.000042   for l:Component in [a:state.empty_message, a:state.error_message] + a:state.left + a:state.right + a:state.top + a:state.bottom
   12   0.000365   0.000208     call wilder#renderer#call_component_post_hook(a:ctx, l:Component)
   13              0.000067   endfor
                            
    1              0.000002   call timer_stop(a:state.empty_message_first_draw_timer)
                            
    1              0.000002   let a:state.active = 0

FUNCTION  wilder#cmdline#parse()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:3
Called 2 times
Total time:   0.003118
 Self time:   0.000658

count  total (s)   self (s)
    2   0.000020   0.000015   if !s:cmdline_cache.has_key(a:cmdline)
    2              0.000005     let l:ctx = {'cmdline': a:cmdline, 'pos': 0, 'cmd': '', 'expand': ''}
    2   0.002938   0.000559     call wilder#cmdline#main#do(l:ctx)
                            
    2              0.000006     let l:ctx['arg'] = l:ctx['cmdline'][l:ctx.pos :]
    2              0.000003     let l:ctx['pos'] = l:ctx.pos
    2   0.000116   0.000045     call s:cmdline_cache.set(a:cmdline, l:ctx)
    2              0.000001   endif
                            
    2   0.000023   0.000020   return copy(s:cmdline_cache.get(a:cmdline))

FUNCTION  wilder#highlight#init_hl()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:16
Called 1 time
Total time:   0.002070
 Self time:   0.000327

count  total (s)   self (s)
    3              0.000009   for [l:name, l:x, l:xs] in s:hl_list
    2   0.002057   0.000314     call s:make_hl(l:name, l:x, l:xs)
    3              0.000001   endfor

FUNCTION  <SNR>107_RequestClient()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:118
Called 18 times
Total time:   0.000128
 Self time:   0.000128

count  total (s)   self (s)
   18              0.000106   return get(s:instances, self.client_id, v:null)

FUNCTION  wilder#resolve()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:37
Called 8 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    8              0.000023   call timer_start(0, {-> wilder#pipeline#resolve(a:ctx, a:x)})

FUNCTION  <SNR>107_NvimDoNotify()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:479
Called 10 times
Total time:   0.000340
 Self time:   0.000340

count  total (s)   self (s)
   10              0.000337   return eval("v:lua.require'_copilot'.rpc_notify(a:client_id, a:method, a:params)")

FUNCTION  copilot#util#AppendPosition()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/util.vim:56
Called 18 times
Total time:   0.001017
 Self time:   0.000785

count  total (s)   self (s)
   18              0.000064   let line = getline('.')
   18              0.000270   let col_byte = col('.') - (mode() =~# '^[iR]' || empty(line))
   18   0.000593   0.000361   let col_utf16 = copilot#util#UTF16Width(strpart(line, 0, col_byte))
   18              0.000064   return {'line': line('.') - 1, 'character': col_utf16}

FUNCTION  <SNR>107_Nop()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:599
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001   return v:null

FUNCTION  copilot#client#LspHandle()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:483
Called 2 times
Total time:   0.000176
 Self time:   0.000069

count  total (s)   self (s)
    2              0.000022   if !has_key(s:instances, a:id)
                                return
    2              0.000002   endif
    2   0.000146   0.000039   return s:OnMessage(s:instances[a:id], a:request)

FUNCTION  <SNR>104_ClearPreview()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:294
Called 47 times
Total time:   0.001063
 Self time:   0.000814

count  total (s)   self (s)
   47              0.000075   if s:has_nvim_ghost_text
   47   0.000707   0.000458     call nvim_buf_del_extmark(0, copilot#NvimNs(), 1)
                              elseif s:has_vim_ghost_text
                                call prop_remove({'type': s:hlgroup, 'all': v:true})
                                call prop_remove({'type': s:annot_hlgroup, 'all': v:true})
   47              0.000019   endif

FUNCTION  copilot#util#UTF16Width()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/util.vim:21
Called 18 times
Total time:   0.000232
 Self time:   0.000232

count  total (s)   self (s)
   18              0.000218   return strchars(substitute(a:str, "\\%#=2[^\u0001-\uffff]", "  ", 'g'))

FUNCTION  <lambda>80()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:113
Called 6 times
Total time:   0.002021
 Self time:   0.000054

count  total (s)   self (s)
                            return s:render(l:state, ctx, result)

FUNCTION  <SNR>51_render_lines_from_timer()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:275
Called 5 times
Total time:   0.051545
 Self time:   0.000102

count  total (s)   self (s)
                              " Multiple renders might be queued, skip if there is a newer render
    5              0.000008   if a:render_id != a:state.render_id || !a:state.active
    2              0.000001     return
    3              0.000001   endif
                            
    3   0.051531   0.000088   call s:render_lines(a:state, a:ctx, a:result)

FUNCTION  copilot#OnCursorMovedI()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:461
Called 17 times
Total time:   0.005297
 Self time:   0.000155

count  total (s)   self (s)
   17   0.005288   0.000147   return copilot#Schedule()

FUNCTION  <SNR>117_pre_draw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:62
Called 40 times
Total time:   0.000798
 Self time:   0.000685

count  total (s)   self (s)
   40              0.000042   if type(a:component) isnot v:t_dict
   36              0.000019     return a:ctx.done
    4              0.000001   endif
                            
    4              0.000005   if has_key(a:component, 'pre_draw')
    4   0.000718   0.000605     return a:component.pre_draw(a:ctx, a:result)
                              endif
                            
                              return a:ctx.done || get(a:component, 'dynamic', 0)

FUNCTION  <SNR>54_delete_all_lines()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:243
Called 3 times
Total time:   0.000151
 Self time:   0.000151

count  total (s)   self (s)
    3              0.000151   call nvim_buf_set_lines(self.state.buf, 0, -1, v:true, [])

FUNCTION  <SNR>107_OnResponse()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:337
Called 18 times
Total time:   0.001762
 Self time:   0.000908

count  total (s)   self (s)
   18              0.000048   let response = a:response
   18              0.000054   let id = get(a:response, 'id', v:null)
   18              0.000042   if !has_key(a:instance.requests, id)
                                return
   18              0.000007   endif
   18              0.000058   let request = remove(a:instance.requests, id)
   18              0.000049   for progress_token in request.progress
                                if has_key(a:instance.progress, progress_token)
                                  call remove(a:instance.progress, progress_token)
                                endif
   18              0.000018   endfor
   18              0.000032   if request.status !=# 'running'
                                return
   18              0.000007   endif
   18              0.000026   if has_key(response, 'result')
    6              0.000013     let request.waiting = {}
    6              0.000010     let resolve = remove(request, 'resolve')
    6              0.000018     call remove(request, 'reject')
    6              0.000006     let request.status = 'success'
    6              0.000007     let request.result = response.result
   12              0.000015     for Cb in resolve
    6              0.000058       let request.waiting[timer_start(0, function('s:Callback', [request, 'result', Cb]))] = 1
   12              0.000039     endfor
   12              0.000006   else
   12   0.000954   0.000100     call s:RejectRequest(request, response.error)
   18              0.000006   endif

FUNCTION  wilder#highlight#get_hl()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:229
Called 2 times
Total time:   0.000059
 Self time:   0.000029

count  total (s)   self (s)
    2              0.000004   if has('nvim')
    2   0.000053   0.000023     return wilder#highlight#get_hl_nvim(a:group)
                              else
                                return wilder#highlight#get_hl_vim(a:group)
                              endif

FUNCTION  wilder#lua#unref_wrapped_function()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/lua.vim:50
Called 4 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    4              0.000007   unlet s:functions[a:index]

FUNCTION  <SNR>16_parent()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:264
Called 2 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    2              0.000002   return fnamemodify(a:dir, ':h')

FUNCTION  <SNR>55_set_query()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1473
Called 2 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    2              0.000003   let l:data = a:data is v:null ? {} : a:data
    2              0.000003   let l:match_arg = get(l:data, 'cmdline.match_arg', '')
                            
    2              0.000013   return extend(l:data, {'query': l:match_arg})

FUNCTION  <SNR>104_HideDuringCompletion()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:189
Called 39 times
Total time:   0.000169
 Self time:   0.000169

count  total (s)   self (s)
   39              0.000151   return get(g:, 'copilot_hide_during_completion', 1)

FUNCTION  <SNR>47_get_middle_position()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:460
Called 3 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
                              " Use max_height so the prompt does not move around the screen when height
                              " of the candidates changes
    3              0.000001   if a:is_top
    3              0.000004     let l:row = (&lines - 1 - a:dimensions.max_height) / 2
                              else
                                let l:row = (&lines - 1 - a:dimensions.max_height) / 2 + a:dimensions.max_height - a:dimensions.height
    3              0.000000   endif
                            
    3              0.000003   let l:col = (&columns - a:dimensions.width) / 2
                            
    3              0.000002   return [l:row, l:col]

FUNCTION  <SNR>1_LoadFTPlugin()
    Defined: /opt/homebrew/Cellar/neovim/0.11.0/share/nvim/runtime/ftplugin.vim:15
Called 8 times
Total time:   0.018814
 Self time:   0.017444

count  total (s)   self (s)
    8              0.000019     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    8              0.000003     endif
                            
    8              0.000018     let s = expand("<amatch>")
    8              0.000006     if s != ""
    8              0.000024       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    8              0.000002       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
   16              0.000031       for name in split(s, '\.')
                                    " Load Lua ftplugins after Vim ftplugins _per directory_
                                    " TODO(clason): use nvim__get_runtime when supports globs and modeline
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
    8   0.018620   0.017250         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
   16              0.000026       endfor
    8              0.000003     endif

FUNCTION  <SNR>51_make_lines()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:446
Called 3 times
Total time:   0.025402
 Self time:   0.005465

count  total (s)   self (s)
    3              0.000006   let l:Highlighter = get(a:state, 'highlighter', [])
                            
    3              0.000002   let l:height = a:ctx.height
                            
    3              0.000002   if l:height > 0
    3   0.000446   0.000439     let l:left_column_chunks = map(repeat([0], l:height), {-> []})
    3   0.001707   0.000025     call s:draw_columns(l:left_column_chunks, a:state.left, a:ctx, a:result)
                            
    3   0.000400   0.000394     let l:right_column_chunks = map(repeat([0], l:height), {-> []})
    3   0.010152   0.000023     call s:draw_columns(l:right_column_chunks, a:state.right, a:ctx, a:result)
                              else
                                let l:left_column_chunks = []
                                let l:right_column_chunks = []
    3              0.000001   endif
                            
                              " [[left_column, chunks, right_column]]
    3              0.000005   let l:raw_lines = repeat([0], l:height)
                              " [[chunks_width, total_width]]
    3              0.000004   let l:widths = repeat([0], l:height)
                            
                              " Draw each line and calculate the width taken by the chunks.
    3              0.000003   let [l:start, l:end] = a:state.page
    3              0.000001   let l:i = 0
   88              0.000039   while l:i < l:height
   85              0.000048     let l:index = l:start + l:i
   85              0.000037     if l:index <= l:end
   85   0.005467   0.000619       let l:chunks = s:draw_candidates_chunks(a:state, a:ctx, a:result, l:index)
                                else
                                  let l:chunks = []
   85              0.000016     endif
   85              0.000073     let l:left_column = l:left_column_chunks[l:i]
   85              0.000073     let l:right_column = l:right_column_chunks[l:i]
                            
   85   0.002476   0.000624     let l:left_width = wilder#render#chunks_displaywidth(l:left_column)
   85   0.001107   0.000603     let l:chunks_width = wilder#render#chunks_displaywidth(l:chunks)
   85   0.001460   0.000597     let l:right_width = wilder#render#chunks_displaywidth(l:right_column)
                            
   85              0.000086     let l:total_width = l:left_width + l:chunks_width + l:right_width
                            
                                " Store the longest line width seen so far.
   85              0.000055     if l:total_width > a:state.longest_line_width
    8              0.000006       let a:state.longest_line_width = l:total_width
   85              0.000015     endif
                            
   85              0.000053     let l:index = l:i - l:start
   85              0.000100     let l:raw_lines[l:i] = [l:left_column, l:chunks, l:right_column]
   85              0.000078     let l:widths[l:i] = [l:chunks_width, l:total_width]
                            
   85              0.000035     let l:i += 1
   88              0.000021   endwhile
                            
    3   0.000036   0.000011   let l:max_width = a:state.get_max_width(a:ctx, a:result)
    3   0.000031   0.000010   let l:min_width = a:state.get_min_width(a:ctx, a:result)
                            
                              " Try to fit the longest line seen so far, if possible.
    3              0.000005   let l:expected_width = min([ l:max_width, a:state.longest_line_width, ])
    3              0.000002   if l:expected_width < l:min_width
    3              0.000002     let l:expected_width = l:min_width
    3              0.000001   endif
                            
                              " lines is the list of list of chunks which will be drawn.
                              " Each element represents one line of the popupmenu.
    3              0.000004   let l:lines = repeat([0], l:height)
                            
    3              0.000001   let l:i = 0
   88              0.000051   while l:i < len(l:raw_lines)
   85              0.000089     let [l:left_column, l:chunks, l:right_column] = l:raw_lines[l:i]
   85              0.000070     let [l:chunks_width, l:total_width] = l:widths[l:i]
                            
                                " Truncate or pad if necessary
   85              0.000044     if l:total_width > l:expected_width
                                  let l:ellipsis = a:state.ellipsis
                                  let l:ellipsis_width = strdisplaywidth(l:ellipsis)
                            
                                  let l:left_right_width = l:total_width - l:chunks_width
                                  let l:truncated_width = l:expected_width - l:left_right_width - l:ellipsis_width
                                  let l:chunks = wilder#render#truncate_chunks(l:truncated_width, l:chunks)
                            
                                  call add(l:chunks, [l:ellipsis])
                                  call add(l:chunks, [repeat(' ', l:truncated_width - wilder#render#chunks_displaywidth(l:chunks))])
   85              0.000045     elseif l:total_width < l:expected_width
   85              0.000057       let l:to_pad = l:expected_width - l:total_width
   85              0.000090       let l:chunks += [[repeat(' ', l:to_pad)]]
   85              0.000013     endif
                            
   85              0.000102     let l:lines[l:i] = l:left_column + l:chunks + l:right_column
                            
   85              0.000031     let l:i += 1
   88              0.000044   endwhile
                            
    3              0.000002   return [l:lines, l:expected_width]

FUNCTION  <SNR>107_RequestCancel()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:292
Called 18 times
Total time:   0.001022
 Self time:   0.000648

count  total (s)   self (s)
   18   0.000362   0.000234   let instance = self.Client()
   18              0.000044   if !empty(instance)
   18   0.000475   0.000230     call instance.Cancel(self)
                              elseif get(self, 'status', '') ==# 'running'
                                call s:RejectRequest(self, s:error_canceled)
   18              0.000008   endif
   18              0.000018   return self

FUNCTION  <SNR>75_Remove_Matches()
    Defined: /opt/homebrew/Cellar/neovim/0.11.0/share/nvim/runtime/plugin/matchparen.vim:203
Called 187 times
Total time:   0.002165
 Self time:   0.002165

count  total (s)   self (s)
  187              0.000500   if exists('w:paren_hl_on') && w:paren_hl_on
    8              0.000017     while !empty(w:matchparen_ids)
    4              0.000024       silent! call remove(w:matchparen_ids, 0)->matchdelete()
    8              0.000007     endwhile
    4              0.000008     let w:paren_hl_on = 0
  187              0.000067   endif

FUNCTION  provider#python3#Call()
    Defined: /opt/homebrew/Cellar/neovim/0.11.0/share/nvim/runtime/autoload/provider/python3.vim:5
Called 65 times
Total time:   0.092474
 Self time:   0.092474

count  total (s)   self (s)
   65              0.092387   return v:lua.vim.provider.python.call(a:method, a:args)

FUNCTION  <SNR>75_Highlight_Matching_Pair()
    Defined: /opt/homebrew/Cellar/neovim/0.11.0/share/nvim/runtime/plugin/matchparen.vim:45
Called 165 times
Total time:   0.013889
 Self time:   0.012046

count  total (s)   self (s)
  165              0.000846   if !exists("w:matchparen_ids")
    2              0.000003     let w:matchparen_ids = []
  165              0.000167   endif
                              " Remove any previous match.
  165   0.003731   0.001887   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  165              0.000567   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
  165              0.000050   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  165              0.000355   let c_lnum = line('.')
  165              0.000244   let c_col = col('.')
  165              0.000127   let before = 0
                            
  165              0.000358   let text = getline(c_lnum)
  165              0.000692   let c_before = text->strpart(0, c_col - 1)->slice(-1)
  165              0.000421   let c = text->strpart(c_col - 1)->slice(0, 1)
  165              0.002134   let plist = split(&matchpairs, '.\zs[:,]')
  165              0.000407   let i = index(plist, c)
  165              0.000132   if i < 0
                                " not found, in Insert mode try character before the cursor
  159              0.000351     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   45              0.000075       let before = strlen(c_before)
   45              0.000032       let c = c_before
   45              0.000053       let i = index(plist, c)
  159              0.000060     endif
  159              0.000091     if i < 0
                                  " not found, nothing to do
  159              0.000106       return
                                endif
    6              0.000002   endif
                            
                              " Figure out the arguments for searchpairpos().
    6              0.000005   if i % 2 == 0
    3              0.000003     let s_flags = 'nW'
    3              0.000007     let c2 = plist[i + 1]
    3              0.000002   else
    3              0.000003     let s_flags = 'nbW'
    3              0.000003     let c2 = c
    3              0.000005     let c = plist[i - 1]
    6              0.000002   endif
    6              0.000005   if c == '['
                                let c = '\['
                                let c2 = '\]'
    6              0.000002   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    6              0.000005   if before > 0
                                let save_cursor = getcurpos()
                                call cursor(c_lnum, c_col - before)
                                defer setpos('.', save_cursor)
    6              0.000002   endif
                            
    6              0.000034   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
    6              0.000021   elseif exists("b:ts_highlight") && &syntax != 'on'
    6              0.000024     let s_skip = "match(v:lua.vim.treesitter.get_captures_at_cursor(), '" .. 'string\|character\|singlequote\|escape\|symbol\|comment' .. "') != -1"
                              else
                                " do not attempt to match when the syntax item where the cursor is
                                " indicates there does not exist a matching parenthesis, e.g. for shells
                                " case statement: "case $var in foobar)"
                                "
                                " add the check behind a filetype check, so it only needs to be
                                " evaluated for certain filetypes
                                if ['sh']->index(&filetype) >= 0 && synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name") =~? "shSnglCase"}) >= 0
                                  return
                                endif
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
    6              0.000002   endif
                            
                              " Limit the search to lines visible in the window.
    6              0.000012   let stoplinebottom = line('w$')
    6              0.000012   let stoplinetop = line('w0')
    6              0.000005   if i % 2 == 0
    3              0.000004     let stopline = stoplinebottom
    3              0.000001   else
    3              0.000003     let stopline = stoplinetop
    6              0.000002   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    6              0.000011   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    6              0.000002   else
    6              0.000023     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    6              0.000003   endif
    6              0.000002   try
    6              0.000346     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
    6              0.000006   endtry
                            
                              " If a match is found setup match highlighting.
    6              0.000012   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom
    4              0.000006     if !g:matchparen_disable_cursor_hl
    4              0.000049       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
                                else
                                  call add(w:matchparen_ids, matchaddpos('MatchParen', [[m_lnum, m_col]], 10))
    4              0.000002     endif
    4              0.000006     let w:paren_hl_on = 1
    6              0.000002   endif

FUNCTION  wilder#render#chunks_displaywidth()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/render.vim:250
Called 255 times
Total time:   0.003218
 Self time:   0.003218

count  total (s)   self (s)
  255              0.000110   let l:width = 0
                            
  764              0.000299   for l:chunk in a:chunks
  509              0.000271     if !empty(l:chunk)
  509              0.000503       let l:width += strdisplaywidth(l:chunk[0])
  509              0.000085     endif
  764              0.001333   endfor
                            
  255              0.000097   return l:width

FUNCTION  <SNR>121_load_objects()
    Defined: ~/.local/share/nvim/lazy/wildfire.vim/autoload/wildfire.vim:64
Called 1 time
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
                                " force `a:objects` to be a dictionary
    1              0.000005     let _objects = type(a:objects) == type([]) ? {"*": a:objects} : a:objects
                                " split filetypes that share the same text objects
    2              0.000005     for [ftypes, objs] in items(_objects)
    2              0.000005         for ft in split(ftypes, ",")
    1              0.000002             let _objects[ft] = objs
    2              0.000016         endfor
    2              0.000001     endfor
    1              0.000002     return _objects

FUNCTION  <SNR>51_draw_columns()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:543
Called 6 times
Total time:   0.011811
 Self time:   0.001533

count  total (s)   self (s)
    6              0.000005   let l:height = a:ctx.height
                            
   24              0.000014   for l:Column in a:columns
   18   0.010476   0.000198     let l:column = wilder#renderer#popupmenu#draw_column(a:ctx, a:result, l:Column)
                            
   18              0.000012     if empty(l:column)
    4              0.000001       continue
   14              0.000003     endif
                            
   14              0.000008     let l:i = 0
  438              0.000290     while l:i < len(l:column)
  424              0.000421       let a:column_chunks[l:i] += l:column[l:i]
                            
  424              0.000188       let l:i += 1
  438              0.000168     endwhile
                            
   14              0.000008     if l:i < l:height
                                  let l:width = wilder#render#chunks_displaywidth(l:column[0])
                            
                                  while l:i < l:height
                                    let a:column_chunks[l:i] += [[repeat(' ', l:width)]]
                            
                                    let l:i += 1
                                  endwhile
   14              0.000003     endif
   20              0.000008   endfor

FUNCTION  copilot#client#Result()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:735
Called 18 times
Total time:   0.000171
 Self time:   0.000171

count  total (s)   self (s)
   18              0.000041   if has_key(a:request, 'resolve')
   18              0.000038     call add(a:request.resolve, a:callback)
                              elseif has_key(a:request, 'result')
                                let a:request.waiting[timer_start(0, function('s:Callback', [a:request, 'result', a:callback]))] = 1
   18              0.000007   endif

FUNCTION  <SNR>2_LoadIndent()
    Defined: /opt/homebrew/Cellar/neovim/0.11.0/share/nvim/runtime/indent.vim:14
Called 8 times
Total time:   0.004895
 Self time:   0.004682

count  total (s)   self (s)
    8              0.000012     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    8              0.000002     endif
    8              0.000012     let s = expand("<amatch>")
    8              0.000005     if s != ""
    8              0.000006       if exists("b:did_indent")
                            	unlet b:did_indent
    8              0.000002       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
   16              0.000020       for name in split(s, '\.')
                                    " XXX: "[.]" in the pattern makes it a wildcard on Windows
    8   0.004791   0.004578         exe $'runtime! indent/{name}[.]{{vim,lua}}'
   16              0.000008       endfor
    8              0.000002     endif

FUNCTION  copilot#OnInsertLeavePre()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:444
Called 4 times
Total time:   0.002081
 Self time:   0.000140

count  total (s)   self (s)
    4   0.001935   0.000087   call copilot#Clear()
    4   0.000141   0.000049   call s:ClearPreview()

FUNCTION  <SNR>54_set_line()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:247
Called 97 times
Total time:   0.000684
 Self time:   0.000684

count  total (s)   self (s)
   97              0.000672   call nvim_buf_set_lines(self.state.buf, a:line, a:line, v:true, [a:str])

FUNCTION  <SNR>47_prompt_pre_draw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:160
Called 4 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    4              0.000011   return a:state.cached_cmdline !=# getcmdline() || a:state.cmdpos != getcmdpos()

FUNCTION  <SNR>54_set_option()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:230
Called 5 times
Total time:   0.000099
 Self time:   0.000037

count  total (s)   self (s)
    5              0.000003   if self.state.window_state ==# 'hidden'
                                return
    5              0.000001   endif
                            
    5              0.000002   if self.state.window_state ==# 'pending'
                                let self.state.options[a:option] = a:value
                                return
    5              0.000001   endif
                            
    5   0.000084   0.000022   call nvim_win_set_option(self.state.win, a:option, a:value)

FUNCTION  <SNR>121_select_text_object()
    Defined: ~/.local/share/nvim/lazy/wildfire.vim/autoload/wildfire.vim:76
Called 2 times
Total time:   0.026010
 Self time:   0.000754

count  total (s)   self (s)
                            
    2              0.000007     cal setpos(".", s:origin)
                            
    2              0.000008     let view = winsaveview()
                            
    2              0.000003     let candidates = {}
   16              0.000018     for object in keys(s:counts)
                            
   14              0.000046         let selection = {"object": object, "count": s:counts[object]}
                            
   14   0.023535   0.000162         let [startline, startcol, endline, endcol] = s:edges(selection)
   14              0.000106         let selection = extend(selection, {"startline": startline, "startcol": startcol, "endline": endline, "endcol": endcol })
                            
   14              0.000040         cal winrestview(view)
                            
                                    " Some text object cannot be nested. This avoids unwanted behavior.
   14              0.000038         if get(s:cannot_be_nested, selection.object) && selection.count > 1
                                        continue
   14              0.000006         endif
                            
                                    " The selection failed with the candidate text object
   14              0.000029         if selection.startline == selection.endline && selection.startcol == selection.endcol
    9              0.000006             continue
    5              0.000001         endif
                            
                                    " Sometimes Vim selects text objects even if the cursor is outside the
                                    " them (e.g. `it`, `i"`, etc). We don't want this.
    5              0.000004         if selection.startline == selection.endline
    3              0.000007             if s:origin[2] < selection.startcol - 1 || s:origin[2] > selection.endcol + 1
    3              0.000006                 let s:counts[object] += 1
    3              0.000002                 continue
                                        endif
    2              0.000001         endif
                            
                                    " Check if the cursor is even within selection. If not, we obviously
                                    " don't want that
    2              0.000005         if s:origin[1] < selection.startline || s:origin[1] > selection.endline
                                        let s:counts[object] += 1
                                        continue
    2              0.000001         endif
                            
    2   0.000043   0.000018         let size = s:size(selection)
                            
                                    " This happens when the _count is incremented but the selection remains still
    2              0.000013         let _selection = extend(copy(selection), {"count": selection.count-1})
    2   0.000033   0.000017         if s:already_selected(_selection)
                                        continue
    2              0.000000         endif
                            
                                    " Special case
    2              0.000013         if object =~ "a\"\\|i\"\\|a'\\|i'" && startline == endline
                                        let _selection = extend(copy(selection), {"count": selection.count-1, "startcol": selection.startcol+1, "endcol": selection.endcol-1})
                                        if s:already_selected(_selection)
                                            " When there is no more string to select on the same line, vim
                                            " selects the outer string text object. This is far from the
                                            " desired behavior
                                            continue
                                        endif
                                        let _selection = extend(copy(selection), {"count": selection.count-1, "startcol": selection.startcol+1})
                                        if s:already_selected(_selection)
                                            " This follows the previous check. When the string ends the
                                            " line, the size of the text object is just one character less
                                            continue
                                        endif
                                        let line = getline("'<")
                                        let quote = strpart(object, 1)
                                        let [before, after] = [line[:selection.startcol-3], line[selection.endcol+1:]]
                                        if s:odd_quotes(quote, before) || s:odd_quotes(quote, after)
                                            continue
                                        endif
    2              0.000000         endif
                            
    2              0.000004         let candidates[size] = selection
                            
    4              0.000005     endfor
                            
    2   0.001860   0.000017     cal s:select_best_candidate(candidates)
                            

FUNCTION  <SNR>55_prepare_fuzzy_completion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:46
Called 2 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
                              " For non-python completion, a maximum of 300 help tags are returned, so
                              " getting all the candidates and filtering will miss out on a lot of matches
                              " If argument is empty, don't fuzzy match except for expanding 'help', where
                              " the default argument is 'help'
    2              0.000004   if (a:res.expand ==# 'help' && !a:use_python) || a:res.pos == len(a:res.cmdline)
    1              0.000001     return a:res
    1              0.000000   endif
                            
                              " Remove the starting s: and g: so the fuzzy filter does not match against
                              " that them.
    1              0.000002   if (a:res.expand ==# 'expression' || a:res.expand ==# 'var') && a:res.expand_arg[1] ==# ':' && (a:res.expand_arg[0] ==# 'g' || a:res.expand_arg[0] ==# 's')
                                let a:res.fuzzy_char = a:res.expand_arg[2]
                                let a:res.match_arg = a:res.expand_arg[2 :]
                                let a:res.expand_arg = a:res.expand_arg[0: 1]
                            
                              " For tag-regexp, keep the argument and don't do fuzzy matching
    1              0.000001   elseif a:res.expand ==# 'tags' && a:res.expand_arg[0] ==# '/'
                                let a:res.fuzzy_char = ''
                                let a:res.match_arg = ''
                            
                              " Return all candidates and let the fuzzy filter remove the non-matching
                              " candidates for the following cases:
                              "
                              " mapping: special keys such as <Space> cannot be fuzzy completed since
                              " < will not get completions for <Space>.
                              "
                              " buffer: getcompletion() for buffers checks against the file name, but
                              " we want to check against the full path.
                              "
                              " help: help tag matching does not have to start from beginning of word.
    1              0.000001   elseif a:res.expand ==# 'mapping' || a:res.expand ==# 'buffer' || a:res.expand ==# 'help'
                                " Default argument for help completion is 'help'
                                if a:res.expand ==# 'help' && empty(a:res.expand_arg)
                                  let a:res.match_arg = 'help'
                                else
                                  let a:res.match_arg = a:res.expand_arg
                                endif
                            
                                let a:res.expand_arg = ''
                                let a:res.fuzzy_char = ''
    1              0.000000   else
                                " Default case, expand with the fuzzy_char
    1              0.000002     let a:res.fuzzy_char = strcharpart(a:res.expand_arg, 0, 1)
    1              0.000001     let a:res.expand_arg = ''
    1              0.000000   endif
                            
    1              0.000000   return a:res

FUNCTION  <SNR>113_post_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:236
Called 1 time
Total time:   0.000725
 Self time:   0.000050

count  total (s)   self (s)
    1   0.000027   0.000015   call wilder#pipeline#clear_handlers()
                            
    1              0.000004   if has_key(s:opts.renderer, 'post_hook')
    1   0.000687   0.000024     call s:opts.renderer.post_hook({})
    1              0.000000   endif
                            
    1              0.000002   if has_key(s:opts, 'post_hook')
                                call s:opts.post_hook({})
    1              0.000000   endif

FUNCTION  wilder#main#start()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:79
Called 16 times
Total time:   0.000704
 Self time:   0.000448

count  total (s)   self (s)
                              " Workaround for https://github.com/neovim/neovim/issues/15403
   16   0.000484   0.000228   if wilder#main#in_mode() && s:enabled
                                " use timer_start so statusline does not flicker
                                " when using mappings which performs a command
   16              0.000135     call timer_start(0, {-> s:start()})
   16              0.000023   endif

FUNCTION  <SNR>47_prompt_pre_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:409
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000003   call timer_stop(a:state.timer)
                            
    1              0.000008   let a:state.cmdpos = -1
    1              0.000001   let a:state.previous_start = -1
    1              0.000001   let a:state.previous_end = -1
                            
    1              0.000008   let a:state.timer = timer_start(a:state.cursor_check_interval, {-> s:prompt_update_cursor(a:state)}, {'repeat': -1})

FUNCTION  <SNR>46_scrollbar()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/component/popupmenu_scrollbar.vim:17
Called 3 times
Total time:   0.000078
 Self time:   0.000078

count  total (s)   self (s)
    3              0.000003   let [l:start, l:end] = a:ctx.page
    3              0.000004   let l:num_candidates = len(a:result.value)
    3              0.000002   let l:height = a:ctx.height
                            
    3              0.000003   if l:num_candidates <= l:height
    1              0.000000     if a:state.collapse
    1              0.000000       return []
                                else
                                  return repeat([[a:state.scrollbar_chunk]], l:height)
                                endif
    2              0.000000   endif
                            
    2              0.000006   let l:thumb_start = float2nr(1.0 * l:start * l:height / l:num_candidates)
    2              0.000004   let l:thumb_size = float2nr(1.0 * l:height * l:height / l:num_candidates) + 1
    2              0.000003   let l:thumb_end = l:thumb_start + l:thumb_size
                            
                              " Due to floating point rounding, thumb can exceed height.
                              " Adjust the thumb back 1 row so that visually the thumb size remains fixed.
                              " The position of the thumb will be wrong but the fixed thumb size is more
                              " important.
    2              0.000002   if l:thumb_end > l:height
                                let l:thumb_start -= 1
                                let l:thumb_end -= 1
    2              0.000000   endif
                            
                              " Adjust case where rounding causes l:thumb_size to equal l:height.
    2              0.000002   if l:thumb_size == l:height
                                let l:thumb_size -= 1
                            
                                if l:end < l:num_candidates - 1
                                  let l:thumb_end -= 1
                                else
                                  let l:thumb_start += 1
                                endif
    2              0.000000   endif
                            
    2              0.000002   let l:thumb_chunk = a:state.thumb_chunk
    2              0.000002   let l:scrollbar_chunk = a:state.scrollbar_chunk
                            
    2              0.000005   let l:before_thumb_chunks = repeat([[l:scrollbar_chunk]], l:thumb_start)
    2              0.000004   let l:thumb_chunks = repeat([[l:thumb_chunk]], l:thumb_size)
    2              0.000005   let l:after_thumb_chunks = repeat([[l:scrollbar_chunk]], l:height - l:thumb_end)
                            
    2              0.000005   return l:before_thumb_chunks + l:thumb_chunks + l:after_thumb_chunks

FUNCTION  <SNR>98_SynSet()
    Defined: /opt/homebrew/Cellar/neovim/0.11.0/share/nvim/runtime/syntax/synload.vim:27
Called 33 times
Total time:   0.035450
 Self time:   0.035450

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
   33              0.000072   syn clear
   33              0.000066   if exists("b:current_syntax")
                                unlet b:current_syntax
   33              0.000014   endif
                            
   33              0.000090   0verbose let s = expand("<amatch>")
   33              0.000035   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
   33              0.000024   elseif s == "OFF"
                                let s = ""
   33              0.000009   endif
                            
   33              0.000018   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
   38              0.000082     for name in split(s, '\.')
   19              0.000022       if !empty(name)
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
   19              0.034539         exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
   19              0.000025       endif
   38              0.000043     endfor
   33              0.000010   endif

FUNCTION  <SNR>16_has()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:212
Called 10 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
                              " We do not want a:dir to be treated as a glob so escape any wildcards.
                              " If this approach is problematic (e.g. on Windows), an alternative
                              " might be to change directory to a:dir, call globpath() with just
                              " a:identifier, then restore the working directory.
   10              0.000079   return !empty(globpath(escape(a:dir, '?*[]'), a:identifier, 1))

FUNCTION  <SNR>113_run_pipeline()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:293
Called 2 times
Total time:   0.000973
 Self time:   0.000268

count  total (s)   self (s)
    2              0.000003   let s:run_id += 1
                            
    2              0.000007   let l:ctx = { 'input': a:input, 'run_id': s:run_id, 'session_id': s:session_id, }
                            
    2              0.000001   if a:0 > 0
                                call extend(l:ctx, a:1)
    2              0.000001   endif
                            
    2   0.000954   0.000249   call wilder#pipeline#run( s:opts.pipeline, function('wilder#main#on_finish'), function('wilder#main#on_error'), l:ctx, a:input, )

FUNCTION  wilder#pipeline#wait()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:166
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000004   let l:state = { 'f': a:f, 'on_finish': a:on_finish, }
                            
    2              0.000004   return {ctx -> s:wait_start(l:state, ctx)}

FUNCTION  <SNR>16_activate()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:102
Called 13 times
Total time:   0.001401
 Self time:   0.000832

count  total (s)   self (s)
   13              0.000064   if index(g:rooter_buftypes, &buftype) == -1 | return 0 | endif
                            
   13              0.000029   if type(g:rooter_targets) == type([])
   13              0.000022     let patterns = g:rooter_targets
                              else
                                let patterns = split(g:rooter_targets, ',')
   13              0.000004   endif
   13   0.000732   0.000163   let fn = s:current_file()
                            
                              " directory
   13              0.000061   if empty(fn) || isdirectory(fn)
    2              0.000004     return index(patterns, '/') != -1
   11              0.000003   endif
                            
                              " file
   11              0.000182   if !filereadable(fn) | return 0 | endif
    8              0.000022   if !exists('*glob2regpat') | return 1 | endif
                            
    8              0.000057   for p in filter(copy(patterns), 'v:val != "/"')
    8              0.000019     if p[0] == '!'
                                  let [p, verdict] = [p[1:], 0]
    8              0.000003     else
    8              0.000016       let [p, verdict] = [p, 1]
    8              0.000003     endif
    8              0.000072     if fn =~ glob2regpat(p)
    8              0.000007       return verdict
                                endif
                              endfor
                            
                              return 0

FUNCTION  <lambda>97()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/check.vim:1
Called 2 times
Total time:   0.000071
 Self time:   0.000010

count  total (s)   self (s)
                            return s:check(a:args, ctx, x)

FUNCTION  wilder#cmdline#get_fuzzy_completion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:261
Called 2 times
Total time:   0.000418
 Self time:   0.000053

count  total (s)   self (s)
                              " Use tag-regexp to get fuzzy completions from taglist()
    2              0.000001   if a:res.expand ==# 'tags'
                                let l:fuzzy_char = get(a:res, 'fuzzy_char', '')
                            
                                if empty(l:fuzzy_char)
                                  let a:res.expand_arg = '.'
                                else
                                  let a:res.expand_arg = '/'
                                  if toupper(l:fuzzy_char) !=# l:fuzzy_char
                                    let a:res.expand_arg .= '\c'
                                  endif
                            
                                  if a:fuzzy_mode == 1
                                    let a:res.expand_arg .= '^'
                                  endif
                            
                                  let a:res.expand_arg .= l:fuzzy_char
                                endif
                            
                                return a:getcompletion(a:ctx, a:res)
    2              0.000000   endif
                            
                              " If argument is empty, use normal completions
                              " Don't fuzzy complete for vim help since a maximum of 300 help tags are returned
    2              0.000003   if a:res.pos == len(a:res.cmdline) || (a:res.expand ==# 'help' && !a:use_python)
    1   0.000329   0.000012     return a:getcompletion(a:ctx, a:res)
    1              0.000000   endif
                            
    1              0.000001   let l:fuzzy_char = get(a:res, 'fuzzy_char', '')
                            
                              " Keep leading . in file expansion to search hidden directories
    1              0.000001   if a:fuzzy_mode == 2 && !(wilder#cmdline#is_file_expansion(a:res.expand) && l:fuzzy_char ==# '.')
                                let l:fuzzy_char = ''
    1              0.000000   endif
                            
    1              0.000001   if toupper(l:fuzzy_char) ==# l:fuzzy_char
    1              0.000001     let a:res.expand_arg = a:res.expand_arg . l:fuzzy_char
    1   0.000056   0.000008     return a:getcompletion(a:ctx, a:res)
                              endif
                            
                              let l:lower_res = copy(a:res)
                              let l:lower_res.expand_arg = a:res.expand_arg . l:fuzzy_char
                            
                              let l:upper_res = copy(a:res)
                              let l:upper_res.expand_arg = a:res.expand_arg . toupper(l:fuzzy_char)
                            
                              return wilder#wait(a:getcompletion(a:ctx, l:upper_res), {ctx, upper_xs -> wilder#resolve(ctx, wilder#wait(a:getcompletion(ctx, l:lower_res), {ctx, lower_xs -> wilder#resolve(ctx, wilder#uniq_filt(0, 0, lower_xs + upper_xs))}))})

FUNCTION  wilder#renderer#popupmenu#draw_column()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:572
Called 18 times
Total time:   0.010278
 Self time:   0.001009

count  total (s)   self (s)
   18              0.000014   let l:Column = a:column
   18              0.000012   let l:height = a:ctx.height
                            
   18              0.000016   if type(l:Column) is v:t_dict
                                let l:Column = l:Column.value
   18              0.000004   endif
                            
   18              0.000014   if type(l:Column) is v:t_func
    6   0.010057   0.000788     let l:Column = l:Column(a:ctx, a:result)
   18              0.000004   endif
                            
   18              0.000015   if type(l:Column) is v:t_string
    9              0.000006     if empty(l:Column)
    3              0.000001       return []
    6              0.000001     endif
                            
    6              0.000012     return repeat([[[l:Column]]], l:height)
    9              0.000002   endif
                            
                              " v:t_list
    9              0.000006   if empty(l:Column)
    1              0.000000     return []
    8              0.000001   endif
                            
    8              0.000007   if empty(l:Column[0])
                                return []
    8              0.000002   endif
                            
                              " highlight chunk
    8              0.000008   if type(l:Column[0]) is v:t_string
    6              0.000010     return repeat([[l:Column]], l:height)
    2              0.000000   endif
                            
                              " list of highlight chunks
    2              0.000002   if type(l:Column[0][0]) is v:t_string
                                return repeat([l:Column], l:height)
    2              0.000000   endif
                            
                              " list of list of highlight chunks
    2              0.000001   return l:Column

FUNCTION  <SNR>16_current_file()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:255
Called 16 times
Total time:   0.000646
 Self time:   0.000646

count  total (s)   self (s)
   16              0.000402   let fn = expand('%:p', 1)
   16              0.000141   if fn =~ 'NERD_tree_\d\+$' | let fn = b:NERDTree.root.path.str().'/' | endif
   16              0.000038   if fn[:5] == 'oil://' | let fn = fn[5:] | endif
   16              0.000032   if g:rooter_resolve_links | let fn = resolve(fn) | endif
   16              0.000011   return fn

FUNCTION  <SNR>22_vm_persist()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/plugin/visual-multi.vim:82
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000002   if exists('g:VM_PERSIST') && !g:VM_persistent_registers
                                unlet g:VM_PERSIST
    1              0.000001   elseif g:VM_persistent_registers
                                let g:VM_PERSIST = deepcopy(g:Vm.registers)
    1              0.000000   endif

FUNCTION  <SNR>104_HandleTriggerError()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:378
Called 12 times
Total time:   0.002658
 Self time:   0.000238

count  total (s)   self (s)
   12              0.000043   let a:state.suggestions = []
   12              0.000015   let a:state.choice = 0
   12              0.000015   let a:state.error = a:result
   12              0.000029   if get(b:, '_copilot') is# a:state
   12   0.002535   0.000115     call s:UpdatePreview()
   12              0.000005   endif

FUNCTION  copilot#Client()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:48
Called 53 times
Total time:   0.000883
 Self time:   0.000384

count  total (s)   self (s)
   53   0.000834   0.000335   call s:Start()
   53              0.000031   return s:client

FUNCTION  wilder#cmdline#main#is_whitespace()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/main.vim:678
Called 4 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    4              0.000008   let l:nr = char2nr(a:char)
    4              0.000008   return a:char ==# ' ' || l:nr >= 9 && l:nr <= 13

FUNCTION  copilot#Suggest()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:387
Called 18 times
Total time:   0.012738
 Self time:   0.000734

count  total (s)   self (s)
   18   0.000368   0.000224   if !s:Running()
                                return ''
   18              0.000009   endif
   18              0.000017   try
   18   0.012207   0.000346     call copilot#Complete(function('s:HandleTriggerResult'), function('s:HandleTriggerError'))
                              catch
                                call copilot#logger#Exception()
   18              0.000021   endtry
   18              0.000013   return ''

FUNCTION  wilder#render#draw_candidate()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/render.vim:10
Called 85 times
Total time:   0.001957
 Self time:   0.001520

count  total (s)   self (s)
   85   0.000604   0.000526   let l:x = wilder#main#get_candidate(a:ctx, a:result, a:i)
                            
   85              0.000065   if has_key(a:result, 'draw')
                                let l:ctx = { 'i': a:i, 'selected': a:ctx.selected == a:i, }
                            
                                for l:F in a:result.draw
                                  if type(l:F) isnot v:t_func
                                    let l:F = function(l:F)
                                  endif
                            
                                  let l:x = l:F(l:ctx, l:x, get(a:result, 'data', {}))
                                endfor
   85              0.000016   endif
                            
   85   0.000864   0.000506   return wilder#render#to_printable(l:x)

FUNCTION  UltiSnips#CheckFiletype()
    Defined: ~/.local/share/nvim/lazy/ultisnips/autoload/UltiSnips.vim:194
Called 12 times
Total time:   0.006003
 Self time:   0.006003

count  total (s)   self (s)
   12              0.005989     py3 UltiSnips_Manager._check_filetype(vim.eval('&ft'))

FUNCTION  wilder#lua#call_wrapped_function()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/lua.vim:44
Called 61 times
Total time:   0.045794
 Self time:   0.001154

count  total (s)   self (s)
   61              0.000123   let l:F = s:functions[a:index]
   61   0.010670   0.005083   let l:Result = call(l:F, a:000)
   61   0.024295   0.000429   return wilder#lua#wrap(l:Result)

FUNCTION  copilot#OnFileType()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:427
Called 8 times
Total time:   0.000424
 Self time:   0.000212

count  total (s)   self (s)
    8   0.000367   0.000175   if empty(s:BufferDisabled()) && &l:modifiable && &l:buflisted
    3   0.000045   0.000025     call copilot#util#Defer(function('s:Attach'), bufnr(''))
    8              0.000002   endif

FUNCTION  <SNR>58_check()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/check.vim:5
Called 6 times
Total time:   0.000110
 Self time:   0.000058

count  total (s)   self (s)
    6              0.000004   let l:i = 0
                            
    8              0.000009   for l:Check in a:checks
    6   0.000081   0.000029     if !l:Check(a:ctx, a:x)
    4              0.000002       return v:false
    2              0.000001     endif
    4              0.000002   endfor
                            
    2              0.000001   return a:x

FUNCTION  <SNR>4_DetectShebang()
    Defined: ~/.local/share/nvim/lazy/dart-vim-plugin/ftdetect/dart.vim:7
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000007   if did_filetype() | return | endif
    1              0.000003   if getline(1) ==# '#!/usr/bin/env dart'
                                setlocal filetype=dart
    1              0.000000   endif

FUNCTION  <SNR>113_getcmdline()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:634
Called 15 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
   15              0.000025   if s:opts.use_cmdlinechanged || !s:opts.before_cursor
   15              0.000015     return getcmdline()
                              endif
                            
                              if a:0
                                let l:cmdline = a:1
                                let l:cmdpos = a:2
                              else
                                let l:cmdline = getcmdline()
                                let l:cmdpos = getcmdpos()
                              endif
                            
                              if l:cmdpos <= 1
                                return ''
                              else
                                return l:cmdline[: l:cmdpos - 2]
                              endif

FUNCTION  <SNR>107_NvimRequest()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:443
Called 18 times
Total time:   0.006701
 Self time:   0.000813

count  total (s)   self (s)
   18              0.000105   let params = deepcopy(a:params)
   18   0.005145   0.000216   let [bufnr, progress] = s:PreprocessParams(self, params)
   18   0.001028   0.000258   let request = call('s:SetUpRequest', [self, v:null, a:method, params, progress] + a:000)
   18   0.000388   0.000199   call self.AfterInitialized(function('s:NvimDoRequest', [self, request, bufnr]))
   18              0.000015   return request

FUNCTION  wilder#renderer#redraw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:1
Called 3 times
Total time:   0.012112
 Self time:   0.000015

count  total (s)   self (s)
    3   0.012111   0.000015   call s:redraw(a:apply_incsearch_fix, 0)

FUNCTION  <SNR>113_do()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:248
Called 15 times
Total time:   0.003075
 Self time:   0.000849

count  total (s)   self (s)
   15              0.000023   if !s:active || !s:enabled
                                return
   15              0.000006   endif
                            
   15   0.000146   0.000100   if a:check && !wilder#main#in_mode()
                                call wilder#main#stop()
                                return
   15              0.000004   endif
                            
   15   0.000271   0.000224   let l:input = s:getcmdline()
                            
   15              0.000023   let l:has_completion = l:input ==# s:completion
   15              0.000023   let l:is_new_input = s:previous_cmdline is v:null
   15              0.000030   let l:input_changed = s:previous_cmdline isnot v:null && s:previous_cmdline !=# l:input
   15              0.000064   let l:should_keep_completion = s:completion_from_reject_completion isnot v:null && s:completion_from_reject_completion ==# l:input
                            
   15              0.000017   if !l:has_completion && !l:should_keep_completion
   15              0.000014     let s:completion = v:null
   15              0.000020     let s:replaced_cmdline = v:null
   15              0.000015     let s:completion_stack = []
   15              0.000005   endif
                            
   15              0.000010   if !l:should_keep_completion
   15              0.000017     let s:completion_from_reject_completion = v:null
   15              0.000004   endif
                            
   15              0.000017   if s:previous_cmdline is v:null || l:input_changed
    2              0.000002     let s:previous_cmdline = l:input
   15              0.000004   endif
                            
   15              0.000012   let s:draw_done = 0
                            
   15              0.000020   if !l:has_completion && (l:input_changed || l:is_new_input)
    2   0.000994   0.000020     call s:run_pipeline(l:input)
                            
    2              0.000002     if !s:draw_done
    2   0.001176   0.000016       call s:draw()
    2              0.000001     endif
   15              0.000004   endif
                            
   15              0.000014   let s:force = 0

FUNCTION  wilder#main#stop()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:172
Called 17 times
Total time:   0.000892
 Self time:   0.000167

count  total (s)   self (s)
   17              0.000029   let s:select_next = 0
                            
   17              0.000010   if !s:active
   16              0.000006     return
    1              0.000001   endif
                            
    1              0.000004   if exists('#WilderCmdlineChanged')
    1              0.000002     augroup WilderCmdlineChanged
    1              0.000018       autocmd!
    1              0.000000     augroup END
    1              0.000006     augroup! WilderCmdlineChanged
    1              0.000000   endif
                            
    1              0.000003   if s:timer isnot v:null
                                call timer_stop(s:timer)
                                let s:timer = v:null
    1              0.000000   endif
                            
    1              0.000002   if exists('#WilderCmdlineLeave')
    1              0.000001     augroup WilderCmdlineLeave
    1              0.000006       autocmd!
    1              0.000000     augroup END
    1              0.000004     augroup! WilderCmdlineLeave
    1              0.000000   endif
                            
    1              0.000001   if exists('#WilderVimResized')
    1              0.000001     augroup WilderVimResized
    1              0.000007       autocmd!
    1              0.000000     augroup END
    1              0.000004     augroup! WilderVimResized
    1              0.000000   endif
                            
    1              0.000001   let s:active = 0
    1              0.000005   let s:result = {'value': [], 'data': {}}
    1              0.000001   let s:selected = -1
    1              0.000001   let s:selection_was_made = 0
    1              0.000002   let s:clear_previous_renderer_state = 0
    1              0.000002   let s:completion_stack = []
    1              0.000002   let s:previous_cmdline = v:null
    1              0.000001   let s:completion = v:null
    1              0.000001   let s:error = v:null
    1              0.000001   let s:replaced_cmdline = v:null
    1              0.000002   let s:completion_from_reject_completion = v:null
                            
    1              0.000001   if !s:hidden
    1   0.000738   0.000013     call s:post_hook()
    1              0.000000   endif
                            
    1              0.000001   let s:hidden = 0

FUNCTION  <SNR>118_call()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:95
Called 8 times
Total time:   0.007569
 Self time:   0.000143

count  total (s)   self (s)
    8              0.000016   let a:ctx.handler_id = a:handler_id
                            
    8              0.000004   try
    8   0.007524   0.000098     call a:f(a:ctx)
                              catch
                                call wilder#reject(a:ctx, 'pipeline: ' . v:exception)
    8              0.000003   endtry

FUNCTION  <SNR>16_match()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:185
Called 10 times
Total time:   0.000197
 Self time:   0.000109

count  total (s)   self (s)
   10              0.000008   if a:pattern[0] == '='
                                return s:is(a:dir, a:pattern[1:])
   10              0.000006   elseif a:pattern[0] == '^'
                                return s:sub(a:dir, a:pattern[1:])
   10              0.000006   elseif a:pattern[0] == '>'
                                return s:child(a:dir, a:pattern[1:])
   10              0.000002   else
   10   0.000143   0.000055     return s:has(a:dir, a:pattern)
                              endif

FUNCTION  <SNR>16_root()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:137
Called 3 times
Total time:   0.000519
 Self time:   0.000195

count  total (s)   self (s)
    3   0.000141   0.000016   let dir = s:current()
                            
    3              0.000010   let patterns = g:rooter_ignore      ? s:remove_ignored(g:rooter_patterns, dir, s:current_file())      : g:rooter_patterns
                            
                              " breadth-first search
    5              0.000003   while 1
   12              0.000009     for pattern in patterns
   10              0.000008       if pattern[0] == '!'
                                    let [p, exclude] = [pattern[1:], 1]
   10              0.000003       else
   10              0.000012         let [p, exclude] = [pattern, 0]
   10              0.000002       endif
   10   0.000253   0.000056       if s:match(dir, p)
    3              0.000002         if exclude
                                      break
    3              0.000001         else
    3              0.000002           return dir
                                    endif
    7              0.000001       endif
    9              0.000018     endfor
                            
    2   0.000012   0.000010     let [current, dir] = [dir, s:parent(dir)]
    3              0.000003     if current == dir | break | endif
    2              0.000001   endwhile
                            
                              return ''

FUNCTION  <SNR>45_has_key()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cache.vim:19
Called 2 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    2              0.000005   return has_key(self['_cache'], a:key)

FUNCTION  <SNR>118_wait_call()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:186
Called 2 times
Total time:   0.000104
 Self time:   0.000038

count  total (s)   self (s)
    2              0.000001   try
    2              0.000003     if type(a:state.f) is v:t_func
                                  let l:ctx = copy(a:ctx)
                            
                                  let s:id_index += 1
                                  let l:id_index = s:id_index
                                  let s:handler_registry[s:id_index] = a:state.handler
                            
                                  call timer_start(0, {_ -> s:call(a:state.f, l:ctx, l:id_index)})
    2              0.000001     else
    2              0.000002       let a:ctx.handler_id = a:state.wait_handler_id
    2   0.000076   0.000011       call a:state.on_finish(a:ctx, a:state.f)
    2              0.000001     endif
                              catch
                                let a:ctx.handler_id = a:state.wait_handler_id
                                call s:wait_on_error(a:state, a:ctx, v:exception)
    2              0.000001   endtry

FUNCTION  wilder#main#in_mode()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:53
Called 47 times
Total time:   0.000375
 Self time:   0.000375

count  total (s)   self (s)
   47              0.000342   return mode(1) ==# 'c' && index(s:opts.modes, getcmdtype()) >= 0

FUNCTION  copilot#Complete()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:155
Called 18 times
Total time:   0.011861
 Self time:   0.002067

count  total (s)   self (s)
   18              0.000051   if exists('g:_copilot_timer')
                                call timer_stop(remove(g:, '_copilot_timer'))
   18              0.000009   endif
   18              0.000138   let target = [bufnr(''), getbufvar('', 'changedtick'), line('.'), col('.')]
   18              0.000079   if !exists('b:_copilot.target') || b:_copilot.target !=# target
   18              0.000048     if exists('b:_copilot.first')
   14   0.001108   0.000127       call copilot#client#Cancel(b:_copilot.first)
   18              0.000008     endif
   18              0.000035     if exists('b:_copilot.cycling')
                                  call copilot#client#Cancel(b:_copilot.cycling)
   18              0.000008     endif
   18   0.001437   0.000420     let params = { 'textDocument': {'uri': bufnr('')}, 'position': copilot#util#AppendPosition(), 'formattingOptions': {'insertSpaces': &expandtab ? v:true : v:false, 'tabSize': shiftwidth()}, 'context': {'triggerKind': s:inline_automatic}}
   18   0.007711   0.000221     let b:_copilot = { 'target': target, 'params': params, 'first': copilot#Request('textDocument/inlineCompletion', params)}
   18              0.000254     let g:_copilot_last = b:_copilot
   18              0.000009   endif
   18              0.000030   let completion = b:_copilot.first
   18              0.000016   if !a:0
                                return completion.Await()
   18              0.000009   else
   18   0.000370   0.000199     call copilot#client#Result(completion, function(a:1, [b:_copilot]))
   18              0.000018     if a:0 > 1
   18   0.000298   0.000163       call copilot#client#Error(completion, function(a:2, [b:_copilot]))
   18              0.000008     endif
   18              0.000007   endif

FUNCTION  wilder#pipeline#run()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:87
Called 14 times
Total time:   0.009349
 Self time:   0.000098

count  total (s)   self (s)
   14              0.000038   let l:pipeline = type(a:pipeline) isnot v:t_list ? [a:pipeline] : a:pipeline
                            
   14   0.007239   0.000537   return s:run(l:pipeline, a:on_finish, a:on_error, a:ctx, a:x, 0)

FUNCTION  <SNR>107_DispatchMessage()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:302
Called 2 times
Total time:   0.000055
 Self time:   0.000051

count  total (s)   self (s)
    2              0.000002   try
    2   0.000021   0.000017     let response = {'result': call(a:handler, [a:params, a:instance])}
    2              0.000003     if response.result is# 0
    1              0.000001       let response.result = v:null
    2              0.000001     endif
                              catch
                                call copilot#logger#Exception('lsp.request.' . a:method)
                                let response = {'error': {'code': -32000, 'message': v:exception}}
    2              0.000002   endtry
    2              0.000002   if a:id isnot# v:null
                                call s:Send(a:instance, extend({'id': a:id}, response))
    2              0.000000   endif
    2              0.000004   if !has_key(s:notifications, a:method)
                                return response
    2              0.000000   endif

FUNCTION  <SNR>51_render_lines()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:285
Called 3 times
Total time:   0.051443
 Self time:   0.008230

count  total (s)   self (s)
    3              0.000003   if !has_key(a:ctx, 'error')
                                " +1 to account for the cmdline prompt.
    3              0.000005     let l:pos = get(a:result, 'pos', 0) + 1
    3              0.000003     let l:pos -= a:state.left_offset
    3              0.000002     if l:pos < 0
                                  let l:pos = 0
    3              0.000001     endif
                              else
                                let l:cmdline = getcmdline()
                                let l:parsed = wilder#cmdline#parse(l:cmdline)
                                let l:pos = l:parsed.pos
    3              0.000001   endif
                            
    3              0.000003   let l:selected = a:ctx.selected
    3              0.000002   let l:reverse = a:state.reverse
                            
    3              0.000005   let [l:page_start, l:page_end] = a:state.page
                            
    3              0.000003   if a:state.page != [-1, -1]
                                " draw candidates
    3   0.025464   0.000062     let [l:lines, l:width] = s:make_lines(a:state, a:ctx, a:result)
    3              0.000004     let l:lines = l:reverse ? reverse(l:lines) : l:lines
                              else
                                if has_key(a:ctx, 'error')
                                  " draw error
                                  let l:lines = s:make_message(a:state, a:ctx, a:state.error_message, s:empty_result, a:ctx.error, 'error')
                                else
                                  " draw empty message
                                  let l:lines = s:make_message(a:state, a:ctx, a:state.empty_message, a:result, a:result, 'empty_message')
                                endif
                            
                                let l:width = empty(l:lines) ? a:state.get_min_width(a:ctx, a:result) : wilder#render#chunks_displaywidth(l:lines[0])
    3              0.000000   endif
                            
    3              0.000014   let l:ctx = extend({'width': l:width}, a:ctx)
                            
                              " height excluding top and bottom
    3              0.000003   let l:lines_height = len(l:lines)
                            
    3              0.000002   let l:top_lines = []
    3              0.000002   let l:top_height = 0
   12              0.000008   for l:Top in a:state.top
    9   0.003329   0.000065     let l:line = s:draw_top_or_bottom_line(l:Top, l:ctx, a:result)
                            
    9              0.000006     if empty(l:line)
                                  continue
    9              0.000002     endif
                            
    9              0.000010     call add(l:top_lines, l:line)
    9              0.000007     let l:top_height += 1
   12              0.000003   endfor
    3              0.000007   let l:lines = l:top_lines + l:lines
                            
    3              0.000002   let l:bottom_height = 0
    6              0.000006   for l:Bottom in a:state.bottom
    3   0.000759   0.000021     let l:line = s:draw_top_or_bottom_line(l:Bottom, l:ctx, a:result)
                            
    3              0.000002     if empty(l:line)
                                  continue
    3              0.000001     endif
                            
    3              0.000003     call add(l:lines, l:line)
    3              0.000002     let l:bottom_height += 1
    6              0.000002   endfor
                            
    3              0.000002   if empty(l:lines)
                                call a:state.api.hide()
                                return
    3              0.000000   endif
                            
    3   0.000317   0.000012   call a:state.api.show()
                            
    3              0.000003   let l:height = len(l:lines)
    3   0.000037   0.000011   let l:max_height = a:state.get_max_height(a:ctx, a:result)
    3              0.000002   if l:max_height > &lines
                                let l:max_height = &lines
    3              0.000000   endif
    3   0.000228   0.000060   let [l:row, l:col] = a:state.position(a:ctx, l:pos, {'height': l:height, 'width': l:width, 'max_height': l:max_height})
                            
    3   0.000043   0.000013   call a:state.api.move(l:row, l:col, l:height, l:width)
    3   0.000088   0.000014   call a:state.api.set_option('wrap', v:false)
    3   0.000058   0.000017   call a:state.api.clear_all_highlights()
    3   0.000166   0.000015   call a:state.api.delete_all_lines()
                            
    3              0.000005   let l:default_hl = a:state.highlights['default']
    3              0.000003   let l:selected_hl = a:state.highlights['selected']
                            
    3              0.000001   let l:i = 0
  100              0.000057   while l:i < len(l:lines)
   97              0.000054     let l:chunks = l:lines[l:i]
                            
   97              0.000037     let l:text = ''
  739              0.000206     for l:chunk in l:chunks
  642              0.000422       let l:text .= l:chunk[0]
  739              0.000128     endfor
                            
   97   0.001062   0.000379     call a:state.api.set_line(l:i, l:text)
                            
                                " Don't apply selected for top lines or error or empty message.
   97              0.000137     if l:page_start == -1 || (!l:reverse && l:i < l:top_height) || (l:reverse && l:i >= l:top_height + l:lines_height)
    9              0.000005       let l:is_selected = 0
   88              0.000015     else
   88              0.000147       let l:is_selected = l:reverse ?  l:page_start + (l:height - l:i - l:bottom_height - 1) == l:selected : l:page_start + l:i - l:top_height == l:selected
   97              0.000015     endif
                            
   97              0.000035     let l:start = 0
  739              0.000212     for l:chunk in l:chunks
  642              0.000509       let l:end = l:start + len(l:chunk[0])
                            
  642              0.000196       if l:is_selected
                                    if len(l:chunk) == 1
                                      let l:hl = l:selected_hl
                                    elseif len(l:chunk) == 2
                                      let l:hl = l:chunk[1]
                                    else
                                      let l:hl = l:chunk[2]
                                    endif
  642              0.000094       else
  642              0.000503         let l:hl = get(l:chunk, 1, l:default_hl)
  642              0.000089       endif
                            
  642              0.000294       if l:hl !=# l:default_hl
   87   0.000623   0.000424         call a:state.api.add_highlight(l:hl, l:i, l:start, l:end)
  642              0.000094       endif
                            
  642              0.000249       let l:start = l:end
  739              0.000545     endfor
                            
   97              0.000038     let l:i += 1
  100              0.000022   endwhile
                            
    3   0.000032   0.000013   call a:state.api.set_firstline(1)
    3   0.012141   0.000029   call wilder#renderer#redraw(a:state.apply_incsearch_fix)

FUNCTION  wilder#renderer#call_component_post_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:81
Called 12 times
Total time:   0.000156
 Self time:   0.000087

count  total (s)   self (s)
   12              0.000040   if type(a:component) is v:t_dict && has_key(a:component, 'post_hook')
    1   0.000089   0.000019     call a:component['post_hook'](a:ctx)
   12              0.000006   endif

FUNCTION  <SNR>106_log()
    Defined: ~/.local/share/nvim/lazy/undotree/autoload/undotree.vim:204
Called 2 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    2              0.000001     if s:debug
                                    exec 'redir >> ' . s:debugfile
                                    silent echon strftime('%H:%M:%S') . ': ' . string(a:msg) . "\n"
                                    redir END
    2              0.000001     endif

FUNCTION  copilot#util#Defer()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/util.vim:7
Called 43 times
Total time:   0.000408
 Self time:   0.000408

count  total (s)   self (s)
   43              0.000177   call add(s:deferred, function(a:fn, a:000))
   43              0.000205   return timer_start(0, function('s:RunDeferred'))

FUNCTION  copilot#Schedule()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:408
Called 21 times
Total time:   0.006158
 Self time:   0.000950

count  total (s)   self (s)
   21   0.001892   0.000366   if !s:has_ghost_text || !s:Running() || !copilot#Enabled()
                                call copilot#Clear()
                                return
   21              0.000007   endif
   21   0.003886   0.000204   call s:UpdatePreview()
   21              0.000047   let delay = get(g:, 'copilot_idle_delay', 45)
   21              0.000069   call timer_stop(get(g:, '_copilot_timer', -1))
   21              0.000174   let g:_copilot_timer = timer_start(delay, function('s:Trigger', [bufnr('')]))

FUNCTION  copilot#Request()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:75
Called 18 times
Total time:   0.007490
 Self time:   0.000399

count  total (s)   self (s)
   18   0.000492   0.000101   let client = copilot#Client()
   18   0.006987   0.000286   return call(client.Request, [a:method, a:params] + a:000)

FUNCTION  copilot#client#LspResponse()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:424
Called 18 times
Total time:   0.002185
 Self time:   0.000423

count  total (s)   self (s)
   18              0.000151   if !has_key(s:instances, a:id)
                                return
   18              0.000014   endif
   18   0.001982   0.000220   call s:OnResponse(s:instances[a:id], a:opts)

FUNCTION  <SNR>121_size()
    Defined: ~/.local/share/nvim/lazy/wildfire.vim/autoload/wildfire.vim:232
Called 3 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    3              0.000004     if a:selection.startline == a:selection.endline
                                    return a:selection.endcol - a:selection.startcol + 1
    3              0.000001     endif
    3              0.000011     let size = len(getline(a:selection.startline)) - a:selection.startcol + a:selection.endcol + 1
    3              0.000010     let size += winwidth(0) * (a:selection.endline - a:selection.startline - 1)
    3              0.000002     return size

FUNCTION  <SNR>51_pre_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:682
Called 1 time
Total time:   0.002210
 Self time:   0.000549

count  total (s)   self (s)
    1   0.000709   0.000029   call a:state.api.new({ 'normal_highlight': a:state.highlights.default, 'zindex': get(a:state, 'zindex', 0), 'pumblend': get(a:state, 'pumblend', -1) })
                            
   13              0.000027   for l:Component in [a:state.empty_message, a:state.error_message] + a:state.left + a:state.right + a:state.top + a:state.bottom
   12   0.001405   0.000424     call wilder#renderer#call_component_pre_hook(a:ctx, l:Component)
   13              0.000062   endfor
                            
    1              0.000001   let a:state.active = 1
    1              0.000001   let a:state.is_first_draw = 1

FUNCTION  wilder#highlight#get_hl_nvim()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:237
Called 2 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    2              0.000002   try
    2              0.000011     let l:cterm_hl = nvim_get_hl_by_name(a:group, 0)
    2              0.000005     let l:gui_hl = nvim_get_hl_by_name(a:group, 1)
                            
    2              0.000004     return [{}, l:cterm_hl, l:gui_hl]
                              catch
                                return [{}, {}, {}]
    2              0.000002   endtry

FUNCTION  <SNR>16_current()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:248
Called 3 times
Total time:   0.000124
 Self time:   0.000048

count  total (s)   self (s)
    3   0.000092   0.000016   let fn = s:current_file()
    3              0.000029   if empty(fn) | return getcwd() | endif  " opening vim without a file
    1              0.000001   return fnamemodify(fn, ':h')

FUNCTION  copilot#client#Cancel()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:722
Called 22 times
Total time:   0.001402
 Self time:   0.000380

count  total (s)   self (s)
   22              0.000148   if type(a:request) == type({}) && has_key(a:request, 'Cancel')
   18   0.001223   0.000201     call a:request.Cancel()
   22              0.000011   endif

FUNCTION  <SNR>107_OnMessage()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:320
Called 2 times
Total time:   0.000107
 Self time:   0.000053

count  total (s)   self (s)
    2              0.000007   if !has_key(a:body, 'method')
                                return s:OnResponse(a:instance, a:body)
    2              0.000001   endif
    2              0.000005   let request = a:body
    2              0.000005   let id = get(request, 'id', v:null)
    2              0.000003   let params = get(request, 'params', v:null)
    2              0.000005   if has_key(a:instance.methods, request.method)
    2   0.000072   0.000017     return s:DispatchMessage(a:instance, request.method, a:instance.methods[request.method], id, params)
                              elseif id isnot# v:null
                                call s:Send(a:instance, {"id": id, "error": {"code": -32700, "message": "Method not found: " . request.method}})
                                call copilot#logger#Debug('Unexpected request ' . request.method . ' called with ' . json_encode(params))
                              elseif request.method !~# '^\$/'
                                call copilot#logger#Debug('Unexpected notification ' . request.method . ' called with ' . json_encode(params))
                              endif

FUNCTION  <SNR>104_Attach()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:419
Called 3 times
Total time:   0.007202
 Self time:   0.000033

count  total (s)   self (s)
    3              0.000002   try
    3   0.007192   0.000023     return copilot#Client().Attach(a:bufnr)
                              catch
                                call copilot#logger#Exception()
    3              0.000002   endtry

FUNCTION  <SNR>113_draw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:429
Called 6 times
Total time:   0.002994
 Self time:   0.000845

count  total (s)   self (s)
    6              0.000004   if s:hidden
                                return
    6              0.000001   endif
                            
    6              0.000002   try
    6              0.000009       let l:direction = a:0 >= 1 ? a:1 : 0
                            
    6              0.000015       if s:selected == -1 && !s:opts.noselect && !s:selection_was_made && !empty(s:result.value)
                                    let l:selected = 0
    6              0.000003       else
    6              0.000005         let l:selected = s:selected
    6              0.000002       endif
                            
    6              0.000034       let l:ctx = { 'clear_previous': get(s:, 'clear_previous_renderer_state', 0), 'selected': l:selected, 'direction': l:direction, 'run_id': s:result_run_id, 'done': s:run_id == s:result_run_id, 'session_id': s:result_session_id, }
    6              0.000006       let s:clear_previous_renderer_state = 0
                            
    6              0.000007       let l:has_error = s:error isnot v:null
                            
    6              0.000003       if l:has_error
                                    let l:ctx.error = s:error
                                    let l:value = {'value': []}
    6              0.000002       else
    6              0.000006         let l:value = s:result
    6              0.000001       endif
                            
    6   0.002826   0.000677       call s:opts.renderer.render(l:ctx, l:value)
                              catch
                                echohl ErrorMsg
                                echomsg 'wilder: draw: ' . v:exception
                                echohl Normal
    6              0.000005   finally
    6              0.000005     let s:draw_done = 1
    6              0.000003   endtry

FUNCTION  <SNR>104_HandleTriggerResult()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:370
Called 6 times
Total time:   0.001168
 Self time:   0.000108

count  total (s)   self (s)
    6              0.000037   let a:state.suggestions = type(a:result) == type([]) ? a:result : get(empty(a:result) ? {} : a:result, 'items', [])
    6              0.000006   let a:state.choice = 0
    6              0.000014   if get(b:, '_copilot') is# a:state
    6   0.001102   0.000042     call s:UpdatePreview()
    6              0.000002   endif

FUNCTION  <SNR>54_new_buf()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:59
Called 2 times
Total time:   0.000643
 Self time:   0.000333

count  total (s)   self (s)
    2              0.000094   let l:buf = nvim_create_buf(v:false, v:true)
    2   0.000535   0.000224   call nvim_buf_set_name(l:buf, '[Wilder Float ' . s:index . ']')
    2              0.000011   let s:index += 1
                            
    2              0.000002   return l:buf

FUNCTION  wilder#render#to_printable()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/render.vim:98
Called 85 times
Total time:   0.000358
 Self time:   0.000358

count  total (s)   self (s)
   85              0.000041   if !s:has_strtrans_issue
                                " check if first character is a combining character
   85              0.000123     if strdisplaywidth(' ' . a:x) == strdisplaywidth(a:x)
                                  return strtrans(' ' . a:x)
   85              0.000016     endif
                            
   85              0.000082     return strtrans(a:x)
                              endif
                            
                              let l:transformed = strtrans(a:x)
                              " strtrans is ok
                              if strdisplaywidth(a:x) == strdisplaywidth(l:transformed)
                                " check if first character is a combining character
                                if strdisplaywidth(' ' . a:x) == strdisplaywidth(a:x)
                                  return strtrans(' ' . a:x)
                                endif
                            
                                return strtrans(a:x)
                              endif
                            
                              let l:res = ''
                              let l:first = 1
                            
                              for l:char in split(a:x, '\zs')
                                let l:transformed_char = strtrans(l:char)
                            
                                let l:transformed_width = strdisplaywidth(l:transformed_char)
                                let l:width = strdisplaywidth(l:char)
                            
                                if l:transformed_width == l:width
                                  " strtrans is ok
                                  let l:res .= l:transformed_char
                                elseif l:transformed_width == 0
                                  " strtrans returns empty character, use original char
                                  if l:first && strdisplaywidth(' ' . l:char) == strdisplaywidth(l:char)
                                    " check if first character is combining character
                                    let l:res .= ' ' . l:char
                                  else
                                    let l:res .= l:char
                                  endif
                                else
                                  " fallback to hex representation
                                  let l:res .= '<' . printf('%02x', char2nr(l:char)) . '>'
                                endif
                            
                                let l:first = 0
                              endfor
                            
                              return l:res

FUNCTION  <SNR>107_NvimDoRequest()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:451
Called 18 times
Total time:   0.005182
 Self time:   0.004770

count  total (s)   self (s)
   18              0.000039   let request = a:request
   18              0.000068   if has_key(a:client, 'client_id') && !has_key(a:client, 'kill')
   18   0.004745   0.004332     let request.id = eval("v:lua.require'_copilot'.lsp_request(a:client.id, a:request.method, a:request.params, a:bufnr)")
   18              0.000021   endif
   18              0.000033   if request.id isnot# v:null
   18              0.000064     let a:client.requests[request.id] = request
                              else
                                if has_key(a:client, 'client_id')
                                  call copilot#client#LspExit(a:client.client_id, -1, -1)
                                endif
                                call copilot#util#Defer(function('s:RejectRequest'), request, s:error_connection_inactive)
   18              0.000007   endif
   18              0.000019   return request

FUNCTION  <SNR>104_Trigger()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:399
Called 18 times
Total time:   0.013574
 Self time:   0.000836

count  total (s)   self (s)
   18              0.000358   let timer = get(g:, '_copilot_timer', -1)
   18              0.000128   if a:bufnr !=# bufnr('') || a:timer isnot# timer || mode() !=# 'i'
                                return
   18              0.000023   endif
   18              0.000049   unlet! g:_copilot_timer
   18   0.012917   0.000179   return copilot#Suggest()

FUNCTION  <SNR>107_RejectRequest()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:49
Called 12 times
Total time:   0.000854
 Self time:   0.000803

count  total (s)   self (s)
   12              0.000019   if a:request.status !=# 'running'
                                return
   12              0.000004   endif
   12              0.000026   let a:request.waiting = {}
   12              0.000039   call remove(a:request, 'resolve')
   12              0.000027   let reject = remove(a:request, 'reject')
   12              0.000016   let a:request.status = 'error'
   12              0.000042   let a:request.error = deepcopy(a:error)
   24              0.000034   for Cb in reject
   12              0.000117     let a:request.waiting[timer_start(0, function('s:Callback', [a:request, 'error', Cb]))] = 1
   24              0.000044   endfor
   12              0.000062   if index([s:error_canceled.code, s:error_connection_inactive.code], a:error.code) != -1
                                return
   12              0.000006   endif
   12              0.000155   let msg = 'Method ' . a:request.method . ' errored with E' . a:error.code . ': ' . json_encode(a:error.message)
   12              0.000018   if empty(reject)
                                call copilot#logger#Error(msg)
   12              0.000005   else
   12   0.000141   0.000090     call copilot#logger#Debug(msg)
   12              0.000005   endif

FUNCTION  <SNR>45_mru_update()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cache.vim:56
Called 2 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    2              0.000003   let l:queue = self['_queue']
    2              0.000003   let l:counts = self['_counts']
                            
    2              0.000005   call add(l:queue, a:key)
    2              0.000004   if !has_key(l:counts, a:key)
    2              0.000003     let l:counts[a:key] = 1
                              else
                                let l:counts[a:key] += 1
    2              0.000001   endif
                            
    2              0.000004   if len(l:queue) > self['_max_size']
                                let l:removed_key = remove(l:queue, 0)
                                let l:counts[l:removed_key] -= 1
                            
                                if l:counts[l:removed_key] == 0
                                  unlet l:counts[l:removed_key]
                                  unlet self['_cache'][l:removed_key]
                                endif
    2              0.000001   endif

FUNCTION  wilder#main#on_finish()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:315
Called 2 times
Total time:   0.001006
 Self time:   0.000071

count  total (s)   self (s)
    2              0.000002   if !s:active || !s:enabled
                                return
    2              0.000000   endif
                            
    2              0.000001   if a:ctx.run_id != s:run_id
                                return
    2              0.000000   endif
                            
    2              0.000002   let s:result_run_id = a:ctx.run_id
    2              0.000002   let s:result_session_id = a:ctx.session_id
                            
    2              0.000003   let l:result = (a:x is v:false || a:x is v:true) ? {'value': []} : a:x
    2              0.000002   if type(l:result) isnot v:t_dict
                                let s:result = {'value': l:result}
    2              0.000000   else
    2              0.000002     let s:result = l:result
    2              0.000000   endif
                            
    2              0.000002   if !has_key(s:result, 'data')
                                let s:result.data = {}
    2              0.000000   endif
                            
    2              0.000002   if !has_key(s:result.data, 'query')
                                let s:result.data.query = a:ctx.input
    2              0.000000   endif
                            
                              " When a new result arrives, the previous results are cleared. If there is a
                              " selection, treat the current cmdline as being replaced.
    2              0.000001   if s:selected >= 0
                                let s:replaced_cmdline = getcmdline()
    2              0.000000   endif
                            
    2              0.000001   let s:selected = -1
    2              0.000002   let s:selection_was_made = 0
    2              0.000002   let s:clear_previous_renderer_state = 1
                              " keep previous completion
                            
    2              0.000001   let s:error = v:null
                            
    2              0.000001   if a:x is v:true
                                if !s:hidden
                                  let s:hidden = 1
                            
                                  call s:post_hook()
                                endif
                            
                                return
    2              0.000000   endif
                            
    2              0.000001   if s:hidden
                                let s:hidden = 0
                            
                                call s:pre_hook()
    2              0.000000   endif
                            
    2              0.000001   if s:select_next
                                call wilder#main#next()
                            
                                let s:select_next = 0
                                return
    2              0.000000   endif
                            
    2              0.000003   if !empty(s:completion_stack) && get(a:ctx, 'auto_select', 0)
                                " removing previous_cmdline causes this to be treated as a new input
                                let s:previous_cmdline = v:null
                            
                                call wilder#main#next()
                                return
    2              0.000000   endif
                            
    2   0.000945   0.000009   call s:draw()

FUNCTION  <SNR>47_prompt_update_cursor()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:423
Called 82 times
Total time:   0.002878
 Self time:   0.001959

count  total (s)   self (s)
   82              0.000919   let l:cmdpos = getcmdpos()
                            
   82              0.000362   if a:state.cmdpos != l:cmdpos
    2   0.000942   0.000024     call wilder#main#draw()
   82              0.000112   endif

FUNCTION  <SNR>107_SetUpRequest()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:129
Called 18 times
Total time:   0.000769
 Self time:   0.000769

count  total (s)   self (s)
   18              0.000325   let request = { 'client_id': a:instance.id, 'id': a:id, 'method': a:method, 'params': a:params, 'Client': function('s:RequestClient'), 'Wait': function('s:RequestWait'), 'Await': function('s:RequestAwait'), 'Cancel': function('s:RequestCancel'), 'resolve': [], 'reject': [], 'progress': a:progress, 'status': 'running'}
   18              0.000038   let args = a:000[2:-1]
   18              0.000027   if len(args)
                                if !empty(a:1)
                                  call add(request.resolve, { v -> call(a:1, [v] + args)})
                                endif
                                if !empty(a:2)
                                  call add(request.reject, { v -> call(a:2, [v] + args)})
                                endif
                                return request
   18              0.000008   endif
   18              0.000024   if a:0 && !empty(a:1)
                                call add(request.resolve, a:1)
   18              0.000006   endif
   18              0.000024   if a:0 > 1 && !empty(a:2)
                                call add(request.reject, a:2)
   18              0.000006   endif
   18              0.000015   return request

FUNCTION  <SNR>117_redraw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:9
Called 3 times
Total time:   0.012096
 Self time:   0.012096

count  total (s)   self (s)
    3              0.000005   if a:apply_incsearch_fix && &incsearch && (getcmdtype() ==# '/' || getcmdtype() ==# '?')
                                call feedkeys("\<C-R>\<BS>", 'n')
                                return
    3              0.000000   endif
                            
    3              0.000002   if a:is_redrawstatus
                                redrawstatus
    3              0.000001   else
    3              0.012076     redraw
    3              0.000003   endif

FUNCTION  <SNR>121_already_selected()
    Defined: ~/.local/share/nvim/lazy/wildfire.vim/autoload/wildfire.vim:222
Called 2 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    3              0.000004     for s in s:history
    1              0.000002         if s.selection == a:selection
                                        return 1
    1              0.000000         end
    3              0.000002     endfor
    2              0.000001     return 0

FUNCTION  wilder#transform#vim_fuzzy_filt()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/transform.vim:99
Called 2 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    2              0.000002   if empty(a:query)
    1              0.000001     return a:candidates
    1              0.000000   endif
                            
    1              0.000001   if exists('*matchfuzzy')
    1              0.000008     return matchfuzzy(a:candidates, a:query)
                              endif
                            
                              return s:vim_fuzzy_filt(a:ctx, a:candidates, a:query)

FUNCTION  copilot#OnInsertEnter()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:449
Called 4 times
Total time:   0.001077
 Self time:   0.000061

count  total (s)   self (s)
    4   0.001076   0.000059   return copilot#Schedule()

FUNCTION  <SNR>104_Focus()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:433
Called 12 times
Total time:   0.002043
 Self time:   0.000628

count  total (s)   self (s)
   12   0.000807   0.000264   if s:Running() && copilot#Client().IsAttached(a:bufnr)
   10   0.001217   0.000346     call copilot#Client().Notify('textDocument/didFocus', {'textDocument': {'uri': copilot#Client().Attach(a:bufnr).uri}})
   12              0.000005   endif

FUNCTION  <SNR>54_show()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:67
Called 3 times
Total time:   0.000305
 Self time:   0.000014

count  total (s)   self (s)
    3              0.000004   if self.state.win != -1 || self.state.window_state !=# 'hidden'
    2              0.000001     return
    1              0.000000   endif
                            
    1              0.000001   let self.state.window_state = 'pending'
                            
    1              0.000000   try
    1   0.000296   0.000005     call self._open_win()
                              catch
                                call timer_start(0, {-> self._open_win()})
    1              0.000000   endtry

FUNCTION  <SNR>54__open_win()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:82
Called 1 time
Total time:   0.000291
 Self time:   0.000078

count  total (s)   self (s)
                              " window might have been open or closed already.
    1              0.000001   if self.state.window_state !=# 'pending'
                                return
    1              0.000000   endif
                            
                              " Fix E5555 when re-showing wilder when inccommand is cancelled.
    1              0.000003   let l:buf = has('nvim-0.6') && !has('nvim-0.7') ? 0 : self.state.buf
                            
    1              0.000002   let l:win_opts = { 'relative': 'editor', 'height': 1, 'width': 1, 'row': &lines - 1, 'col': 0, 'focusable': 0, }
                            
    1              0.000001   if has('nvim-0.5.1')
    1              0.000001     let l:win_opts.zindex = self.state.zindex
    1              0.000000   endif
                            
    1   0.000218   0.000029   let self.state.win = nvim_open_win(l:buf, 0, l:win_opts)
                            
    1              0.000001   let self.state.window_state = 'showing'
                            
    1              0.000002   if has('nvim-0.6') && !has('nvim-0.7')
                                try
                                  call self._set_buf()
                                catch
                                  call timer_start(0, {-> self._set_buf()})
                                endtry
    1              0.000000   else
    1              0.000008     call nvim_win_set_config(self.state.win, { 'style': 'minimal', })
    1              0.000000   endif
                            
    1   0.000020   0.000005   call self.set_option('winhighlight', 'Search:None,IncSearch:None,Normal:' . self.state.normal_highlight)
    1              0.000001   if self.state.pumblend != -1
                                call self.set_option('winblend', self.state.pumblend)
    1              0.000000   else
    1   0.000014   0.000005     call self.set_option('winblend', &pumblend)
    1              0.000000   endif
                            
    1              0.000001   if self.state.firstline isnot -1
                                call nvim_win_set_cursor(self.state.win, [self.state.firstline, 0])
    1              0.000000   endif
                            
    1              0.000000   if self.state.dimensions isnot -1
                                let [l:row, l:col, l:height, l:width] = self.state.dimensions
                                call nvim_win_set_config(self.state.win, { 'relative': 'editor', 'row': l:row, 'col': l:col, 'height': l:height, 'width': l:width, })
    1              0.000000   endif
                            
    1              0.000001   for l:option in keys(self.state.options)
                                let l:value = self.state.options[l:option]
                                call nvim_win_set_option(self.state.win, l:option, l:value)
    1              0.000000   endfor
                            
    1              0.000001   let self.state.firstline = -1
    1              0.000001   let self.state.dimensions = -1
    1              0.000001   let self.state.options = {}

FUNCTION  <SNR>49_wrap_string_or_func_with_border()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:121
Called 3 times
Total time:   0.000753
 Self time:   0.000091

count  total (s)   self (s)
    3              0.000002   let l:width = a:ctx.width
    3              0.000003   let l:width -= strdisplaywidth(a:left)
    3              0.000003   let l:width -= strdisplaywidth(a:right)
    3              0.000001   if l:width < 0
                                let l:width = 0
    3              0.000001   endif
                            
    3              0.000002   if type(a:line) is v:t_func
    3              0.000004     let l:ctx = copy(a:ctx)
    3              0.000002     let l:ctx.width = l:width
    3   0.000700   0.000038     let l:result = a:line(l:ctx, a:result)
                            
    3              0.000002     if empty(l:result)
                                  return l:result
    3              0.000001     endif
                            
    3              0.000002     if type(l:result) is v:t_string
                                  let l:chunks = [[wilder#render#truncate_and_pad(l:width, l:result)]]
    3              0.000001     else
    3              0.000002       let l:chunks = l:result
    3              0.000001     endif
                              else
                                if empty(a:line)
                                  return a:line
                                endif
                            
                                let l:chunks = [[wilder#render#truncate_and_pad(l:width, a:line)]]
    3              0.000000   endif
                            
    3              0.000002   let l:border_hl = a:ctx.highlights.border
    3              0.000006   return [[a:left, l:border_hl]] + l:chunks + [[a:right, l:border_hl]]

FUNCTION  <SNR>55_convert_result_to_data()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:753
Called 2 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    2              0.000006   let l:data = { 'pos': a:res.pos, 'cmdline.command': a:res.cmd, 'cmdline.expand': a:res.expand, 'cmdline.arg': a:res.arg, }
                            
    2              0.000002   if has_key(a:res, 'path_prefix')
                                let l:data['cmdline.path_prefix'] = a:res.path_prefix
    2              0.000001   endif
                            
    2              0.000002   if has_key(a:res, 'match_arg')
    2              0.000003     let l:data['cmdline.match_arg'] = a:res.match_arg
    2              0.000001   endif
                            
    2              0.000002   if has_key(a:res, 'has_wildcard')
                                let l:data['cmdline.has_wildcard'] = a:res.has_wildcard
    2              0.000000   endif
                            
    2              0.000001   return l:data

FUNCTION  UltiSnips#TrackChange()
    Defined: ~/.local/share/nvim/lazy/ultisnips/autoload/UltiSnips.vim:190
Called 51 times
Total time:   0.072979
 Self time:   0.072979

count  total (s)   self (s)
   51              0.072936     py3 UltiSnips_Manager._track_change()

FUNCTION  <SNR>45_clear()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cache.vim:23
Called 4 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    4              0.000004   let self['_cache'] = {}

FUNCTION  <SNR>118_handle()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:27
Called 8 times
Total time:   0.015958
 Self time:   0.000284

count  total (s)   self (s)
    8              0.000014   let l:handler_id = get(a:ctx, 'handler_id', 0)
                            
    8              0.000012   if !has_key(s:handler_registry, l:handler_id)
                                " only show error if handler has not been cleared
                                if l:handler_id > s:last_cleared_id
                                  let l:message = 'wilder#' . a:key . '()'
                                  let l:message .= ' handler not found - id: ' . l:handler_id
                                  let l:message .= ': ' . string(a:x)
                            
                                  call s:echoerr(l:message)
                                endif
                            
                                return
    8              0.000002   endif
                            
    8              0.000004   let l:X = a:x
    8              0.000011   let l:handler = s:handler_registry[l:handler_id]
                            
    8              0.000007   if get(a:ctx, 'partial', 0)
                                if type(l:X) isnot v:t_list
                                  call l:handler.on_error(a:ctx, 'pipeline: ' . s:partial_error_message(a:key, l:X))
                                  return
                                endif
                            
                                if !has_key(s:partial_results, l:handler_id)
                                  let s:partial_results[l:handler_id] = l:X
                                else
                                  let s:partial_results[l:handler_id] += l:X
                                endif
                            
                                return
    8              0.000002   endif
                            
    8              0.000009   unlet s:handler_registry[l:handler_id]
                            
    8              0.000010   if has_key(s:partial_results, l:handler_id)
                                if type(l:X) isnot v:t_list
                                  call l:handler.on_error(a:ctx, 'pipeline: ' . s:partial_error_message(a:key, l:X))
                                  return
                                endif
                            
                                let l:X = s:partial_results[l:handler_id] + l:X
                                unlet s:partial_results[l:handler_id]
    8              0.000002   endif
                            
    8              0.000005   if a:key ==# 'reject'
                                call l:handler.on_error(a:ctx, l:X)
                                return
    8              0.000002   endif
                            
    8              0.000003   try
    8   0.015710   0.000036     call l:handler.on_finish(a:ctx, l:X)
                              catch
                                call l:handler.on_error(a:ctx, 'pipeline: ' . v:exception)
    8              0.000003   endtry

FUNCTION  <SNR>54_new()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:43
Called 1 time
Total time:   0.000680
 Self time:   0.000036

count  total (s)   self (s)
                              " If the buffer is somehow unloaded, bufload(self.state.buf) doesn't restore
                              " it so we have to create a new one
    1              0.000004   if !bufexists(self.state.buf) || !bufloaded(self.state.buf)
    1   0.000470   0.000010     let self.state.buf = s:new_buf()
    1              0.000000   endif
                            
    1              0.000003   if !bufexists(self.state.dummy_buf) || !bufloaded(self.state.dummy_buf)
    1   0.000191   0.000008     let self.state.dummy_buf = s:new_buf()
    1              0.000000   endif
                            
    1              0.000004   let self.state.normal_highlight = get(a:opts, 'normal_highlight', 'Normal')
    1              0.000002   let self.state.pumblend = get(a:opts, 'pumblend', -1)
    1              0.000002   let self.state.zindex = get(a:opts, 'zindex', 0)

FUNCTION  <SNR>51_draw_candidate()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:656
Called 85 times
Total time:   0.004066
 Self time:   0.002109

count  total (s)   self (s)
   85              0.000061   let l:use_cache = a:ctx.selected == a:i
   85              0.000074   if l:use_cache && a:state.draw_cache.has_key(a:i)
                                return a:state.draw_cache.get(a:i)
   85              0.000015   endif
                            
   85   0.003643   0.001686   let l:x = wilder#render#draw_candidate(a:ctx, a:result, a:i)
                            
   85              0.000030   if l:use_cache
                                call a:state.draw_cache.set(a:i, l:x)
   85              0.000015   endif
                            
   85              0.000033   return l:x

FUNCTION  <SNR>121_edges()
    Defined: ~/.local/share/nvim/lazy/wildfire.vim/autoload/wildfire.vim:201
Called 14 times
Total time:   0.023373
 Self time:   0.000377

count  total (s)   self (s)
   14   0.018347   0.000124     cal s:select(a:selection)
   14   0.004956   0.000183     exe "sil! norm! \<ESC>"
   14              0.000063     return [line("'<"), col("'<"), line("'>"), col("'>")]

FUNCTION  wilder#pipeline#clear_handlers()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:6
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000007   let s:last_cleared_id = s:id_index
    1              0.000002   let s:handler_registry = {}
    1              0.000002   let s:partial_results = {}

FUNCTION  <SNR>59_result()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:23
Called 6 times
Total time:   0.000466
 Self time:   0.000329

count  total (s)   self (s)
    6              0.000005   if empty(a:kvs)
                                return a:result
    6              0.000001   endif
                            
    6              0.000004   let l:kvs = a:kvs
                            
   14              0.000012   while !empty(l:kvs)
    8              0.000006     let l:kv = l:kvs[0]
    8              0.000007     let l:kvs = l:kvs[1:]
    8              0.000006     let l:key = l:kv.key
    8              0.000007     let l:Value = l:kv.value
                            
    8              0.000007     if type(l:Value) is v:t_func
    6   0.000175   0.000038       let l:R = l:Value(a:ctx, get(a:result, l:key, v:null), get(a:result, 'data', {}))
                            
    6              0.000005       if type(l:R) is v:t_func
                                    return wilder#wait(l:R, {ctx, value -> wilder#resolve(ctx, s:result(l:kvs, ctx, s:add_key(a:result, l:key, value)))})
    6              0.000002       endif
                            
    6              0.000006       let a:result[l:key] = l:R
    2              0.000002     elseif type(l:Value) is v:t_list
    2              0.000006       let a:result[l:key] = get(a:result, l:key, []) + l:Value
                                elseif type(l:Value) is v:t_dict
                                  let a:result[l:key] = extend(get(a:result, l:key, {}), l:Value)
                                else
                                  let a:result[l:key] = l:Value
    8              0.000004     endif
   14              0.000037   endwhile
                            
    6              0.000003   return a:result

FUNCTION  <SNR>60_branch()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:9
Called 6 times
Total time:   0.007109
 Self time:   0.000159

count  total (s)   self (s)
    6              0.000033   let l:state = { 'index': 0, 'pipelines': a:pipelines, 'original_ctx': copy(a:ctx), 'original_x': copy(a:x), }
                            
    6   0.007068   0.000118   call wilder#pipeline#run( l:state.pipelines[0], {ctx, x -> s:on_finish(l:state, ctx, x)}, {ctx, x -> s:on_error(l:state, ctx, x)}, copy(a:ctx), copy(a:x), )

FUNCTION  <SNR>51_draw_candidates_chunks()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:615
Called 85 times
Total time:   0.004849
 Self time:   0.000782

count  total (s)   self (s)
   85              0.000068   let l:is_selected = a:ctx.selected == a:i
                            
   85   0.004579   0.000513   let l:str = s:draw_candidate(a:state, a:ctx, a:result, a:i)
                            
   85              0.000060   let l:Highlighter = a:state.highlighter
                            
   85              0.000039   if l:Highlighter is 0
   85              0.000042     return [[l:str]]
                              endif
                            
                              if !l:is_selected && a:state.highlight_cache.has_key(l:str)
                                return copy(a:state.highlight_cache.get(l:str))
                              endif
                            
                              let l:data = get(a:result, 'data', {})
                              let l:spans = l:Highlighter(a:ctx, l:str, l:data)
                            
                              if l:spans is 0
                                return [[l:str]]
                              endif
                            
                              if a:state.highlight_mode ==# 'basic'
                                let l:spans = s:merge_spans(l:spans)
                              endif
                            
                              let l:chunks = wilder#render#spans_to_chunks( l:str, l:spans, l:is_selected, a:ctx.highlights)
                            
                              if !l:is_selected
                                call a:state.highlight_cache.set(l:str, l:chunks)
                                let l:chunks = copy(l:chunks)
                              endif
                            
                              return l:chunks

FUNCTION  wilder#cmdline#getcompletion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:345
Called 2 times
Total time:   0.000365
 Self time:   0.000365

count  total (s)   self (s)
    2              0.000002   if has_key(a:res, 'completions')
                                return a:res['completions']
    2              0.000000   endif
                            
    2              0.000002   let l:expand_arg = a:res.expand_arg
                            
                              " getting all shellcmds takes a significant amount of time
    2              0.000002   if a:res.expand ==# 'shellcmd' && empty(l:expand_arg)
                                return []
    2              0.000000   endif
                            
    2              0.000004   if a:res.expand ==# 'dir' || a:res.expand ==# 'file' || a:res.expand ==# 'file_in_path' || a:res.expand ==# 'shellcmd'
                            
                                if get(a:res, 'has_wildcard', 0)
                                  let l:xs = expand(l:expand_arg, 0, 1)
                            
                                  if len(l:xs) == 1 && l:xs[0] ==# l:expand_arg
                                    return []
                                  endif
                            
                                  return l:xs
                                endif
                            
                                return getcompletion(l:expand_arg, a:res.expand, 1)
    2              0.000000   endif
                            
    2              0.000002   if a:res.expand ==# 'nothing' || a:res.expand ==# 'unsuccessful'
                                return []
    2              0.000001   elseif a:res.expand ==# 'augroup'
                                return getcompletion(l:expand_arg, 'augroup')
    2              0.000001   elseif a:res.expand ==# 'arglist'
                                return getcompletion(l:expand_arg, 'arglist')
    2              0.000001   elseif a:res.expand ==# 'behave'
                                return getcompletion(l:expand_arg, 'behave')
    2              0.000001   elseif a:res.expand ==# 'buffer'
                                let l:buffers = getcompletion(l:expand_arg, 'buffer')
                                return map(l:buffers, {_, x -> fnamemodify(x, ':~:.')})
    2              0.000001   elseif a:res.expand ==# 'checkhealth'
                                return has('nvim') ? getcompletion(l:expand_arg, 'checkhealth') : []
    2              0.000001   elseif a:res.expand ==# 'color'
                                return getcompletion(l:expand_arg, 'color')
    2              0.000001   elseif a:res.expand ==# 'command'
    2              0.000310     return getcompletion(l:expand_arg, 'command')
                              elseif a:res.expand ==# 'compiler'
                                return getcompletion(l:expand_arg, 'compiler')
                              elseif a:res.expand ==# 'cscope'
                                return getcompletion(a:res.cmdline[a:res.subcommand_start :], 'cscope')
                              elseif a:res.expand ==# 'event'
                                return getcompletion(l:expand_arg, 'event')
                              elseif a:res.expand ==# 'event_and_augroup'
                                return getcompletion(l:expand_arg, 'event') + getcompletion(l:expand_arg, 'augroup')
                              elseif a:res.expand ==# 'expression'
                                return getcompletion(l:expand_arg, 'expression')
                              elseif a:res.expand ==# 'environment'
                                return getcompletion(l:expand_arg, 'environment')
                              elseif a:res.expand ==# 'file_opt'
                                let l:opts = ['bad', 'bin', 'enc', 'ff', 'nobin']
                                if a:res.cmd ==# 'read'
                                  call insert(l:opts, 'edit', 2)
                                endif
                            
                                return filter(l:opts, {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'function'
                                return getcompletion(l:expand_arg, 'function')
                              elseif a:res.expand ==# 'help'
                                return getcompletion(l:expand_arg, 'help')
                              elseif a:res.expand ==# 'highlight'
                                return getcompletion(l:expand_arg, 'highlight')
                              elseif a:res.expand ==# 'history'
                                return getcompletion(l:expand_arg, 'history')
                              elseif a:res.expand ==# 'language'
                                return getcompletion(l:expand_arg, 'locale') + filter(['ctype', 'messages', 'time'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'locale'
                                return getcompletion(l:expand_arg, 'locale')
                              elseif a:res.expand ==# 'lua'
                                " Lua completion handled by s:get_lua_completion()
                                return []
                              elseif a:res.expand ==# 'mapping'
                                let l:map_args = get(a:res, 'map_args', {})
                            
                                let l:result = []
                            
                                if l:expand_arg ==# '' || l:expand_arg[0] ==# '<'
                                  for l:map_arg in ['<buffer>', '<unique>', '<nowait>', '<silent>', '<special>', '<script>', '<expr>']
                                    if !has_key(l:map_args, l:map_arg)
                                      call add(l:result, l:map_arg)
                                    endif
                                  endfor
                            
                                  if l:expand_arg[0] ==# '<'
                                    call filter(l:result, {_, x -> s:is_prefix(x, l:expand_arg)})
                                  endif
                                endif
                            
                                if a:res.cmd[-5 :] ==# 'unmap'
                                  let l:mode = a:res.cmd ==# 'unmap' ? '' : a:res.cmd[0]
                                  let l:cmd = 'map'
                                elseif a:res.cmd[-3 :] ==# 'map'
                                  let l:mode = a:res.cmd ==# 'map' || a:res.cmd ==# 'noremap' ? '' : a:res.cmd[0]
                                  let l:cmd = 'map'
                                elseif a:res.cmd[-12 :] ==# 'unabbreviate'
                                  let l:mode = a:res.cmd ==# 'unabbreviate' ? '' : a:res.cmd[0]
                                  let l:cmd = 'abbrev'
                                elseif a:res.cmd ==# 'abbreviate'
                                  let l:mode = ''
                                  let l:cmd = 'abbrev'
                                elseif a:res.cmd[-6 :] ==# 'abbrev'
                                  let l:mode = a:res.cmd ==# 'noreabbrev' ? '' : a:res.cmd[0]
                                  let l:cmd = 'abbrev'
                                else
                                  let l:mode = ''
                                  let l:cmd = 'map'
                                endif
                            
                                let l:lines = split(execute(l:mode . l:cmd . ' ' . join(keys(l:map_args), ' ') . ' ' . l:expand_arg), "\n")
                            
                                if len(l:lines) != 1 || (l:lines[0] !=# 'No mapping found' && l:lines[0] !=# 'No abbreviation found')
                                  for l:line in l:lines
                                    let l:words = split(l:line,'\s\+')
                                    if l:line[0] ==# ' '
                                      let l:map_lhs = l:words[0]
                                    else
                                      let l:map_lhs = l:words[1]
                                    endif
                            
                                    call add(l:result, l:map_lhs)
                                  endfor
                                endif
                            
                                return wilder#uniq_filt(0, 0, l:result)
                              elseif a:res.expand ==# 'mapclear'
                                return s:is_prefix('<buffer>', l:expand_arg) ? ['<buffer>'] : []
                              elseif a:res.expand ==# 'menu'
                                if !has_key(a:res, 'menu_arg')
                                  return []
                                endif
                                return getcompletion(a:res.menu_arg, 'menu')
                              elseif a:res.expand ==# 'messages'
                                return getcompletion(l:expand_arg, 'messages')
                              elseif a:res.expand ==# 'option'
                                return getcompletion(l:expand_arg, 'option')
                              elseif a:res.expand ==# 'option_bool'
                                return filter(wilder#cmdline#set#get_bool_options(), {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'option_old'
                                let l:old_option = eval('&' . a:res.option)
                                return [type(l:old_option) is v:t_string ? l:old_option : string(l:old_option)]
                              elseif a:res.expand ==# 'packadd'
                                return getcompletion(l:expand_arg, 'packadd')
                              elseif a:res.expand ==# 'profile'
                                return filter(['continue', 'dump', 'file', 'func', 'pause', 'start'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'ownsyntax'
                                return getcompletion(l:expand_arg, 'syntax')
                              elseif a:res.expand ==# 'shellcmd'
                                return getcompletion(l:expand_arg, 'shellcmd')
                              elseif a:res.expand ==# 'sign'
                                return getcompletion(a:res.cmdline[a:res.subcommand_start :], 'sign')
                              elseif a:res.expand ==# 'syntax'
                                return getcompletion(l:expand_arg, 'syntax')
                              elseif a:res.expand ==# 'syntax_subcommand'
                                return filter(['case', 'clear', 'cluster', 'conceal', 'enable', 'foldlevel', 'include', 'iskeyword', 'keyword', 'list', 'manual', 'match', 'off', 'on', 'region', 'reset', 'spell', 'sync'], {_, x -> s:is_prefix(x, l:expand_arg)})
                                return getcompletion(l:expand_arg, 'syntax')
                              elseif a:res.expand ==# 'syntime'
                                return getcompletion(l:expand_arg, 'syntime')
                              elseif a:res.expand ==# 'user'
                                return getcompletion(l:expand_arg, 'user')
                              elseif a:res.expand ==# 'user_func'
                                let l:functions = getcompletion(l:expand_arg, 'function')
                                let l:functions = filter(l:functions, {_, x -> !(x[0] >= 'a' && x[0] <= 'z')})
                                return map(l:functions, {_, x -> x[-1 :] ==# ')' ? x[: -3] : x[: -2]})
                              elseif a:res.expand ==# 'user_addr_type'
                                return filter(['arguments', 'buffers', 'lines', 'loaded_buffers', 'quickfix', 'tabs', 'windows'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'user_cmd_flags'
                                return filter(['addr', 'bar', 'buffer', 'complete', 'count', 'nargs', 'range', 'register'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'user_complete'
                                return filter(['arglist', 'augroup', 'behave', 'buffer', 'checkhealth', 'color', 'command', 'compiler', 'cscope', 'custom', 'customlist', 'dir', 'environment', 'event', 'expression', 'file', 'file_in_path', 'filetype', 'function', 'help', 'highlight', 'history', 'locale', 'mapclear', 'mapping', 'menu', 'messages', 'option', 'packadd', 'shellcmd', 'sign', 'syntax', 'syntime', 'tag', 'tag_listfiles', 'user', 'var'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'user_nargs'
                                if empty(l:expand_arg)
                                  return ['*', '+', '0', '1', '?']
                                endif
                            
                                if l:expand_arg ==# '*' || l:expand_arg ==# '+' || l:expand_arg ==# '0' || l:expand_arg ==# '1' || l:expand_arg ==# '?'
                                  return [l:expand_arg]
                                endif
                            
                                return []
                              elseif a:res.expand ==# 'user_commands'
                                return filter(getcompletion(l:expand_arg, 'command'), {_, x -> x[0] >=# 'A' && x[0] <=# 'Z'})
                              elseif a:res.expand ==# 'tags'
                                if a:ctx.session_id > s:cached_tags_session_id
                                  let s:cached_tags_session_id = a:ctx.session_id
                                  let s:cached_tags = {}
                                endif
                            
                                let l:arg = a:res.expand_arg
                                if l:arg[0] ==# '/'
                                  let l:taglist_arg = l:arg[1:]
                                else
                                  let l:taglist_arg = l:arg
                                endif
                            
                                if empty(l:taglist_arg)
                                  let l:taglist_arg = '.'
                                endif
                            
                                if !has_key(s:cached_tags, l:taglist_arg)
                                  let s:cached_tags[l:taglist_arg] = map(taglist(l:taglist_arg), {_, x -> x.name})
                                endif
                            
                                return copy(s:cached_tags[l:taglist_arg])
                              elseif a:res.expand ==# 'var'
                                return getcompletion(l:expand_arg, 'var')
                              endif
                            
                              if !exists('s:has_get_completion_cmdline')
                                try
                                  " cmdline completion only available in Vim 8.2+
                                  call getcompletion('foo', 'cmdline')
                                  let s:has_getcompletion_cmdline = 1
                                catch
                                  let s:has_getcompletion_cmdline = 0
                                endtry
                              endif
                            
                              " fallback to cmdline getcompletion
                              if s:has_getcompletion_cmdline
                                return getcompletion(a:res.cmdline, 'cmdline')
                              endif
                            
                              return []

FUNCTION  <SNR>53_make_hl()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:34
Called 2 times
Total time:   0.001744
 Self time:   0.000100

count  total (s)   self (s)
    2   0.000610   0.000024   let l:x = s:to_hl_list(a:x)
                            
    4              0.000004   for l:elem in a:xs
    2   0.000507   0.000018     let l:y = s:to_hl_list(l:elem)
    2   0.000129   0.000022     let l:x = s:combine_hl_list(l:x, l:y)
    4              0.000002   endfor
                            
    2   0.000485   0.000023   call s:make_hl_from_list(a:name, l:x)

FUNCTION  <SNR>107_Cancel()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:285
Called 18 times
Total time:   0.000245
 Self time:   0.000245

count  total (s)   self (s)
   18              0.000094   if has_key(self.requests, get(a:request, 'id', ''))
                                call self.Notify('$/cancelRequest', {'id': a:request.id})
                                call s:RejectRequest(remove(self.requests, a:request.id), s:error_canceled)
   18              0.000010   endif

FUNCTION  <SNR>51_clamp()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:818
Called 19 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
   19              0.000011   if a:value < 1
    8              0.000003     return 1
   11              0.000002   endif
                            
   11              0.000010   let l:max = a:is_height ? (&lines - 1) : &columns
   11              0.000005   if a:value > l:max
                                return l:max
   11              0.000002   endif
                            
   11              0.000004   return a:value

FUNCTION  <SNR>16_cd()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:270
Called 10 times
Total time:   0.001193
 Self time:   0.000687

count  total (s)   self (s)
   10              0.000217   if a:dir == getcwd() | return | endif
    7   0.000895   0.000390   execute g:rooter_cd_cmd fnameescape(a:dir)
    7              0.000026   if !g:rooter_silent_chdir | redraw | echo 'cwd: '.a:dir | endif
    7              0.000028   if exists('#User#RooterChDir')
                                execute 'doautocmd' s:nomodeline 'User RooterChDir'
    7              0.000002   endif

FUNCTION  wilder#lua#wrap()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/lua.vim:9
Called 2597 times
Total time:   0.054470
 Self time:   0.046694

count  total (s)   self (s)
 2597              0.004690   if type(a:t) is v:t_string || type(a:t) is v:t_number || type(a:t) is v:t_bool || a:t is v:null
 2164              0.000866     return a:t
  433              0.000086   endif
                            
  433              0.000283   if type(a:t) is v:t_func
    4   0.000099   0.000052     return s:wrap_function(a:t)
  429              0.000079   endif
                            
  429              0.000275   if type(a:t) is v:t_dict
   94              0.000065     for l:key in keys(a:t)
   80              0.000079       let l:Value = a:t[l:key]
   80              0.000093       let a:t[l:key] = wilder#lua#wrap(l:Value)
   94              0.000029     endfor
  429              0.000081   endif
                            
                              " v:t_list
  429              0.002946   return map(a:t, {_, x -> wilder#lua#wrap(x)})

FUNCTION  wilder#renderer#call_component_pre_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:74
Called 12 times
Total time:   0.000111
 Self time:   0.000054

count  total (s)   self (s)
   12              0.000027   if type(a:component) is v:t_dict && has_key(a:component, 'pre_hook')
    1   0.000066   0.000009     call a:component['pre_hook'](a:ctx)
   12              0.000004   endif

FUNCTION  copilot#Clear()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:94
Called 4 times
Total time:   0.001849
 Self time:   0.000262

count  total (s)   self (s)
    4              0.000031   if exists('g:_copilot_timer')
                                call timer_stop(remove(g:, '_copilot_timer'))
    4              0.000005   endif
    4              0.000015   if exists('b:_copilot')
    4   0.000462   0.000068     call copilot#client#Cancel(get(b:_copilot, 'first', {}))
    4   0.000075   0.000048     call copilot#client#Cancel(get(b:_copilot, 'cycling', {}))
    4              0.000002   endif
    4   0.001216   0.000050   call s:UpdatePreview()
    4              0.000012   unlet! b:_copilot
    4              0.000004   return ''

FUNCTION  wildfire#Start()
    Defined: ~/.local/share/nvim/lazy/wildfire.vim/autoload/wildfire.vim:32
Called 1 time
Total time:   0.009935
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000086   0.000009     cal s:init(a:objects)
    1   0.009849   0.000007     cal wildfire#Fuel(a:repeat)

FUNCTION  <SNR>53_get_attrs_as_list()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:209
Called 12 times
Total time:   0.000779
 Self time:   0.000779

count  total (s)   self (s)
   12              0.000012   let l:res = []
                            
  108              0.000062   for l:attr in s:attr_list
   96              0.000104     if has_key(a:attrs, l:attr)
    9              0.000008       if l:attr ==# 'inverse'
                                    let l:attr = 'reverse'
    9              0.000003       endif
                            
    9              0.000009       if a:attrs[l:attr]
    9              0.000013         call add(l:res, l:attr)
                                  else
                                    call add(l:res, 'no' . l:attr)
    9              0.000003       endif
   96              0.000025     endif
  108              0.000079   endfor
                            
   12              0.000008   return l:res

FUNCTION  <SNR>54_need_timer()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:263
Called 5 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    5              0.000016   if has('nvim-0.7')
                                " See https://github.com/neovim/neovim/issues/17810.
                                " Avoid calling nvim_buf_set_lines(), so assume timer is always needed.
    5              0.000002     return 1
                              endif
                            
                              try
                                call nvim_buf_set_lines(self.state.dummy_buf, 0, -1, v:true, [])
                              catch
                                return 1
                              endtry
                            
                              return 0

FUNCTION  <SNR>53_to_hl_list()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:45
Called 4 times
Total time:   0.001075
 Self time:   0.000237

count  total (s)   self (s)
    4              0.000009   if type(a:x) is v:t_string
    2   0.000079   0.000020     let l:x = wilder#highlight#get_hl(a:x)
    2              0.000001   else
    2              0.000002     let l:x = a:x
    4              0.000001   endif
                            
    4              0.000012   if type(l:x) is v:t_list && type(l:x[0]) is v:t_list
                                return l:x
    4              0.000001   endif
                            
    4   0.000330   0.000056   let l:term_hl = s:get_attrs_as_list(l:x[0])
                            
    4   0.000316   0.000057   let l:cterm_hl = [ get(l:x[1], 'foreground', 'NONE'), get(l:x[1], 'background', 'NONE') ] + s:get_attrs_as_list(l:x[1])
                            
    4   0.000302   0.000056   let l:gui_hl = [ get(l:x[2], 'foreground', 'NONE'), get(l:x[2], 'background', 'NONE') ] + s:get_attrs_as_list(l:x[2])
                            
    4              0.000006   return [l:term_hl, l:cterm_hl, l:gui_hl]

FUNCTION  undotree#UndotreePersistUndo()
    Defined: ~/.local/share/nvim/lazy/undotree/autoload/undotree.vim:1538
Called 1 time
Total time:   0.000044
 Self time:   0.000037

count  total (s)   self (s)
    1   0.000026   0.000021     call s:log("undotree#UndotreePersistUndo(" . a:goSetUndofile . ")")
    1              0.000001     if ! &undofile
                                    if !isdirectory(g:undotree_UndoDir)
                                        call mkdir(g:undotree_UndoDir, 'p', 0700)
                                        call s:log(" > [Dir " . g:undotree_UndoDir . "] created.")
                                    endif
                                    exe "set undodir=" . fnameescape(g:undotree_UndoDir)
                                    call s:log(" > [set undodir=" . g:undotree_UndoDir . "] executed.")
                                    if filereadable(undofile(expand('%'))) || a:goSetUndofile
                                        setlocal undofile
                                        call s:log(" > [setlocal undofile] executed")
                                    endif
                                    if a:goSetUndofile
                                        silent! write
                                        echo "A persistence undo file has been created."
                                    endif
    1              0.000000     else
    1   0.000006   0.000004         call s:log(" > Undofile has been set. Do nothing.")
    1              0.000000     endif

FUNCTION  wilder#cmdline#prepare_getcompletion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:20
Called 2 times
Total time:   0.000062
 Self time:   0.000039

count  total (s)   self (s)
    2              0.000002   let a:res.match_arg = a:res.arg
    2              0.000006   let a:res.expand_arg = has_key(a:res, 'subcommand_start') ? a:res.cmdline[a:res.subcommand_start :] : a:res.arg
                            
    2              0.000001   if !a:fuzzy
                                if a:res.expand ==# 'tags' && !empty(a:res.expand_arg) && a:res.expand_arg[0] !=# '/'
                                  " Search taglist for tags starting with expand_arg
                                  let a:res.expand_arg = '/^' . a:res.expand_arg
                                endif
                            
                                return a:res
    2              0.000000   endif
                            
    2   0.000042   0.000019   return s:prepare_fuzzy_completion(a:ctx, a:res, a:use_python)

FUNCTION  wilder#wait()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:55
Called 2 times
Total time:   0.000031
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000002   if !a:0
                                return wilder#pipeline#wait(a:f)
    2              0.000001   elseif a:0 == 1
    2   0.000024   0.000015     return wilder#pipeline#wait(a:f, a:1)
                              else
                                return wilder#pipeline#wait(a:f, a:1, a:2)
                              endif

FUNCTION  <SNR>53_combine_hl_list()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:71
Called 2 times
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
    2              0.000004   let l:term_hl = copy(a:l[0])
    2              0.000003   let l:cterm_hl = copy(a:l[1])
    2              0.000003   let l:gui_hl = copy(a:l[2])
                            
    2              0.000003   if len(l:term_hl) <= 2
    2              0.000003     let l:term_hl = copy(a:m[0])
                              else
                                let l:term_hl += a:m[0][2:]
    2              0.000001   endif
                            
    2              0.000003   let l:cterm_fg = get(a:m[1], 0, -1)
    2              0.000003   if l:cterm_fg isnot 'NONE' && l:cterm_fg isnot -1
                                if empty(l:cterm_hl)
                                  let l:cterm_hl = [l:cterm_fg]
                                else
                                  let l:cterm_hl[0] = l:cterm_fg
                                endif
    2              0.000001   endif
                            
    2              0.000003   let l:cterm_bg = get(a:m[1], 1, -1)
    2              0.000002   if l:cterm_bg isnot 'NONE' && l:cterm_bg isnot -1
                                if empty(l:cterm_hl)
                                  let l:cterm_hl = ['NONE', l:cterm_bg]
                                else
                                  let l:cterm_hl[1] = l:cterm_bg
                                endif
    2              0.000001   endif
                            
    2              0.000002   if len(a:m[1]) > 2
    2              0.000003     if empty(l:cterm_hl)
                                  let l:cterm_hl = ['NONE', 'NONE'] + a:m[1][2:]
    2              0.000001     else
    2              0.000005       let l:cterm_hl += a:m[1][2:]
    2              0.000001     endif
    2              0.000001   endif
                            
    2              0.000003   let l:gui_fg = get(a:m[2], 0, -1)
    2              0.000002   if l:gui_fg isnot 'NONE' && l:gui_fg isnot -1
                                if empty(l:gui_hl)
                                  let l:gui_hl = [l:gui_fg]
                                else
                                  let l:gui_hl[0] = l:gui_fg
                                endif
    2              0.000001   endif
                            
    2              0.000003   let l:gui_bg = get(a:m[2], 1, -1)
    2              0.000002   if l:gui_bg isnot 'NONE' && l:gui_bg isnot -1
                                if empty(l:gui_hl)
                                  let l:gui_hl = ['NONE', l:gui_bg]
                                else
                                  let l:gui_hl[1] = l:gui_bg
                                endif
    2              0.000001   endif
                            
    2              0.000002   if len(a:m[2]) > 2
    2              0.000002     if empty(l:gui_hl)
                                  let l:gui_hl = ['NONE', 'NONE'] + a:m[2][2:]
    2              0.000001     else
    2              0.000003       let l:gui_hl += a:m[2][2:]
    2              0.000001     endif
    2              0.000001   endif
                            
    2              0.000002   return [l:term_hl, l:cterm_hl, l:gui_hl]

FUNCTION  <SNR>47_get_cmdline_data()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:127
Called 3 times
Total time:   0.000135
 Self time:   0.000135

count  total (s)   self (s)
    3              0.000003   if a:state.cached_cmdline ==# a:cmdline
    2              0.000001     return a:state.cached_cmdline_data
    1              0.000000   endif
                            
    1              0.000009   let l:cmdline_chars = split(a:cmdline, '\zs')
    1              0.000001   let l:cmdline_data = []
                            
    1              0.000001   let l:byte_pos = 0
    1              0.000001   let l:displaywidth_pos = 0
                            
    1              0.000000   let l:i = 0
   15              0.000010   while l:i < len(l:cmdline_chars)
   14              0.000009     let l:char = l:cmdline_chars[l:i]
                            
                                " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
   14              0.000010     let l:byte_len = len(l:char)
   14              0.000012     let l:displaywidth = strdisplaywidth(l:char)
   14              0.000017     let l:data = [l:char, l:byte_len, l:displaywidth, l:byte_pos, l:displaywidth_pos]
   14              0.000011     call add(l:cmdline_data, l:data)
                            
   14              0.000009     let l:byte_pos += l:byte_len
   14              0.000010     let l:displaywidth_pos += l:displaywidth
                            
   14              0.000006     let l:i += 1
   15              0.000004   endwhile
                            
    1              0.000001   let a:state.cached_cmdline = a:cmdline
    1              0.000001   let a:state.cached_cmdline_data = l:cmdline_data
                            
    1              0.000001   return a:state.cached_cmdline_data

FUNCTION  <SNR>55_getcompletion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:777
Called 2 times
Total time:   0.000568
 Self time:   0.000100

count  total (s)   self (s)
                              " For python file completions, use wilder#cmdline#python_get_file_completion()
                              " For help tags, use _wilder_python_get_help_tags()
                              " Else use wilder#cmdline#getcompletion()
    2              0.000003   if a:use_python && wilder#cmdline#is_file_expansion(a:res.expand)
                                let l:Completion_func = funcref('wilder#cmdline#python_get_file_completion')
    2              0.000002   elseif a:use_python && a:res.expand ==# 'help' && a:fuzzy
                                let l:Completion_func = {-> {ctx -> _wilder_python_get_help_tags(ctx, &rtp, &helplang)}}
    2              0.000001   else
    2              0.000008     let l:Completion_func = funcref('wilder#cmdline#getcompletion')
    2              0.000000   endif
                            
                              " For tag-regexp, don't do fuzzy completion
                              " If fuzzy, wrap the completion func in wilder#cmdline#get_fuzzy_completion()
    2              0.000002   if a:res.expand ==# 'tags' && a:res.expand_arg[0] ==# '/'
                                let l:Getcompletion = l:Completion_func
    2              0.000001   elseif a:fuzzy
    2              0.000008     let l:Getcompletion = {ctx, x -> wilder#cmdline#get_fuzzy_completion( ctx, x, l:Completion_func, a:fuzzy, a:use_python)}
                              else
                                let l:Getcompletion = l:Completion_func
    2              0.000000   endif
                            
    2   0.000524   0.000056   return wilder#wait(l:Getcompletion(a:ctx, a:res), {ctx, xs -> wilder#resolve(ctx, { 'value': xs, 'pos': a:res.pos, 'data': s:convert_result_to_data(a:res), })})

FUNCTION  <SNR>113_start()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:94
Called 17 times
Total time:   0.006044
 Self time:   0.000534

count  total (s)   self (s)
   17   0.000225   0.000153   if !wilder#main#in_mode() || !s:enabled
   16   0.000138   0.000090     call wilder#main#stop()
   16              0.000004     return
    1              0.000001   endif
                            
    1   0.000057   0.000010   if !s:init && wilder#options#get('use_python_remote_plugin')
    1              0.000003     let s:init = 1
                            
    1              0.000001     try
    1              0.000003       if !has('nvim')
                                    " set up yarp
                                    call wilder#yarp#init()
    1              0.000000       endif
                            
    1              0.000036       call _wilder_init({'num_workers': s:opts.num_workers})
    1              0.000020     catch
    1              0.000003       echohl ErrorMsg
    1              0.000024       echomsg 'wilder: Python initialization failed'
    1              0.000006       echomsg v:exception
    1              0.000001       echohl Normal
    1              0.000004     endtry
    1              0.000000   endif
                            
    1              0.000001   if s:opts.use_cmdlinechanged
    1              0.000005     if !exists('#WilderCmdlineChanged')
    1              0.000003       augroup WilderCmdlineChanged
    1              0.000043         autocmd!
                                    " call from a timer so statusline does not change during mappings
    1              0.000007         autocmd CmdlineChanged * call timer_start(0, {_ -> s:do(1)})
    1              0.000001       augroup END
    1              0.000000     endif
                              elseif s:timer is v:null
                                  let s:timer = timer_start(s:opts.interval, {_ -> s:do(1)}, {'repeat': -1})
    1              0.000000   endif
                            
    1              0.000001   if !exists('#WilderCmdlineLeave')
    1              0.000002     augroup WilderCmdlineLeave
    1              0.000007       autocmd!
    1              0.000002       autocmd CmdlineLeave * call wilder#main#stop()
    1              0.000003       autocmd CmdwinEnter * call wilder#main#stop()
    1              0.000000     augroup END
    1              0.000000   endif
                            
    1              0.000001   if !exists('#WilderVimResized')
    1              0.000013     augroup WilderVimResized
    1              0.000007       autocmd!
    1              0.000002         autocmd VimResized * call timer_start(0, {_ -> s:draw_resized()})
    1              0.000000     augroup END
    1              0.000000   endif
                            
    1              0.000002   let s:active = 1
    1              0.000001   let s:hidden = 0
                            
    1              0.000002   if !has_key(s:opts, 'renderer')
                                let s:opts.renderer = wilder#wildmenu_renderer()
    1              0.000000   endif
                            
    1              0.000001   if !has_key(s:opts, 'pipeline')
                                let s:opts.pipeline = [ wilder#branch(   wilder#cmdline_pipeline(),   has('nvim') && has('python3')     ? wilder#python_search_pipeline()     : wilder#vim_search_pipeline(), ), ]
    1              0.000000   endif
                            
    1              0.000002   let s:session_id += 1
                            
    1   0.004366   0.000012   call s:pre_hook()
                            
    1   0.000998   0.000009   call s:do(0)

FUNCTION  copilot#Enabled()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:147
Called 21 times
Total time:   0.001383
 Self time:   0.000235

count  total (s)   self (s)
   21   0.001368   0.000220   return get(g:, 'copilot_enabled', 1) && empty(s:BufferDisabled())

FUNCTION  <SNR>107_PreprocessParams()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:216
Called 18 times
Total time:   0.004929
 Self time:   0.002092

count  total (s)   self (s)
   18              0.000028   let bufnr = v:null
   36              0.000230   for doc in filter([get(a:params, 'textDocument', {})], 'type(get(v:val, "uri", "")) == v:t_number')
   18              0.000030     let bufnr = doc.uri
   18   0.001281   0.000275     call s:RegisterWorkspaceFolderForBuffer(a:instance, bufnr)
   18   0.002211   0.000381     call extend(doc, a:instance.Attach(bufnr))
   36              0.000040   endfor
   18              0.000027   let progress_tokens = []
   90              0.000110   for key in keys(a:params)
   72              0.000242     if key =~# 'Token$' && type(a:params[key]) == v:t_func
                                  let s:progress_token_id += 1
                                  let a:instance.progress[s:progress_token_id] = a:params[key]
                                  call add(progress_tokens, s:progress_token_id)
                                  let a:params[key] = s:progress_token_id
   72              0.000027     endif
   90              0.000041   endfor
   18              0.000028   return [bufnr, progress_tokens]

FUNCTION  <SNR>104_BufferDisabled()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:121
Called 29 times
Total time:   0.001339
 Self time:   0.001339

count  total (s)   self (s)
   29              0.000388   if &buftype =~# '^\%(help\|prompt\|quickfix\|terminal\)$'
    1              0.000001     return 5
   28              0.000022   endif
   28              0.000055   if exists('b:copilot_disabled')
                                return empty(b:copilot_disabled) ? 0 : 3
   28              0.000009   endif
   28              0.000032   if exists('b:copilot_enabled')
                                return empty(b:copilot_enabled) ? 4 : 0
   28              0.000007   endif
   28              0.000204   let short = empty(&l:filetype) ? '.' : split(&l:filetype, '\.', 1)[0]
   28              0.000042   let config = {}
   28              0.000088   if type(get(g:, 'copilot_filetypes')) == v:t_dict
   28              0.000048     let config = g:copilot_filetypes
   28              0.000010   endif
   28              0.000043   if has_key(config, &l:filetype)
                                return empty(config[&l:filetype])
   28              0.000039   elseif has_key(config, short)
                                return empty(config[short])
   28              0.000025   elseif has_key(config, '*')
                                return empty(config['*'])
   28              0.000010   else
   28              0.000063     return get(s:filetype_defaults, short, 1) == 0 ? 2 : 0
                              endif

FUNCTION  <SNR>53_make_hl_from_list()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:158
Called 2 times
Total time:   0.000462
 Self time:   0.000175

count  total (s)   self (s)
    2   0.000108   0.000020   let l:term_hl = s:normalise_attrs(a:args[0])
    2   0.000127   0.000020   let l:cterm_hl = s:normalise_attrs(a:args[1])
    2   0.000111   0.000019   let l:gui_hl = s:normalise_attrs(a:args[2])
                            
    2              0.000003   let l:cmd = 'hi! ' . a:name . ' '
                            
    2              0.000002   let l:term_attr = l:term_hl[2:]
    2              0.000002   if len(l:term_hl) >= 2
                                let l:cmd .= 'term=' . join(l:term_attr, ',') . ' '
    2              0.000001   endif
                            
    2              0.000003   let l:cterm_attr = l:cterm_hl[2:]
    2              0.000002   if !empty(l:cterm_attr)
    2              0.000007     let l:cmd .= 'cterm=' . join(l:cterm_attr, ',') . ' '
    2              0.000001   endif
                            
    2              0.000002   if len(l:cterm_hl) >= 1
    2              0.000002     if l:cterm_hl[0] >= 0
    2              0.000004       let l:cmd .= 'ctermfg=' . l:cterm_hl[0] . ' '
    2              0.000001     endif
                            
    2              0.000003     if len(l:cterm_hl) >= 2 && l:cterm_hl[1] >= 0
    2              0.000004       let l:cmd .= 'ctermbg=' . l:cterm_hl[1] . ' '
    2              0.000001     endif
    2              0.000001   endif
                            
    2              0.000003   let l:gui_attr = l:gui_hl[2:]
    2              0.000002   if !empty(l:gui_attr)
    2              0.000006     let l:cmd .= 'gui=' . join(l:gui_attr, ',') . ' '
    2              0.000001   endif
                            
    2              0.000002   if len(l:gui_hl) >= 1
    2              0.000004     if type(l:gui_hl[0]) == v:t_number
    1              0.000006       let l:cmd .= 'guifg=' . printf('#%06x', l:gui_hl[0]) . ' '
    1              0.000000     else
    1              0.000002       let l:cmd .= 'guifg=' . l:gui_hl[0] . ' '
    2              0.000001     endif
                            
    2              0.000002     if len(l:gui_hl) >= 2
    2              0.000003       if type(l:gui_hl[1]) == v:t_number
    1              0.000003         let l:cmd .= 'guibg=' . printf('#%06x', l:gui_hl[1]) . ' '
    1              0.000000       else
    1              0.000002         let l:cmd .= 'guibg=' . l:gui_hl[1] . ' '
    2              0.000001       endif
    2              0.000001     endif
    2              0.000000   endif
                            
    2              0.000025   exe l:cmd

FUNCTION  <SNR>60_resolve()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:48
Called 6 times
Total time:   0.000081
 Self time:   0.000063

count  total (s)   self (s)
    6              0.000009   let l:ctx = copy(a:ctx)
    6              0.000007   let l:ctx.handler_id = a:state.original_ctx.handler_id
                            
    6   0.000062   0.000044   call wilder#resolve(l:ctx, a:x)

FUNCTION  wilder#renderer#pre_draw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:52
Called 4 times
Total time:   0.001223
 Self time:   0.000425

count  total (s)   self (s)
    4              0.000004   let l:should_draw = 0
                            
   44              0.000030   for l:Component in a:components
   40   0.001044   0.000246     let l:should_draw += s:pre_draw(l:Component, a:ctx, a:result)
   44              0.000130   endfor
                            
    4              0.000003   return l:should_draw

FUNCTION  <SNR>107_NvimNotify()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:475
Called 10 times
Total time:   0.000204
 Self time:   0.000143

count  total (s)   self (s)
   10   0.000201   0.000140   call self.AfterInitialized(function('s:NvimDoNotify', [self.client_id, a:method, a:params]))

FUNCTION  copilot#NvimNs()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:90
Called 47 times
Total time:   0.000248
 Self time:   0.000248

count  total (s)   self (s)
   47              0.000224   return nvim_create_namespace('github-copilot')

FUNCTION  <SNR>54_set_firstline()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:217
Called 3 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    3              0.000002   if self.state.window_state ==# 'hidden'
                                return
    3              0.000001   endif
                            
    3              0.000002   if self.state.window_state ==# 'pending'
                                let self.state.firstline = a:line
                                return
    3              0.000000   endif
                            
    3              0.000010   call nvim_win_set_cursor(self.state.win, [a:line, 0])

FUNCTION  copilot#OnBufEnter()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:439
Called 12 times
Total time:   0.000357
 Self time:   0.000220

count  total (s)   self (s)
   12              0.000026   let bufnr = bufnr('')
   12   0.000324   0.000187   call copilot#util#Defer(function('s:Focus'), bufnr)

FUNCTION  wilder#options#get()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/options.vim:13
Called 1 time
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    1              0.000001   if !a:0
                                return s:opts
    1              0.000000   endif
                            
    1              0.000007   if a:1 ==# 'use_python_remote_plugin' && !has_key(s:opts, 'use_python_remote_plugin')
                                if !has('python3')
                                  let s:opts.use_python_remote_plugin = 0
                                elseif has('nvim')
                                  let s:opts.use_python_remote_plugin = 1
                                else
                                  let l:file = findfile('autoload/yarp.vim', &rtp)
                                  let s:opts.use_python_remote_plugin = !empty(l:file)
                                endif
    1              0.000000   endif
                            
    1              0.000002   return s:opts[a:1]

FUNCTION  <SNR>107_Callback()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:728
Called 18 times
Total time:   0.004145
 Self time:   0.000319

count  total (s)   self (s)
   18              0.000078   call remove(a:request.waiting, a:timer)
   18              0.000034   if has_key(a:request, a:type)
   18   0.004013   0.000187     call a:callback(a:request[a:type])
   18              0.000006   endif

FUNCTION  <SNR>53_normalise_attrs()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:137
Called 6 times
Total time:   0.000287
 Self time:   0.000287

count  total (s)   self (s)
    6              0.000015   let l:attr_map = copy(s:attr_map)
                            
   15              0.000013   for l:attr in a:hl[2:]
    9              0.000011     if has_key(l:attr_map, l:attr)
    9              0.000010       let l:attr_map[l:attr] = 1
                                elseif l:attr[:1] ==# 'no' && has_key(l:attr_map, l:attr[2:])
                                  let l:attr_map[l:attr[2:]] = 0
    9              0.000002     endif
   15              0.000020   endfor
                            
    6              0.000004   let l:result = []
   48              0.000033   for l:attr in keys(l:attr_map)
   42              0.000034     if l:attr_map[l:attr]
    9              0.000010       call add(l:result, l:attr)
   42              0.000010     endif
   48              0.000026   endfor
                            
    6              0.000008   return a:hl[:1] + l:result

FUNCTION  <SNR>40_wrap_function()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/lua.vim:32
Called 4 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    4              0.000005   let l:index = s:index
    4              0.000004   let s:index += 1
                            
    4              0.000015   let s:functions[l:index] = a:f
    4              0.000018   return { 'index': l:index, 'name': get(a:f, 'name'), '__wilder_wrapped__': s:token, }

FUNCTION  wilder#cmdline#skip_range#do()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/skip_range.vim:3
Called 2 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    2              0.000012   while a:ctx.pos < len(a:ctx.cmdline) && stridx(s:chars, a:ctx.cmdline[a:ctx.pos]) != -1
                                let l:char = a:ctx.cmdline[a:ctx.pos]
                                if l:char ==# '\'
                                  if a:ctx.pos + 1 >= len(a:ctx.cmdline)
                                    return 1
                                  endif
                            
                                  let l:second_char = a:ctx.cmdline[a:ctx.pos + 1]
                            
                                  if l:second_char ==# '?' || l:second_char ==# '/' || l:second_char ==# '&'
                                    let a:ctx.pos += 2
                                  else
                                    return 1
                                  endif
                                elseif l:char ==# "'"
                                  let a:ctx.pos += 1
                                elseif l:char ==# '/' || l:char ==# '?'
                                  let l:delim = l:char
                                  let a:ctx.pos += 1
                            
                                  while a:ctx.pos < len(a:ctx.cmdline) && a:ctx.cmdline[a:ctx.pos] !=# l:delim
                                    if a:ctx.cmdline[a:ctx.pos] ==# '\' && a:ctx.pos + 1 < len (a:ctx.cmdline)
                                      let a:ctx.pos += 1
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  if a:ctx.pos == len(a:ctx.cmdline)
                                    return
                                  endif
                                endif
                            
                                let a:ctx.pos += 1
    2              0.000003   endwhile

FUNCTION  wilder#vim_fuzzy_filt()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:416
Called 2 times
Total time:   0.000037
 Self time:   0.000023

count  total (s)   self (s)
    2   0.000036   0.000022   return call('wilder#transform#vim_fuzzy_filt', a:000)

FUNCTION  <SNR>45_mru_set()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cache.vim:45
Called 2 times
Total time:   0.000072
 Self time:   0.000027

count  total (s)   self (s)
    2              0.000006   let self['_cache'][a:key] = a:value
                            
    2   0.000064   0.000019   call self.mru_update(a:key)

FUNCTION  <SNR>65_Event()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/plugin/copilot.vim:45
Called 60 times
Total time:   0.010273
 Self time:   0.001033

count  total (s)   self (s)
   60              0.000096   try
   60   0.009926   0.000686     call call('copilot#On' . a:type, [])
                              catch
                                call copilot#logger#Exception('autocmd.' . a:type)
   60              0.000044   endtry

FUNCTION  <SNR>118_wait_start()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:175
Called 2 times
Total time:   0.000146
 Self time:   0.000042

count  total (s)   self (s)
    2              0.000003   let a:state.wait_handler_id = a:ctx.handler_id
                            
    2              0.000010   let a:state.handler = { 'on_finish': {ctx, x -> s:wait_on_finish(a:state, ctx, x)}, 'on_error': {ctx, x -> s:wait_on_error(a:state, ctx, x)}, }
                            
    2   0.000131   0.000027   call s:wait_call(a:state, a:ctx)

FUNCTION  <SNR>118_run()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:118
Called 22 times
Total time:   0.024802
 Self time:   0.002081

count  total (s)   self (s)
   22              0.000029   if a:x is v:false || a:x is v:true
                                call a:on_finish(a:ctx, a:x)
                                return
   22              0.000006   endif
                            
   22              0.000022   if type(a:x) is v:t_func
                                let l:ctx = copy(a:ctx)
                                call s:prepare_call(a:x, a:pipeline, a:on_finish, a:on_error, l:ctx, a:i)
                                return
   22              0.000005   endif
                            
   22              0.000015   let l:x = a:x
   22              0.000013   let l:i = a:i
                            
   48              0.000058   while l:i < len(a:pipeline)
   40              0.000054     let l:F = a:pipeline[l:i]
                            
   40              0.000041     if type(l:F) isnot v:t_func
                                  call a:on_error(a:ctx, 'pipeline: expected function but got: ' . string(l:F))
                                  return
   40              0.000010     endif
                            
   40              0.000014     try
   40   0.020056   0.000958       let l:Result = l:F(a:ctx, l:x)
                                catch
                                  call a:on_error(a:ctx, 'pipeline: ' . v:exception)
                                  return
   40              0.000017     endtry
                            
   40              0.000054     if l:Result is v:false || l:Result is v:true
    6              0.000167       call a:on_finish(a:ctx, l:Result)
    6              0.000002       return
   34              0.000009     endif
                            
   34              0.000044     if type(l:Result) is v:t_func
    8              0.000015       let l:ctx = copy(a:ctx)
    8   0.000239   0.000097       call s:prepare_call(l:Result, a:pipeline, a:on_finish, a:on_error, l:ctx, l:i+1)
    8              0.000004       return
   26              0.000006     endif
                            
   26              0.000023     let l:x = l:Result
   26              0.000019     let l:i += 1
   34              0.000071   endwhile
                            
    8   0.001214   0.000040   call a:on_finish(a:ctx, l:x)

FUNCTION  <SNR>118_prepare_call()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:105
Called 8 times
Total time:   0.000142
 Self time:   0.000142

count  total (s)   self (s)
    8              0.000060   let l:handler = { 'on_finish': {ctx, x -> s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)}, 'on_error': {ctx, x -> a:on_error(ctx, x)}, }
                            
    8              0.000009   let s:id_index += 1
    8              0.000009   let l:handler_id = s:id_index
    8              0.000016   let s:handler_registry[s:id_index] = l:handler
                            
    8              0.000037   call timer_start(0, {_ -> s:call(a:f, a:ctx, l:handler_id)})

FUNCTION  <SNR>54_clear_all_highlights()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:255
Called 3 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    3              0.000004   if !bufexists(self.state.buf)
                                return
    3              0.000001   endif
                            
    3              0.000035   call nvim_buf_clear_namespace(self.state.buf, self.state.ns_id, 0, -1)

FUNCTION  wildfire#Fuel()
    Defined: ~/.local/share/nvim/lazy/wildfire.vim/autoload/wildfire.vim:37
Called 2 times
Total time:   0.026054
 Self time:   0.000044

count  total (s)   self (s)
    4              0.000009     for i in range(a:repeat)
    2   0.026040   0.000030         cal s:select_text_object()
    4              0.000002     endfor

FUNCTION  <SNR>104_Running()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:30
Called 104 times
Total time:   0.000487
 Self time:   0.000487

count  total (s)   self (s)
  104              0.000412   return exists('s:client.job') || exists('s:client.client_id')

FUNCTION  <lambda>4()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/component/popupmenu_devicons.vim:20
Called 3 times
Total time:   0.000052
 Self time:   0.000030

count  total (s)   self (s)
                            return s:devicons(l:state, ctx, result)

FUNCTION  <lambda>5()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/component/popupmenu_scrollbar.vim:13
Called 3 times
Total time:   0.000099
 Self time:   0.000021

count  total (s)   self (s)
                            return s:scrollbar(l:state, ctx, result)

FUNCTION  wilder#cmdline#prepare_user_completion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:617
Called 2 times
Total time:   0.000032
 Self time:   0.000026

count  total (s)   self (s)
    2   0.000029   0.000023   if !wilder#cmdline#is_user_command(a:res.cmd)
    2              0.000002     return [0, 0, a:res]
                              endif
                            
                              if !has('nvim')
                                return [1, v:true, a:res]
                              endif
                            
                              if a:ctx.session_id > s:cached_commands_session_id
                                let s:cached_commands_session_id = a:ctx.session_id
                                let s:cached_user_commands = extend(nvim_get_commands({}), nvim_buf_get_commands(0, {}))
                                let s:has_completion_error = {}
                              endif
                            
                              " Calling getcompletion() interferes with wildmenu command completion so
                              " we return v:true early
                              if has_key(s:has_completion_error, a:res.cmd)
                                let l:res = copy(a:res)
                                let l:res.pos = 0
                                return [1, v:true, l:res]
                              endif
                            
                              if has_key(s:cached_user_commands, a:res.cmd)
                                let l:command = a:res.cmd
                              else
                                " Command might be a partial name
                                let l:matches = getcompletion(a:res.cmd, 'command')
                            
                                " 2 or more matches indicates command is ambiguous
                                if len(l:matches) >= 2
                                  throw "Ambiguous use of user-defined command, possible matches: " . string(l:matches)
                                elseif len(l:matches) == 0
                                  return [1, [], a:res, 0]
                                endif
                            
                                let l:command = l:matches[0]
                              endif
                            
                              let l:user_command = s:cached_user_commands[l:command]
                            
                              if has_key(l:user_command, 'complete_arg') && l:user_command.complete_arg isnot v:null
                            
                                " Find last argument by looking for the last whitespace character
                                let l:pos = len(a:res.cmdline)
                                while l:pos >= a:res.pos
                                  if a:res.cmdline[l:pos] ==# ' ' || a:res.cmdline[l:pos] ==# "\t"
                                    break
                                  endif
                            
                                  let l:pos -= 1
                                endwhile
                            
                                let l:arg = a:res.cmdline[l:pos+1 :]
                            
                                try
                                  let l:function_name = l:user_command.complete_arg
                                  if l:function_name[:1] ==# 's:'
                                    let l:function_name = '<SNR>' . l:user_command.script_id . '_' . l:function_name[2:]
                                  elseif l:function_name[:4] ==? '<SID>'
                                    let l:function_name = '<SNR>' . l:user_command.script_id . '_' . l:function_name[5:]
                                  endif
                            
                                  let l:Completion_func = function(l:function_name)
                                  let l:result = l:Completion_func(l:arg, a:res.cmdline, len(a:res.cmdline))
                                catch
                                  " Add both the full command and partial command
                                  let s:has_completion_error[l:command] = 1
                                  let s:has_completion_error[a:res.cmd] = 1
                            
                                  let l:res = copy(a:res)
                                  let l:res.pos = 0
                                  return [1, v:true, l:res]
                                endtry
                            
                                let l:is_custom_list = get(l:user_command, 'complete', '') ==# 'customlist'
                                if !l:is_custom_list
                                  let l:result = split(l:result, '\n')
                                endif
                            
                                let l:res = copy(a:res)
                                let l:res.pos = l:pos
                                let l:res.match_arg = l:arg
                                if !l:is_custom_list
                                  let l:res.arg = l:arg
                                endif
                            
                                return [1, l:result, l:res, !l:is_custom_list]
                              endif
                            
                              if has_key(l:user_command, 'complete') && l:user_command['complete'] isnot v:null && l:user_command['complete'] !=# 'custom' && l:user_command['complete'] !=# 'customlist'
                                let l:res = copy(a:res)
                                let l:res['expand'] = l:user_command['complete']
                            
                                return [0, 0, l:res]
                              endif
                            
                              return [1, v:false, a:res]

FUNCTION  <SNR>107_NvimIsAttached()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:439
Called 12 times
Total time:   0.000322
 Self time:   0.000322

count  total (s)   self (s)
   12              0.000313   return bufloaded(a:bufnr) ? luaeval('vim.lsp.buf_is_attached(_A[1], _A[2])', [a:bufnr, self.id]) : v:false

FUNCTION  copilot#client#Error()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:743
Called 18 times
Total time:   0.000135
 Self time:   0.000135

count  total (s)   self (s)
   18              0.000033   if has_key(a:request, 'reject')
   18              0.000032     call add(a:request.reject, a:callback)
                              elseif has_key(a:request, 'error')
                                let a:request.waiting[timer_start(0, function('s:Callback', [a:request, 'error', a:callback]))] = 1
   18              0.000006   endif

FUNCTION  <SNR>104_UpdatePreview()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:303
Called 43 times
Total time:   0.008327
 Self time:   0.004468

count  total (s)   self (s)
   43              0.000037   try
   43   0.003424   0.000536     let [text, outdent, delete, item] = s:SuggestionTextWithAdjustments()
   43              0.000195     let text = split(text, "\r\n\\=\\|\n", 1)
   43              0.000076     if empty(text[-1])
   43              0.000095       call remove(text, -1)
   43              0.000017     endif
   43              0.000057     if empty(text) || !s:has_ghost_text
   43   0.001469   0.000499       return s:ClearPreview()
                                endif
                                if exists('b:_copilot.cycling_callbacks')
                                  let annot = '(1/…)'
                                elseif exists('b:_copilot.cycling')
                                  let annot = '(' . (b:_copilot.choice + 1) . '/' . len(b:_copilot.suggestions) . ')'
                                else
                                  let annot = ''
                                endif
                                call s:ClearPreview()
                                if s:has_nvim_ghost_text
                                  let data = {'id': 1}
                                  let data.virt_text_pos = 'overlay'
                                  let append = strpart(getline('.'), col('.') - 1 + delete)
                                  let data.virt_text = [[text[0] . append . repeat(' ', delete - len(text[0])), s:hlgroup]]
                                  if len(text) > 1
                                    let data.virt_lines = map(text[1:-1], { _, l -> [[l, s:hlgroup]] })
                                    if !empty(annot)
                                      let data.virt_lines[-1] += [[' '], [annot, s:annot_hlgroup]]
                                    endif
                                  elseif len(annot)
                                    let data.virt_text += [[' '], [annot, s:annot_hlgroup]]
                                  endif
                                  let data.hl_mode = 'combine'
                                  call nvim_buf_set_extmark(0, copilot#NvimNs(), line('.')-1, col('.')-1, data)
                                elseif s:has_vim_ghost_text
                                  let new_suffix = text[0]
                                  let current_suffix = getline('.')[col('.') - 1 :]
                                  let inset = ''
                                  while delete > 0 && !empty(new_suffix)
                                    let last_char = matchstr(new_suffix, '.$')
                                    let new_suffix = matchstr(new_suffix, '^.\{-\}\ze.$')
                                    if last_char ==# matchstr(current_suffix, '.$')
                                      if !empty(inset)
                                        call prop_add(line('.'), col('.') + len(current_suffix), {'type': s:hlgroup, 'text': inset})
                                        let inset = ''
                                      endif
                                      let current_suffix = matchstr(current_suffix, '^.\{-\}\ze.$')
                                      let delete -= 1
                                    else
                                      let inset = last_char . inset
                                    endif
                                  endwhile
                                  if !empty(new_suffix . inset)
                                    call prop_add(line('.'), col('.'), {'type': s:hlgroup, 'text': new_suffix . inset})
                                  endif
                                  for line in text[1:]
                                    call prop_add(line('.'), 0, {'type': s:hlgroup, 'text_align': 'below', 'text': line})
                                  endfor
                                  if !empty(annot)
                                    call prop_add(line('.'), col('$'), {'type': s:annot_hlgroup, 'text': ' ' . annot})
                                  endif
                                endif
                                call copilot#Notify('textDocument/didShowCompletion', {'item': item})
                              catch
                                return copilot#logger#Exception()
   43              0.000032   endtry

FUNCTION  <SNR>121_init()
    Defined: ~/.local/share/nvim/lazy/wildfire.vim/autoload/wildfire.vim:54
Called 1 time
Total time:   0.000077
 Self time:   0.000036

count  total (s)   self (s)
    1              0.000003     let s:origin = getpos(".")
    1              0.000001     let s:history = []
    1              0.000001     let s:counts = {}
    1   0.000051   0.000010     let _objects = s:load_objects(a:objects)
    8              0.000008     for object in get(_objects, &ft, get(_objects, "*", []))
    7              0.000008         let s:counts[object] = 1
    8              0.000002     endfor

FUNCTION  <lambda>110()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1161
Called 2 times
Total time:   0.000081
 Self time:   0.000019

count  total (s)   self (s)
                            return wilder#cmdline#prepare_getcompletion(ctx, res, l:fuzzy, l:use_python)

FUNCTION  <lambda>111()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1161
Called 2 times
Total time:   0.000583
 Self time:   0.000014

count  total (s)   self (s)
                            return s:getcompletion(ctx, res, l:fuzzy, l:use_python)

FUNCTION  <lambda>112()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1161
Called 2 times
Total time:   0.000083
 Self time:   0.000025

count  total (s)   self (s)
                            return l:Filter(     ctx, xs, get(data, 'cmdline.match_arg', ''))

FUNCTION  <lambda>113()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:2
Called 2 times
Total time:   0.000260
 Self time:   0.000017

count  total (s)   self (s)
                            return s:result_start(l:args, ctx, x)

FUNCTION  <lambda>114()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:201
Called 2 times
Total time:   0.000269
 Self time:   0.000009

count  total (s)   self (s)
                            return a:p(ctx, x)

FUNCTION  <lambda>117()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:198
Called 2 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            return x

FUNCTION  <lambda>118()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:2
Called 2 times
Total time:   0.000153
 Self time:   0.000027

count  total (s)   self (s)
                            return s:result_start(l:args, ctx, x)

FUNCTION  <lambda>119()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1177
Called 2 times
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
                            return res.expand ==# 'lua'

FUNCTION  <SNR>54_add_highlight()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:251
Called 87 times
Total time:   0.000199
 Self time:   0.000199

count  total (s)   self (s)
   87              0.000189   call nvim_buf_add_highlight(self.state.buf, self.state.ns_id, a:hl, a:line, a:col_start, a:col_end)

FUNCTION  <lambda>10()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:96
Called 3 times
Total time:   0.000110
 Self time:   0.000023

count  total (s)   self (s)
                            return s:make_top_or_bottom_border(ctx, 1, a:border_chars)

FUNCTION  <lambda>11()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:99
Called 3 times
Total time:   0.000099
 Self time:   0.000021

count  total (s)   self (s)
                            return s:make_top_or_bottom_border(ctx, 0, a:border_chars)

FUNCTION  <lambda>15()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:118
Called 3 times
Total time:   0.000662
 Self time:   0.000016

count  total (s)   self (s)
                            return s:prompt(a:state, ctx, result)

FUNCTION  <lambda>16()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:118
Called 1 time
Total time:   0.000033
 Self time:   0.000011

count  total (s)   self (s)
                            return s:prompt_pre_hook(a:state)

FUNCTION  <lambda>17()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:118
Called 1 time
Total time:   0.000019
 Self time:   0.000014

count  total (s)   self (s)
                            return s:prompt_post_hook(a:state)

FUNCTION  <lambda>18()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:118
Called 4 times
Total time:   0.000044
 Self time:   0.000031

count  total (s)   self (s)
                            return s:prompt_pre_draw(a:state)

FUNCTION  <lambda>19()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:116
Called 3 times
Total time:   0.000783
 Self time:   0.000030

count  total (s)   self (s)
                            return s:wrap_string_or_func_with_border(ctx, result, l:Value, a:left, a:right)

FUNCTION  wilder#pipeline#resolve()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:12
Called 8 times
Total time:   0.016047
 Self time:   0.000089

count  total (s)   self (s)
    8   0.016046   0.000088   call s:handle(a:ctx, a:x, 'resolve')

FUNCTION  wilder#cmdline#is_file_expansion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:600
Called 2 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    2              0.000005   return a:expand ==# 'file' || a:expand ==# 'file_in_path' || a:expand ==# 'dir' || a:expand ==# 'shellcmd' || a:expand ==# 'user'

FUNCTION  <SNR>45_mru_get()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cache.vim:41
Called 2 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    2              0.000003   return self['_cache'][a:key]

FUNCTION  <lambda>120()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/check.vim:1
Called 2 times
Total time:   0.000028
 Self time:   0.000011

count  total (s)   self (s)
                            return s:check(a:args, ctx, x)

FUNCTION  <SNR>54_hide()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:165
Called 1 time
Total time:   0.000096
 Self time:   0.000096

count  total (s)   self (s)
    1              0.000011   if self.state.win == -1 || self.state.window_state ==# 'hidden'
                                return
    1              0.000001   endif
                            
    1              0.000002   if self.state.window_state ==# 'pending'
                                let self.state.win = -1
                                let self.state.window_state = 'hidden'
                                return
    1              0.000000   endif
                            
    1              0.000003   if getcmdwintype() ==# ''
    1              0.000001     try
    1              0.000045       call nvim_win_close(self.state.win, 1)
                                catch
                                  let l:win = self.state.win
                                  call timer_start(0, {-> nvim_win_close(l:win, 1)})
    1              0.000002     endtry
                              else
                                " cannot call nvim_win_close() while cmdline-window is open
                                " make the window as small as possible and hide it with winblend = 100
                                let l:win = self.state.win
                                call self.delete_all_lines()
                                call self.move(&lines, &columns, 1, 1)
                                call self.set_option('winblend', 100)
                                execute 'autocmd CmdWinLeave * ++once call timer_start(0, {-> nvim_win_close(' . l:win . ', 0)})'
    1              0.000000   endif
                            
    1              0.000002   let self.state.win = -1
    1              0.000002   let self.state.window_state = 'hidden'

FUNCTION  <lambda>129()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 2 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
                            return {ctx -> s:branch(a:args, ctx, x)}

FUNCTION  <lambda>20()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:96
Called 3 times
Total time:   0.000112
 Self time:   0.000024

count  total (s)   self (s)
                            return s:make_top_or_bottom_border(ctx, 1, a:border_chars)

FUNCTION  <lambda>21()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:456
Called 3 times
Total time:   0.000039
 Self time:   0.000020

count  total (s)   self (s)
                            return s:get_middle_position(ctx, dimensions, a:is_top)

FUNCTION  <SNR>121_select_best_candidate()
    Defined: ~/.local/share/nvim/lazy/wildfire.vim/autoload/wildfire.vim:161
Called 2 times
Total time:   0.001842
 Self time:   0.000065

count  total (s)   self (s)
    2              0.000002     if len(a:candidates)
                                    " select the closest text object (the one with the smaller size)
                                    " skip same size text-objects
    2              0.000002         let lastsize = 0
    2              0.000002         if len(s:history)
    1   0.000018   0.000007             let lastsize = s:size(get(s:history, -1).selection)
    2              0.000001         endif
    2              0.000001         let m = -1
    4              0.000005         for ss in keys(a:candidates)
    2              0.000003             let s = str2nr(ss)
    2              0.000003             if s > lastsize && (m == -1 || s < m)
    2              0.000001                 let m = s
    2              0.000001             endif
    4              0.000002         endfor
    2              0.000001         if m > -1
    2              0.000002             let selection = a:candidates[m]
    2              0.000006             let s:history = add(s:history, {"selection": selection, "view": winsaveview()})
    2              0.000002             let s:counts[selection.object] += 1
    2   0.001776   0.000010             cal s:select(selection)
                                    else
                                        cal s:select_best_candidate_fallback()
    2              0.000000         endif
                                else
                                    cal s:select_best_candidate_fallback()
    2              0.000000     endif

FUNCTION  <SNR>49_make_top_or_bottom_border()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:155
Called 9 times
Total time:   0.000252
 Self time:   0.000252

count  total (s)   self (s)
    9              0.000013   let l:left = a:is_top ? a:border_chars[0] : a:border_chars[5]
    9              0.000009   let l:middle = a:is_top ? a:border_chars[1] : a:border_chars[6]
    9              0.000008   let l:right = a:is_top ? a:border_chars[2] : a:border_chars[7]
                            
    9              0.000011   let l:left_width = strdisplaywidth(l:left)
    9              0.000009   let l:middle_width = strdisplaywidth(l:middle)
    9              0.000008   let l:right_width = strdisplaywidth(l:right)
                            
    9              0.000011   let l:expected_middle_width = a:ctx.width - l:left_width - l:right_width
    9              0.000010   let l:middle_repeat =  l:expected_middle_width / l:middle_width
    9              0.000005   if l:middle_repeat < 0
                                let l:middle_repeat = 0
    9              0.000002   endif
                            
    9              0.000014   let l:middle_str = repeat(l:middle, l:middle_repeat)
    9              0.000030   let l:actual_middle_width = strdisplaywidth(l:middle_str)
    9              0.000008   if l:actual_middle_width < l:expected_middle_width
                                let l:middle_chars = split(l:middle, '\zs')
                            
                                let l:i = 0
                                for l:char in l:middle_chars
                                  let l:new_middle_width = l:actual_middle_width + strdisplaywidth(l:char)
                            
                                  if l:new_middle_width > l:expected_middle_width
                                    break
                                  endif
                            
                                  let l:middle_str .= l:char
                                  let l:actual_middle_width = l:new_middle_width
                                endfor
                            
                                let l:middle_str .= repeat(' ', l:expected_middle_width - l:actual_middle_width)
    9              0.000002   endif
                            
    9              0.000007   let l:border_hl = a:ctx.highlights.border
    9              0.000011   let l:middle_hl = a:is_top ? l:border_hl : a:ctx.highlights.bottom_border
                            
    9              0.000015   return [[l:left, l:border_hl], [l:middle_str, l:middle_hl], [l:right, l:border_hl]]

FUNCTION  <SNR>51_draw_top_or_bottom_line()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:795
Called 12 times
Total time:   0.004002
 Self time:   0.001297

count  total (s)   self (s)
   12              0.000008   let l:width = a:ctx.width
                            
   12              0.000009   let l:Line = a:line
   12              0.000010   if type(l:Line) is v:t_dict
    3              0.000002     let l:Line = l:Line.value
   12              0.000002   endif
                            
   12              0.000008   if type(l:Line) is v:t_func
   12   0.003898   0.001193     let l:Line = l:Line(a:ctx, a:result)
   12              0.000003   endif
                            
   12              0.000009   if type(l:Line) is v:t_string
                                if empty(l:Line)
                                  return l:Line
                                endif
                            
                                let l:Line = [[wilder#render#truncate_and_pad(a:ctx.width, l:Line)]]
   12              0.000002   endif
                            
   12              0.000004   return l:Line

FUNCTION  <lambda>132()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:198
Called 2 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            return x

FUNCTION  <lambda>135()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:198
Called 2 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            return x

FUNCTION  <lambda>136()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 2 times
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
                            return getcmdtype() ==# ':'

FUNCTION  <lambda>137()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/check.vim:1
Called 2 times
Total time:   0.000049
 Self time:   0.000017

count  total (s)   self (s)
                            return s:check(a:args, ctx, x)

FUNCTION  <lambda>138()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 2 times
Total time:   0.003133
 Self time:   0.000016

count  total (s)   self (s)
                            return wilder#cmdline#parse(x)

FUNCTION  <SNR>16_rooter()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:76
Called 13 times
Total time:   0.003505
 Self time:   0.000393

count  total (s)   self (s)
   13   0.001517   0.000116   if !s:activate() | return | endif
                            
   10              0.000015   let bufnr = a:0 ? a:1 : '%'
                            
   10              0.000028   let root = getbufvar(bufnr, 'rootDir')
   10              0.000009   if empty(root)
    3   0.000536   0.000017     let root = s:root()
    3              0.000007     call setbufvar(bufnr, 'rootDir', root)
   10              0.000003   endif
                            
   10              0.000007   if empty(root)
                                call s:rootless()
                                return
   10              0.000003   endif
                            
   10   0.001324   0.000131   call s:cd(root)

FUNCTION  <SNR>60_on_finish()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:26
Called 12 times
Total time:   0.002267
 Self time:   0.000118

count  total (s)   self (s)
   12              0.000010   if a:x isnot v:false
    6   0.000126   0.000045     call s:resolve(a:state, a:ctx, a:x)
    6              0.000002     return
    6              0.000001   endif
                            
    6              0.000006   let a:state.index += 1
                            
    6              0.000008   if a:state.index >= len(a:state.pipelines)
                                call s:resolve(a:state, a:ctx, v:false)
                                return
    6              0.000001   endif
                            
    6   0.001216   0.000171   call wilder#pipeline#run( a:state.pipelines[a:state.index], {ctx, x -> s:on_finish(a:state, ctx, x)}, {ctx, x -> s:on_error(a:state, ctx, x)}, copy(a:state.original_ctx), copy(a:state.original_x), )

FUNCTION  wilder#main#get_candidate()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:599
Called 85 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
   85              0.000066   return a:result.value[a:index]

FUNCTION  copilot#OnBufUnload()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:465
Called 14 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)

FUNCTION  wilder#cmdline#main#do()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/main.vim:36
Called 3 times
Total time:   0.001584
 Self time:   0.001134

count  total (s)   self (s)
                              " default
    3              0.000009   let a:ctx.expand = 'command'
    3              0.000004   let a:ctx.force = 0
                            
    3              0.000011   if empty(a:ctx.cmdline[a:ctx.pos :])
    1              0.000001     return
    2              0.000001   endif
                            
    2   0.000091   0.000025   if !wilder#cmdline#main#skip_whitespace(a:ctx)
                                return
    2              0.000001   endif
                            
                              " check if comment
    2              0.000002   if a:ctx.cmdline[a:ctx.pos] ==# '"'
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
    2              0.000001   endif
                            
                              " skip range
    2   0.000925   0.000616   call wilder#cmdline#skip_range#do(a:ctx)
                            
    2   0.000071   0.000024   if !wilder#cmdline#main#skip_whitespace(a:ctx)
                                return
    2              0.000001   endif
                            
    2              0.000003   if a:ctx.cmdline[a:ctx.pos] ==# '"'
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
    2              0.000001   endif
                            
                              " check if starts with | or :
                              " treat as a new command
    2              0.000004   if a:ctx.cmdline[a:ctx.pos] ==# '|' || a:ctx.cmdline[a:ctx.pos] ==# ':'
    1              0.000001     let a:ctx.pos += 1
    1              0.000001     let a:ctx.cmd = ''
                            
    1              0.000002     call wilder#cmdline#main#do(a:ctx)
                            
    1              0.000000     return
    1              0.000000   endif
                            
    1              0.000001   let l:is_user_cmd = 0
                            
    1              0.000002   if a:ctx.cmdline[a:ctx.pos] ==# 'k' && a:ctx.cmdline[a:ctx.pos + 1] !=# 'e'
                                let a:ctx.cmd = 'k'
                                let a:ctx.pos += 1
                            
                                return
    1              0.000000   else
    1              0.000001     let l:cmd_start = a:ctx.pos
                            
    1              0.000001     let l:char = a:ctx.cmdline[a:ctx.pos]
                            
    1              0.000002     if l:char >=# 'A' && l:char <=# 'Z'
                                  " user-defined command can contain digits
   14              0.000027       while l:char >=# 'a' && l:char <=# 'z' || l:char >=# 'A' && l:char <=# 'Z' || l:char >=# '0' && l:char <=# '9'
   13              0.000009         let a:ctx.pos += 1
   13              0.000015         let l:char = a:ctx.cmdline[a:ctx.pos]
   14              0.000019       endwhile
                            
    1              0.000003       let a:ctx.cmd = a:ctx.cmdline[l:cmd_start : a:ctx.pos - 1]
    1              0.000001       let l:is_user_cmd = 1
                                else
                                  " non-alphabet command
                                  if stridx('@*!=><&~#', l:char) != -1
                                    let a:ctx.pos += 1
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                  else
                                    " py3, python3, py3file and py3do are the only commands with numbers
                                    " all other commands are alphabet only
                                    if a:ctx.cmdline[a:ctx.pos] ==# 'p' && a:ctx.cmdline[a:ctx.pos + 1] ==# 'y' && a:ctx.cmdline[a:ctx.pos + 2] ==# '3'
                                      let a:ctx.pos += 3
                                      let l:char = a:ctx.cmdline[a:ctx.pos]
                                    endif
                            
                                    " this should check for [a-zA-Z] only, but the Vim implementation
                                    " skips over wildcards. This matters for commands which accept
                                    " non-alphanumeric arugments e.g. 'e*' would be parsed as an 'edit'
                                    " command with a '*' argument otherwise. These commands typically
                                    " don't need a space between the command and argument e.g. 'e++opt'
                                    " is a valid command.
                                    while l:char >=# 'a' && l:char <=# 'z' || l:char >=# 'A' && l:char <=# 'Z' || l:char ==# '*'
                                      let a:ctx.pos += 1
                                      let l:char = a:ctx.cmdline[a:ctx.pos]
                                    endwhile
                                  endif
                            
                                  if a:ctx.pos == l:cmd_start
                                    let a:ctx.expand = 'unsuccessful'
                                    return
                                  endif
                            
                                  " find the command
                                  if a:ctx.pos > l:cmd_start
                                    let l:cmd = a:ctx.cmdline[l:cmd_start : a:ctx.pos - 1]
                                    let l:len = a:ctx.pos - l:cmd_start
                            
                                    let l:char = l:cmd[0]
                                    if l:char < 'a' || l:char > 'z'
                                      let l:char = 'z'
                                    endif
                            
                                    let l:next_char = nr2char(char2nr(l:char) + 1)
                            
                                    let l:i = s:command_char_pos[l:char]
                                    let l:end = get(s:command_char_pos, 'l:next_char', len(s:commands))
                            
                                    while l:i < l:end
                                      let l:command = s:commands[l:i]
                                      if l:cmd ==# l:command[: l:len - 1]
                                        let a:ctx.cmd = l:command
                                        break
                                      endif
                            
                                      let l:i += 1
                                    endwhile
                                  endif
    1              0.000000     endif
    1              0.000000   endif
                            
                              " cursor is touching command and ends in alpha-numeric character
                              " complete the command name
    1              0.000001   if a:ctx.pos == len(a:ctx.cmdline)
    1              0.000002     let l:char = a:ctx.cmdline[a:ctx.pos - 1]
                            
    1              0.000002     if l:char >=# 'a' && l:char <=# 'z' || l:char >=# 'A' && l:char <=# 'Z' || l:char >=# '0' && l:char <=# '9'
    1              0.000001       let a:ctx.pos = l:cmd_start
    1              0.000001       let a:ctx.cmd = ''
                                  " expand commands
    1              0.000001       return
                                endif
                              endif
                            
                              " no matching command found, treat as no arguments
                              if empty(a:ctx.cmd)
                                " 2 or 3-letter substitute command, takes no arguments
                                if a:ctx.cmdline[l:cmd_start] ==# 's' && stridx('cgriI', a:ctx.cmdline[l:cmd_start + 1]) != -1
                                  let a:ctx.cmd = 's'
                                endif
                            
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
                              endif
                            
                              let a:ctx.expand = 'nothing'
                            
                              " handle !
                              if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                let a:ctx.pos += 1
                                let a:ctx.force = 1
                              endif
                            
                              if has_key(s:command_modifiers, a:ctx.cmd)
                                let a:ctx.cmd = ''
                                let a:ctx.expand = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
                              endif
                            
                              call wilder#cmdline#main#skip_whitespace(a:ctx)
                            
                              let l:flags = get(s:command_flags, a:ctx.cmd, 0)
                            
                              let l:use_filter = 0
                            
                              if a:ctx.cmd ==# 'write' || a:ctx.cmd ==# 'update'
                                if a:ctx.cmdline[a:ctx.pos] ==# '>'
                                  if a:ctx.cmdline[a:ctx.pos + 1] ==# '>'
                                    let a:ctx.pos += 2
                                  endif
                            
                                  call wilder#cmdline#main#skip_whitespace(a:ctx)
                                endif
                            
                                if a:ctx.cmd ==# 'write' && a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                endif
                              elseif a:ctx.cmd ==# 'read'
                                if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                else
                                  let l:use_filter = a:ctx.force
                                endif
                              elseif a:ctx.cmd ==# '<' || a:ctx.cmd ==# '>'
                                while a:ctx.cmdline[a:ctx.pos] ==# a:ctx.cmd
                                  let a:ctx.pos += 1
                                endwhile
                            
                                call wilder#cmdline#main#skip_whitespace(a:ctx)
                              endif
                            
                              " Handle +cmd or ++opt
                              if a:ctx.cmdline[a:ctx.pos] ==# '+' && ((and(l:flags, s:EDITCMD) && !l:use_filter) || and(l:flags, s:ARGOPT))
                                let l:allow_opt = 1
                                let l:allow_cmd = and(l:flags, s:EDITCMD) && !l:use_filter
                            
                                while a:ctx.cmdline[a:ctx.pos] ==# '+' && a:ctx.pos < len(a:ctx.cmdline)
                                  let a:ctx.pos += 1
                            
                                  if a:ctx.cmdline[a:ctx.pos] ==# '+'
                                    if l:allow_opt
                                      let a:ctx.pos += 1
                                      let l:expand = 'file_opt'
                                    else
                                      let l:expand = 'nothing'
                                    endif
                                  elseif l:allow_cmd
                                    let l:expand = 'command'
                                    " ++opt must be before +cmd
                                    let l:allow_opt = 0
                                    " only 1 +cmd allowed
                                    let l:allow_cmd = 0
                                  else
                                    let l:expand = 'nothing'
                                  endif
                            
                                  let l:arg_start = a:ctx.pos
                            
                                  " skip to next arg
                                  while a:ctx.pos < len(a:ctx.cmdline) && !wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
                                    if a:ctx.cmdline[a:ctx.pos] ==# '\' && a:ctx.pos + 1 < len(a:ctx.cmdline)
                                      let a:ctx.pos += 1
                                    endif
                            
                                    " TODO: multibyte
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  " still in command or option
                                  if empty(a:ctx.cmdline[a:ctx.pos])
                                    let a:ctx.pos = l:arg_start
                                    let a:ctx.expand = l:expand
                                    return
                                  endif
                            
                                  call wilder#cmdline#main#skip_whitespace(a:ctx)
                                endwhile
                            
                                if a:ctx.cmd ==# 'write' && a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                elseif a:ctx.cmd ==# 'read'
                                  if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                    let a:ctx.pos += 1
                                    let l:use_filter = 1
                                  else
                                    let l:use_filter = a:ctx.force
                                  endif
                                endif
                              endif
                            
                              " look for | for new command and " for comment
                              if and(l:flags, s:TRLBAR) && !l:use_filter
                                if a:ctx.cmd ==# 'redir' && a:ctx.cmdline[a:ctx.pos] ==# '@' && a:ctx.cmdline[a:ctx.pos + 1] ==# '"'
                                  let a:ctx.pos += 2
                                endif
                            
                                let l:lookahead = a:ctx.pos
                                while l:lookahead < len(a:ctx.cmdline)
                                  if a:ctx.cmdline[l:lookahead] ==# "\<C-V>" || a:ctx.cmdline[l:lookahead] ==# '\'
                                    let l:lookahead += 1
                            
                                    if l:lookahead + 1 < len(a:ctx.cmdline)
                                      let l:lookahead += 1
                                    else
                                      break
                                    endif
                                  endif
                            
                                  " Check if " indicates a comment or start of string
                                  if a:ctx.cmdline[l:lookahead] ==# '"'
                                    let l:lookahead += 1
                            
                                    let l:end_quote_reached = 0
                                    " Consume until next char is " or end of cmdline is reached
                                    while l:lookahead < len(a:ctx.cmdline)
                                      if a:ctx.cmdline[l:lookahead] ==# '\'
                                        let l:lookahead += 1
                                      elseif a:ctx.cmdline[l:lookahead] ==# '"'
                                        let l:end_quote_reached = 1
                                        let l:lookahead += 1
                                        break
                                      endif
                            
                                      let l:lookahead += 1
                                    endwhile
                            
                                    " remaining part of cmdline is comment, treat as no arguments
                                    if !l:end_quote_reached
                                      let a:ctx.pos = len(a:ctx.cmdline)
                                      return
                                    endif
                            
                                  " start of new command
                                  elseif a:ctx.cmdline[l:lookahead] ==# '|'
                                    let a:ctx.pos = l:lookahead + 1
                                    let a:ctx.cmd = ''
                                    let a:ctx.expand = ''
                            
                                    call wilder#cmdline#main#do(a:ctx)
                            
                                    return
                                  endif
                            
                                  " TODO: multibyte
                                  let l:lookahead += 1
                                endwhile
                              endif
                            
                              " command does not take extra arguments
                              if !and(l:flags, s:EXTRA) && !l:is_user_cmd
                                " consume whitespace
                                call wilder#cmdline#main#skip_whitespace(a:ctx)
                            
                                " and check for | or "
                                if a:ctx.cmdline[a:ctx.pos] ==# '|'
                                  let a:ctx.pos += 1
                                  let a:ctx.cmd = ''
                                  let a:ctx.expand = ''
                            
                                  call wilder#cmdline#main#do(a:ctx)
                                  return
                                else
                                  " remaining part is either comment or invalid arguments
                                  " either way, treat as no arguments
                                  let a:ctx.pos = len(a:ctx.cmdline)
                                  let a:ctx.expand = 'nothing'
                                  return
                                endif
                              endif
                            
                            
                              if l:use_filter || a:ctx.cmd ==# '!' || a:ctx.cmd ==# 'terminal'
                                let l:before_args = a:ctx.pos
                            
                                if !wilder#cmdline#main#skip_nonwhitespace(a:ctx)
                                  let a:ctx.pos = l:before_args
                                  let a:ctx.expand = 'shellcmd'
                                  return
                                endif
                            
                                " Reset pos back to before_args
                                let a:ctx.pos = l:before_args
                              endif
                            
                              if and(l:flags, s:XFILE)
                                " TODO: handle backticks :h backtick-expansion
                            
                                let l:arg_start = a:ctx.pos
                            
                                " Check if completing $ENV
                                if a:ctx.cmdline[a:ctx.pos] ==# '$'
                                  let l:arg_start = a:ctx.pos
                                  let a:ctx.pos += 1
                            
                                  while a:ctx.pos < len(a:ctx.cmdline)
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                    if !s:is_idc(l:char)
                                      break
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  if a:ctx.pos == len(a:ctx.cmdline)
                                    let a:ctx.expand = 'environment'
                                    let a:ctx.pos = l:arg_start + 1
                                    return
                                  endif
                                endif
                            
                                " Check if completing ~user
                                if a:ctx.cmdline[a:ctx.pos] ==# '~'
                                  let l:allow_backslash = has('win32') || has('win64')
                            
                                  while a:ctx.pos < len(a:ctx.cmdline)
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                    if l:char ==# '/' || l:allow_backslash && l:char ==# '\' || !s:is_filec(l:char)
                                      break
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  " + 1 since we want to expand ~ to $HOME
                                  if a:ctx.pos == len(a:ctx.cmdline) && a:ctx.pos > l:arg_start + 1
                                    let a:ctx.expand = 'user'
                                    let a:ctx.pos = l:arg_start + 1
                                    return
                                  endif
                                endif
                            
                                let a:ctx.pos = l:arg_start
                                let a:ctx.expand = 'file'
                            
                                " vim assumes for XFILE, we can ignore arguments other than the last one but
                                " this is not necessarily true, we should not do this for NOSPC
                                if !and(l:flags, s:NOSPC)
                                  call s:move_pos_to_last_arg(a:ctx)
                                endif
                              endif
                            
                              if a:ctx.cmd ==# 'find' || a:ctx.cmd ==# 'sfind' || a:ctx.cmd ==# 'tabfind'
                                if a:ctx.expand ==# 'file'
                                  let a:ctx.expand = 'file_in_path'
                                endif
                                return
                              elseif a:ctx.cmd ==# 'cd' || a:ctx.cmd ==# 'chdir' || a:ctx.cmd ==# 'lcd' || a:ctx.cmd ==# 'lchdir' || a:ctx.cmd ==# 'tcd' || a:ctx.cmd ==# 'tchdir'
                                if a:ctx.expand ==# 'file'
                                  let a:ctx.expand = 'dir'
                                endif
                                return
                              elseif a:ctx.cmd ==# 'help'
                                let a:ctx.expand = 'help'
                                return
                              " command modifiers
                              elseif has_key(s:command_modifiers, a:ctx.cmd)
                                let a:ctx.cmd = ''
                                let a:ctx.expand = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
                              elseif a:ctx.cmd ==# 'filter'
                                call wilder#cmdline#filter#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'match'
                                call wilder#cmdline#match#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'command'
                                call wilder#cmdline#command#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'delcommand'
                                let a:ctx.expand = 'user_commands'
                                return
                              elseif a:ctx.cmd ==# 'global' || a:ctx.cmd ==# 'vglobal'
                                call wilder#cmdline#global#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# '&' || a:ctx.cmd ==# 'substitute'
                                call wilder#cmdline#substitute#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'isearch' || a:ctx.cmd ==# 'dsearch' || a:ctx.cmd ==# 'ilist' || a:ctx.cmd ==# 'dlist' || a:ctx.cmd ==# 'ijump' || a:ctx.cmd ==# 'psearch' || a:ctx.cmd ==# 'djump' || a:ctx.cmd ==# 'isplit' || a:ctx.cmd ==# 'dsplit'
                                call wilder#cmdline#isearch#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'autocmd'
                                call wilder#cmdline#autocmd#do(a:ctx, 0)
                                return
                              elseif a:ctx.cmd ==# 'doautocmd' || a:ctx.cmd ==# 'doautoall'
                                call wilder#cmdline#autocmd#do(a:ctx, 1)
                              elseif a:ctx.cmd ==# 'set' || a:ctx.cmd ==# 'setglobal' || a:ctx.cmd ==# 'setlocal'
                                call wilder#cmdline#set#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'tag' || a:ctx.cmd ==# 'stag' || a:ctx.cmd ==# 'ptag' || a:ctx.cmd ==# 'ltag' || a:ctx.cmd ==# 'tselect' || a:ctx.cmd ==# 'stselect' || a:ctx.cmd ==# 'tjump' || a:ctx.cmd ==# 'stjump' || a:ctx.cmd ==# 'ptselect' || a:ctx.cmd ==# 'ptjump'
                                let a:ctx.expand = 'tags'
                                return
                              elseif a:ctx.cmd ==# 'augroup'
                                let a:ctx.expand = 'augroup'
                              elseif a:ctx.cmd ==# 'syntax'
                                call wilder#cmdline#syntax#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'let' || a:ctx.cmd ==# 'if' || a:ctx.cmd ==# 'elseif' || a:ctx.cmd ==# 'while' || a:ctx.cmd ==# 'for' || a:ctx.cmd ==# 'echo' || a:ctx.cmd ==# 'echon' || a:ctx.cmd ==# 'execute' || a:ctx.cmd ==# 'echomsg' || a:ctx.cmd ==# 'echoerr' || a:ctx.cmd ==# 'call' || a:ctx.cmd ==# 'return' || a:ctx.cmd ==# 'cexpr' || a:ctx.cmd ==# 'caddexpr' || a:ctx.cmd ==# 'cgetexpr' || a:ctx.cmd ==# 'lexpr' || a:ctx.cmd ==# 'laddexpr' || a:ctx.cmd ==# 'lgetexpr'
                                "TODO call has extra arugments
                                call wilder#cmdline#let#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'unlet'
                                call wilder#cmdline#unlet#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'function'
                                let a:ctx.expand = 'function'
                                return
                              elseif a:ctx.cmd ==# 'delfunction'
                                let a:ctx.expand = 'user_func'
                                return
                              elseif a:ctx.cmd ==# 'echohl'
                                let a:ctx.expand = 'highlight'
                                " TODO: include None
                                return
                              elseif a:ctx.cmd ==# 'highlight'
                                call wilder#cmdline#highlight#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'cscope' || a:ctx.cmd ==# 'lcscope' || a:ctx.cmd ==# 'scscope'
                                call wilder#cmdline#cscope#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'sign'
                                call wilder#cmdline#sign#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'bdelete' || a:ctx.cmd ==# 'bwipeout' || a:ctx.cmd ==# 'bunload'
                                let a:ctx.expand = 'buffer'
                                return
                              elseif a:ctx.cmd ==# 'buffer' || a:ctx.cmd ==# 'sbuffer' || a:ctx.cmd ==# 'checktime'
                                let a:ctx.expand = 'buffer'
                                return
                              elseif a:ctx.cmd ==# 'abbreviate' || a:ctx.cmd ==# 'unabbreviate' || a:ctx.cmd[-3 :] ==# 'map' || a:ctx.cmd[-6 :] ==# 'abbrev'
                                call wilder#cmdline#map#do(a:ctx)
                                return
                              elseif a:ctx.cmd[-8 :] ==# 'mapclear'
                                let a:ctx.expand = 'mapclear'
                                return
                              elseif a:ctx.cmd[-4 :] ==# 'menu'
                                call wilder#cmdline#menu#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'colorscheme'
                                let a:ctx.expand = 'color'
                                return
                              elseif a:ctx.cmd ==# 'compiler'
                                let a:ctx.expand = 'compiler'
                                return
                              elseif a:ctx.cmd ==# 'ownsyntax'
                                let a:ctx.expand = 'ownsyntax'
                                return
                              elseif a:ctx.cmd ==# 'packadd'
                                let a:ctx.expand = 'packadd'
                                return
                              elseif a:ctx.cmd ==# 'language'
                                let l:arg_start = a:ctx.pos
                                call wilder#cmdline#main#skip_nonwhitespace(a:ctx)
                            
                                if a:ctx.pos == len(a:ctx.cmdline)
                                  let a:ctx.expand = 'language'
                                  let a:ctx.pos = l:arg_start
                                else
                                  let l:subcommand = a:ctx.cmdline[l:arg_start : a:ctx.pos - 1]
                                  if l:subcommand ==# 'messages' || l:subcommand ==# 'ctype' || l:subcommand ==# 'time'
                                    let a:ctx.expand = 'locales'
                                    call wilder#cmdline#main#skip_whitespace(a:ctx)
                                  endif
                                endif
                              elseif a:ctx.cmd ==# 'profile'
                                call wilder#cmdline#profile#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'checkhealth'
                                let a:ctx.expand = 'checkhealth'
                                call s:move_pos_to_last_arg(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'behave'
                                let a:ctx.expand = 'behave'
                                return
                              elseif a:ctx.cmd ==# 'messages'
                                let a:ctx.expand = 'messages'
                                return
                              elseif a:ctx.cmd ==# 'history'
                                let a:ctx.expand = 'history'
                                return
                              elseif a:ctx.cmd ==# 'syntime'
                                let a:ctx.expand = 'syntime'
                                return
                              elseif a:ctx.cmd ==# 'argdelete'
                                let a:ctx.expand = 'arglist'
                                return
                              elseif a:ctx.cmd ==# 'lua'
                                let a:ctx.expand = 'lua'
                                return
                              endif

FUNCTION  <lambda>140()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:198
Called 2 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            return x

FUNCTION  <lambda>141()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:198
Called 2 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            return x

FUNCTION  <lambda>142()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 2 times
Total time:   0.000061
 Self time:   0.000029

count  total (s)   self (s)
                            return wilder#cmdline#prepare_user_completion(ctx, res)

FUNCTION  <lambda>143()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
                            return {ctx -> s:branch(a:args, ctx, x)}

FUNCTION  <lambda>144()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 2 times
Total time:   0.000023
 Self time:   0.000018

count  total (s)   self (s)
                            return l:sort_buffers_lastused ? s:sort_buffers_lastused(ctx, xs, data) : xs

FUNCTION  <lambda>145()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 2 times
Total time:   0.000031
 Self time:   0.000011

count  total (s)   self (s)
                            return s:set_query(data)

FUNCTION  <lambda>146()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:2
Called 2 times
Total time:   0.000255
 Self time:   0.000015

count  total (s)   self (s)
                            return s:result_start(l:args, ctx, x)

FUNCTION  <SNR>107_StatusNotification()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:595
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001   let a:instance.status = a:params

FUNCTION  <SNR>105_RunDeferred()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/util.vim:12
Called 86 times
Total time:   0.016089
 Self time:   0.001322

count  total (s)   self (s)
   86              0.000236   if empty(s:deferred)
   43              0.000021     return
   43              0.000022   endif
   43              0.000148   let Fn = remove(s:deferred, 0)
   43              0.000180   call timer_start(0, function('s:RunDeferred'))
   43   0.015386   0.000619   call call(Fn, [])

FUNCTION  copilot#OnVimLeavePre()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:468
Called 1 time
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)

FUNCTION  <SNR>59_result_start()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:6
Called 6 times
Total time:   0.000609
 Self time:   0.000143

count  total (s)   self (s)
    6              0.000004   let l:kvs = []
   14              0.000013   for l:key in keys(a:args)
    8              0.000020     call add(l:kvs, {'key': l:key, 'value': a:args[l:key]})
   14              0.000018   endfor
                            
    6              0.000011   let l:result = type(a:x) isnot v:t_dict ? {'value': a:x} : a:x
                            
    6              0.000005   if empty(l:kvs)
                                return l:result
    6              0.000001   endif
                            
    6   0.000516   0.000050   return s:result(l:kvs, a:ctx, l:result)

FUNCTION  <SNR>107_RegisterWorkspaceFolderForBuffer()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:203
Called 18 times
Total time:   0.001006
 Self time:   0.000503

count  total (s)   self (s)
   18              0.000065   let root = getbufvar(a:buf, 'workspace_folder')
   18              0.000036   if type(root) != v:t_string
                                return
   18              0.000016   endif
   18   0.000788   0.000285   let root = s:UriFromPath(substitute(root, '[\/]$', '', ''))
   18              0.000051   if empty(root) || has_key(a:instance.workspaceFolders, root)
   18              0.000009     return
                              endif
                              let a:instance.workspaceFolders[root] = v:true
                              call a:instance.Notify('workspace/didChangeWorkspaceFolders', {'event': {'added': [{'uri': root, 'name': fnamemodify(root, ':t')}], 'removed': []}})

FUNCTION  <SNR>54_move()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:198
Called 3 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    3              0.000003   if self.state.window_state ==# 'hidden'
                                return
    3              0.000001   endif
                            
    3              0.000002   if self.state.window_state ==# 'pending'
                                let self.state.dimensions = [a:row, a:col, a:height, a:width]
                                return
    3              0.000000   endif
                            
    3              0.000018   call nvim_win_set_config(self.state.win, { 'relative': 'editor', 'row': a:row, 'col': a:col, 'height': a:height, 'width': a:width, })

FUNCTION  <SNR>44_devicons()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/component/popupmenu_devicons.vim:24
Called 3 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    3              0.000004   if !has_key(a:result, 'data')
                                return ''
    3              0.000001   endif
                            
    3              0.000004   let l:expand = get(a:result.data, 'cmdline.expand', '')
                            
    3              0.000007   if l:expand !=# 'file' && l:expand !=# 'file_in_path' && l:expand !=# 'dir' && l:expand !=# 'shellcmd' && l:expand !=# 'buffer'
    3              0.000001     return ''
                              endif
                            
                              let l:session_id = a:ctx.session_id
                              if a:state.session_id != l:session_id
                                call a:state.cache.clear()
                                let a:state.created_hls = {}
                                let a:state.session_id = l:session_id
                              endif
                            
                              let l:slash = !has('win32') && !has('win64') ? '/' : &shellslash ? '/' : '\'
                            
                              let [l:start, l:end] = a:ctx.page
                            
                              let l:rows = repeat([0], l:end - l:start + 1)
                            
                              if !has_key(a:state, 'get_icon')
                                let a:state.get_icon = s:get_icon_func()
                              endif
                            
                              if a:state.get_icon is v:null
                                return []
                              endif
                            
                              if !has_key(a:state, 'get_hl')
                                let a:state.get_hl = s:get_hl_func()
                              endif
                            
                              let l:i = l:start
                              while l:i <= l:end
                                let l:index = l:i - l:start
                            
                                let l:x = wilder#main#get_candidate(a:ctx, a:result, l:i)
                            
                                if a:state.cache.has_key(l:x)
                                  let l:rows[l:index] = a:state.cache.get(l:x)
                            
                                  let l:i += 1
                                  continue
                                endif
                            
                                let l:is_dir = l:x[-1:] ==# l:slash || l:x[-1:] ==# '/'
                            
                                let l:icon = a:state.get_icon(a:ctx, l:x, l:is_dir)
                                let l:icon_width = strdisplaywidth(l:icon)
                                if l:icon_width < a:state.min_width
                                  let l:icon .= repeat(' ', a:state.min_width - l:icon_width)
                                endif
                            
                                if a:state.get_hl is v:null
                                  let l:chunks = [[a:state.left_padding . l:icon . a:state.right_padding]]
                                else
                                  let l:hl = a:state.get_hl(a:ctx, l:x, l:is_dir, l:icon)
                            
                                  if !has_key(a:state.created_hls, l:hl)
                                    let l:guifg = s:get_guifg(l:hl)
                                    let l:default_hl = s:make_temp_hl(l:hl, a:ctx.highlights['default'], l:guifg)
                            
                                    if a:state.combine_selected_hl
                                      let l:selected_hl = s:make_temp_hl(l:hl . '_Selected', a:ctx.highlights['selected'], l:guifg)
                                    else
                                      let l:selected_hl = a:ctx.highlights['selected']
                                    endif
                            
                                    let a:state.created_hls[l:hl] = [l:default_hl, l:selected_hl]
                                  endif
                            
                                  let [l:default_hl, l:selected_hl] = a:state.created_hls[l:hl]
                                  let l:chunks = [[a:state.left_padding], [l:icon, l:default_hl, l:selected_hl], [a:state.right_padding]]
                                endif
                            
                                call a:state.cache.set(l:x, l:chunks)
                            
                                let l:rows[l:index] = l:chunks
                            
                                let l:i += 1
                              endwhile
                            
                              let l:height = a:ctx.height
                              let l:width = empty(l:rows) ? 0 : wilder#render#chunks_displaywidth(l:rows[0])
                              let l:empty_row = [[repeat(' ', l:width)]]
                              let l:rows += repeat([l:empty_row], l:height - len(l:rows))
                            
                              return l:rows

FUNCTION  <SNR>55_sort_buffers_lastused()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1398
Called 2 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    2              0.000003   if get(a:data, 'cmdline.expand', '') !=# 'buffer'
    2              0.000001     return a:xs
                              endif
                            
                              let l:bufinfos = getbufinfo()
                              let l:bufnr_to_x = {}
                            
                              for l:x in a:xs
                                let l:bufname = fnamemodify(l:x, ':~')
                                let l:bufnr = bufnr('^' . l:x . '$')
                            
                                let l:bufnr_to_x[l:bufnr] = l:x
                              endfor
                            
                              let l:x_to_info = {}
                              let l:seen = {}
                            
                              for l:info in l:bufinfos
                                let l:bufnr = l:info.bufnr
                            
                                if !has_key(l:bufnr_to_x, l:bufnr)
                                  continue
                                endif
                            
                                let l:x = l:bufnr_to_x[l:bufnr]
                                let l:x_to_info[l:x] = l:info
                                let l:seen[l:bufnr] = 1
                              endfor
                            
                              let l:xs = copy(a:xs)
                              let l:match_arg = get(a:data, 'cmdline.match_arg', '')
                            
                              " add matching bufnr
                              if l:match_arg =~# '\d\+'
                                for l:info in l:bufinfos
                                  let l:bufnr = l:info.bufnr
                                  let l:bufname = l:info.name
                            
                                  if !l:info.listed || empty(l:bufname) || has_key(l:seen, l:bufnr)
                                    continue
                                  endif
                            
                                  if stridx(l:bufnr, l:match_arg) == 0
                                    let l:bufname = fnamemodify(l:bufname, ':~:.')
                                    let l:x_to_info[l:bufname] = l:info
                                    call add(l:xs, l:bufname)
                                  endif
                                endfor
                              endif
                            
                              let l:current_bufnr = bufnr('%')
                            
                              return sort(l:xs, {x1, x2 -> s:sort_buffers_lastused_func(x1, x2, l:x_to_info, l:current_bufnr)})

FUNCTION  wilder#cmdline#main#skip_whitespace()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/main.vim:683
Called 4 times
Total time:   0.000113
 Self time:   0.000096

count  total (s)   self (s)
    4              0.000006   if empty(a:ctx.cmdline[a:ctx.pos])
                                return 0
    4              0.000001   endif
                            
    4   0.000081   0.000064   while wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
                                let a:ctx.pos += 1
                            
                                if empty(a:ctx.cmdline[a:ctx.pos])
                                  return 0
                                endif
    4              0.000003   endwhile
                            
    4              0.000002   return 1

FUNCTION  wilder#cmdline#is_user_command()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:608
Called 2 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    2              0.000005   return !empty(a:cmd) && a:cmd[0] >=# 'A' && a:cmd[0] <=# 'Z'

FUNCTION  <SNR>51_make_page()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:195
Called 6 times
Total time:   0.000154
 Self time:   0.000124

count  total (s)   self (s)
    6              0.000009   if empty(a:result.value)
    2              0.000002     return [-1, -1]
    4              0.000001   endif
                            
    4              0.000004   let l:page = a:state.page
    4              0.000003   let l:selected = a:ctx.selected
                              " Adjust -1 (unselected) to show the top of the list.
    4              0.000005   let l:selected = l:selected == -1 ? 0 : l:selected
                            
                              " Adjust previous page.
    4              0.000005   if l:page != [-1, -1]
    2              0.000004     if l:page[0] > len(a:result.value)
                                  let l:page = [-1, -1]
    2              0.000003     elseif l:page[1] > len(a:result.value)
                                  let l:page[1] = len(a:result.value) - 1
    2              0.000001     endif
    4              0.000001   endif
                            
    4              0.000003   if l:page != [-1, -1]
                                " Selected is within current page, reuse the page.
    2              0.000004     if l:selected != -1 && l:selected >= l:page[0] && l:selected <= l:page[1]
    2              0.000001       return l:page
                                endif
                            
                                " Scroll the page forward.
                                if a:ctx.direction >= 0 && l:page[1] < l:selected
                                  " calculate distance moved.
                                  let l:moved = l:selected - l:page[1]
                                  return [l:page[0] + l:moved, l:selected]
                                endif
                            
                                " Scroll the page backward.
                                if a:ctx.direction < 0 && l:page[0] > l:selected
                                  " calculate distance moved.
                                  let l:moved = l:page[0] - l:selected
                                  return [l:selected, l:page[1] - l:moved]
                                endif
    2              0.000000   endif
                            
                              " Otherwise make a new page.
                            
    2   0.000029   0.000008   let l:max_height = a:state.get_max_height(a:ctx, a:result)
    2   0.000016   0.000007   let l:min_height = a:state.get_min_height(a:ctx, a:result)
    2              0.000001   if l:max_height < l:min_height
                                let l:max_height = l:min_height
    2              0.000000   endif
    2              0.000002   let l:max_height -= len(a:state.top)
    2              0.000002   let l:max_height -= len(a:state.bottom)
                              " Assume the worst case scenario that the cursor is on the top row of the
                              " cmdline.
    2              0.000004   let l:max_height = min([l:max_height, &lines - &cmdheight - 1])
                            
                              " Page starts at selected.
    2              0.000001   if a:ctx.direction >= 0
    2              0.000001     let l:start = l:selected
                            
                                " Try to include all candidates after selected.
    2              0.000002     let l:height = len(a:result.value) - l:selected
                            
    2              0.000001     if l:height > l:max_height
    1              0.000001       let l:height = l:max_height
    2              0.000000     endif
                            
    2              0.000002     return [l:start, l:start + l:height - 1]
                              endif
                            
                              " Page ends at selected.
                              let l:end = l:selected
                            
                              " Try to include all candidates before selected.
                              let l:height = l:selected
                            
                              if l:height > l:max_height
                                let l:height = l:max_height
                              endif
                            
                              return [l:end - l:height + 1, l:end]

FUNCTION  <SNR>113_pre_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:224
Called 1 time
Total time:   0.004354
 Self time:   0.000039

count  total (s)   self (s)
    1   0.002082   0.000012   call wilder#highlight#init_hl()
                            
    1              0.000002   if has_key(s:opts, 'pre_hook')
                                call s:opts.pre_hook({})
    1              0.000000   endif
                            
    1              0.000002   if has_key(s:opts.renderer, 'pre_hook')
    1   0.002264   0.000019     call s:opts.renderer.pre_hook({})
    1              0.000000   endif

FUNCTION  <SNR>107_NvimAttach()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:431
Called 31 times
Total time:   0.009341
 Self time:   0.002766

count  total (s)   self (s)
   31              0.000055   if !bufloaded(a:bufnr)
                                return {'uri': '', 'version': 0}
   31              0.000012   endif
   31   0.008265   0.001691   call luaeval('pcall(vim.lsp.buf_attach_client, _A[1], _A[2])', [a:bufnr, self.id])
   31              0.000933   return luaeval('{uri = vim.uri_from_bufnr(_A), version = vim.lsp.util.buf_versions[_A]}', a:bufnr)

FUNCTION  <SNR>47_prompt_post_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:419
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004   call timer_stop(a:state.timer)

FUNCTION  <lambda>74()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:843
Called 5 times
Total time:   0.000046
 Self time:   0.000026

count  total (s)   self (s)
                            return s:clamp(float2nr(l:percent * (&lines - 1)), a:is_height)

FUNCTION  <lambda>172()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
                            return {ctx -> s:branch(a:args, ctx, x)}

FUNCTION  wilder#main#draw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:412
Called 2 times
Total time:   0.000919
 Self time:   0.000020

count  total (s)   self (s)
    2              0.000003   if !s:active || !s:enabled
                                return 0
    2              0.000001   endif
                            
    2   0.000911   0.000012   call s:draw()
    2              0.000001   return 1

FUNCTION  <lambda>75()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:832
Called 8 times
Total time:   0.000068
 Self time:   0.000056

count  total (s)   self (s)
                            return s:clamp(a:opt, a:is_height)

FUNCTION  <lambda>76()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:845
Called 3 times
Total time:   0.000025
 Self time:   0.000014

count  total (s)   self (s)
                            return s:clamp(float2nr(l:percent * &columns), a:is_height)

FUNCTION  <lambda>77()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:845
Called 3 times
Total time:   0.000021
 Self time:   0.000011

count  total (s)   self (s)
                            return s:clamp(float2nr(l:percent * &columns), a:is_height)

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   65   0.092474             provider#python3#Call()
   51   0.072979             UltiSnips#TrackChange()
 2597   0.054470   0.046694  wilder#lua#wrap()
    5   0.051545   0.000102  <SNR>51_render_lines_from_timer()
    3   0.051443   0.008230  <SNR>51_render_lines()
   61   0.045794   0.001154  wilder#lua#call_wrapped_function()
   33   0.035450             <SNR>98_SynSet()
    2   0.026054   0.000044  wildfire#Fuel()
    2   0.026010   0.000754  <SNR>121_select_text_object()
    3   0.025402   0.005465  <SNR>51_make_lines()
   22   0.024802   0.002081  <SNR>118_run()
   14   0.023373   0.000377  <SNR>121_edges()
   16   0.019989   0.002329  <SNR>121_select()
    8   0.018814   0.017444  <SNR>1_LoadFTPlugin()
   86   0.016089   0.001322  <SNR>105_RunDeferred()
    8   0.016047   0.000089  wilder#pipeline#resolve()
    8   0.015958   0.000284  <SNR>118_handle()
  165   0.013889   0.012046  <SNR>75_Highlight_Matching_Pair()
   18   0.013574   0.000836  <SNR>104_Trigger()
   18   0.012738   0.000734  copilot#Suggest()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   65              0.092474  provider#python3#Call()
   51              0.072979  UltiSnips#TrackChange()
 2597   0.054470   0.046694  wilder#lua#wrap()
   33              0.035450  <SNR>98_SynSet()
    8   0.018814   0.017444  <SNR>1_LoadFTPlugin()
    3              0.012096  <SNR>117_redraw()
  165   0.013889   0.012046  <SNR>75_Highlight_Matching_Pair()
    3   0.051443   0.008230  <SNR>51_render_lines()
   12              0.006003  UltiSnips#CheckFiletype()
    3   0.025402   0.005465  <SNR>51_make_lines()
   18   0.005182   0.004770  <SNR>107_NvimDoRequest()
    8   0.004895   0.004682  <SNR>2_LoadIndent()
   43   0.008327   0.004468  <SNR>104_UpdatePreview()
  255              0.003218  wilder#render#chunks_displaywidth()
   31   0.009341   0.002766  <SNR>107_NvimAttach()
   43   0.002889   0.002720  <SNR>104_SuggestionTextWithAdjustments()
   16   0.019989   0.002329  <SNR>121_select()
  187              0.002165  <SNR>75_Remove_Matches()
   85   0.004066   0.002109  <SNR>51_draw_candidate()
   18   0.004929   0.002092  <SNR>107_PreprocessParams()

